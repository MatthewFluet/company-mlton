type 'a array = 'a array (* @ $(SML_LIB)/basis/arrays-and-vectors/array.sml 21.15-21.19 *)
datatype bool = false | true (* = datatype bool *) (* @ $(SML_LIB)/basis/general/bool.sml 11.16-11.19 *)
type char = char (* @ $(SML_LIB)/basis/text/string.sml 27.12-27.15 *)
type exn = exn (* @ $(SML_LIB)/basis/general/general.sml 13.12-13.14 *)
type int = int (* @ $(SML_LIB)/basis/primitive/prim-basis.sml 228.12-228.14 *)
datatype 'a list = :: of 'a * 'a list | nil (* = datatype 'a list *) (* @ $(SML_LIB)/basis/list/list.sml 13.15-13.18 *)
datatype 'a option = NONE | SOME of 'a (* = datatype 'a option *) (* @ $(SML_LIB)/basis/general/option.sml 12.10-12.15 *)
datatype order = EQUAL | GREATER | LESS (* = datatype order *) (* @ $(SML_LIB)/basis/general/general.sml 25.16-25.20 *)
type real = real (* @ $(SML_LIB)/basis/real/real.sml 26.12-26.15 *)
datatype 'a ref = ref of 'a (* = datatype 'a ref *) (* @ $(SML_LIB)/basis/libs/basis-extra/top-level/basis.sml 277.16-277.18 *)
type string = string (* @ $(SML_LIB)/basis/text/string.sml 28.12-28.17 *)
type substring = char VectorSlice.slice (* @ $(SML_LIB)/basis/text/substring.sml 23.12-23.20 *)
type unit = unit (* @ $(SML_LIB)/basis/general/general.sml 11.12-11.15 *)
type 'a vector = 'a vector (* @ $(SML_LIB)/basis/arrays-and-vectors/vector.sml 15.15-15.20 *)
type word = word (* @ $(SML_LIB)/basis/primitive/prim-basis.sml 426.12-426.15 *)
val ! : 'a ref -> 'a (* @ $(SML_LIB)/basis/general/general.sml 27.11-27.11 *)
val * : 'a * 'a -> 'a (* @ $(SML_LIB)/basis/libs/basis-2002/top-level/overloads.sml 240.13-240.13 *)
val + : 'a * 'a -> 'a (* @ $(SML_LIB)/basis/libs/basis-2002/top-level/overloads.sml 82.13-82.13 *)
val - : 'a * 'a -> 'a (* @ $(SML_LIB)/basis/libs/basis-2002/top-level/overloads.sml 161.13-161.13 *)
val / : 'a * 'a -> 'a (* @ $(SML_LIB)/basis/libs/basis-2002/top-level/overloads.sml 319.13-319.13 *)
con :: : 'a * 'a list -> 'a list (* @ <bogus> ~1.~1 *)
val := : 'a ref * 'a -> unit (* @ $(SML_LIB)/basis/general/general.sml 28.14-28.15 *)
val < : 'a * 'a -> bool (* @ $(SML_LIB)/basis/libs/basis-2002/top-level/overloads.sml 518.13-518.13 *)
val <= : 'a * 'a -> bool (* @ $(SML_LIB)/basis/libs/basis-2002/top-level/overloads.sml 601.13-601.14 *)
val <> : ''a * ''a -> bool (* @ $(SML_LIB)/basis/libs/basis-extra/top-level/basis.sml 275.14-275.15 *)
val = : ''a * ''a -> bool (* @ $(SML_LIB)/basis/libs/basis-extra/top-level/basis.sml 274.14-274.14 *)
val > : 'a * 'a -> bool (* @ $(SML_LIB)/basis/libs/basis-2002/top-level/overloads.sml 684.13-684.13 *)
val >= : 'a * 'a -> bool (* @ $(SML_LIB)/basis/libs/basis-2002/top-level/overloads.sml 767.13-767.14 *)
val @ : 'a list * 'a list -> 'a list (* @ $(SML_LIB)/basis/list/list.sml 55.13-55.13 *)
exn Bind: exn (* @ $(SML_LIB)/basis/general/general.sml 14.17-14.20 *)
exn Chr: exn (* @ $(SML_LIB)/basis/general/general.sml 16.17-16.19 *)
exn Div: exn (* @ $(SML_LIB)/basis/general/general.sml 17.17-17.19 *)
exn Domain: exn (* @ $(SML_LIB)/basis/general/general.sml 18.17-18.22 *)
con EQUAL: order (* @ $(SML_LIB)/basis/primitive/prim1.sml 61.27-61.31 *)
exn Empty: exn (* @ $(SML_LIB)/basis/list/list.sml 15.16-15.20 *)
exn Fail: string -> exn (* @ $(SML_LIB)/basis/general/general.sml 19.17-19.20 *)
con GREATER: order (* @ $(SML_LIB)/basis/primitive/prim1.sml 61.35-61.41 *)
con LESS: order (* @ $(SML_LIB)/basis/primitive/prim1.sml 61.20-61.23 *)
exn Match: exn (* @ $(SML_LIB)/basis/general/general.sml 15.17-15.21 *)
con NONE: 'a option (* @ $(SML_LIB)/basis/primitive/prim1.sml 67.23-67.26 *)
exn Option: exn (* @ $(SML_LIB)/basis/general/option.sml 14.11-14.16 *)
exn Overflow: exn (* @ $(SML_LIB)/basis/general/general.sml 20.17-20.24 *)
con SOME: 'a -> 'a option (* @ $(SML_LIB)/basis/primitive/prim1.sml 67.30-67.33 *)
exn Size: exn (* @ $(SML_LIB)/basis/general/general.sml 21.17-21.20 *)
exn Span: exn (* @ $(SML_LIB)/basis/general/general.sml 22.17-22.20 *)
exn Subscript: exn (* @ $(SML_LIB)/basis/general/general.sml 23.17-23.25 *)
val ^ : string * string -> string (* @ $(SML_LIB)/basis/text/string.sml 35.14-35.14 *)
val abs: 'a -> 'a (* @ $(SML_LIB)/basis/libs/basis-2002/top-level/overloads.sml 475.13-475.15 *)
val app: ('a -> unit) -> 'a list -> unit (* @ $(SML_LIB)/basis/list/list.sml 64.10-64.12 *)
val before: 'a * unit -> 'a (* @ $(SML_LIB)/basis/general/general.sml 30.13-30.18 *)
val ceil: real -> int (* @ $(SML_LIB)/basis/real/real.sml 859.11-859.14 *)
val chr: int -> char (* @ $(SML_LIB)/basis/text/char.sml 50.11-50.13 *)
val concat: string list -> string (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 462.13-462.18 *)
val div: 'a * 'a -> 'a (* @ $(SML_LIB)/basis/libs/basis-2002/top-level/overloads.sml 325.13-325.15 *)
val exnMessage: exn -> string (* @ $(SML_LIB)/basis/general/general.sml 40.18-40.27 *)
val exnName: exn -> string (* @ $(SML_LIB)/basis/general/general.sml 32.11-32.17 *)
val explode: string -> char list (* @ $(SML_LIB)/basis/text/string.sml 37.11-37.17 *)
con false: bool (* @ <bogus> ~1.~1 *)
val floor: real -> int (* @ $(SML_LIB)/basis/real/real.sml 858.11-858.15 *)
val foldl: ('a * 'b -> 'b) -> 'b -> 'a list -> 'b (* @ $(SML_LIB)/basis/list/list.sml 38.10-38.14 *)
val foldr: ('a * 'b -> 'b) -> 'b -> 'a list -> 'b (* @ $(SML_LIB)/basis/list/list.sml 60.10-60.14 *)
val getOpt: 'a option * 'a -> 'a (* @ $(SML_LIB)/basis/general/option.sml 34.5-34.10 *)
val hd: 'a list -> 'a (* @ $(SML_LIB)/basis/list/list.sml 21.10-21.11 *)
val ignore: 'a -> unit (* @ $(SML_LIB)/basis/general/general.sml 31.11-31.16 *)
val implode: char list -> string (* @ $(SML_LIB)/basis/text/string.sml 36.11-36.17 *)
val isSome: 'a option -> bool (* @ $(SML_LIB)/basis/general/option.sml 39.5-39.10 *)
val length: 'a list -> int (* @ $(SML_LIB)/basis/list/list.sml 47.10-47.15 *)
val map: ('a -> 'b) -> 'a list -> 'b list (* @ $(SML_LIB)/basis/list/list.sml 66.10-66.12 *)
val mod: 'a * 'a -> 'a (* @ $(SML_LIB)/basis/libs/basis-2002/top-level/overloads.sml 400.13-400.15 *)
con nil: 'a list (* @ <bogus> ~1.~1 *)
val not: bool -> bool (* @ $(SML_LIB)/basis/general/bool.sml 13.11-13.13 *)
val null: 'a list -> bool (* @ $(SML_LIB)/basis/list/list.sml 17.10-17.13 *)
val o: ('a -> 'b) * ('c -> 'a) -> 'c -> 'b (* @ $(SML_LIB)/basis/general/general.sml 29.14-29.14 *)
val ord: char -> int (* @ $(SML_LIB)/basis/text/char0.sml 57.30-57.32 *)
val print: string -> unit (* @ $(SML_LIB)/basis/io/text-io.sml 40.11-40.15 *)
val real: int -> real (* @ $(SML_LIB)/basis/libs/basis-extra/top-level/basis.sml 273.11-273.14 *)
con ref: 'a -> 'a ref (* @ <bogus> ~1.~1 *)
val rev: 'a list -> 'a list (* @ $(SML_LIB)/basis/list/list.sml 53.10-53.12 *)
val round: real -> int (* @ $(SML_LIB)/basis/real/real.sml 861.11-861.15 *)
val size: string -> int (* @ $(SML_LIB)/basis/text/string.sml 34.11-34.14 *)
val str: char -> string (* @ $(SML_LIB)/basis/text/string.sml 31.11-31.13 *)
val substring: string * int * int -> string (* @ $(SML_LIB)/basis/text/string.sml 41.11-41.19 *)
val tl: 'a list -> 'a list (* @ $(SML_LIB)/basis/list/list.sml 25.10-25.11 *)
con true: bool (* @ <bogus> ~1.~1 *)
val trunc: real -> int (* @ $(SML_LIB)/basis/real/real.sml 860.11-860.15 *)
val valOf: 'a option -> 'a (* @ $(SML_LIB)/basis/general/option.sml 43.5-43.9 *)
val vector: 'a list -> 'a vector (* @ $(SML_LIB)/basis/libs/basis-extra/top-level/basis.sml 276.11-276.16 *)
val ~ : 'a -> 'a (* @ $(SML_LIB)/basis/libs/basis-2002/top-level/overloads.sml 3.13-3.13 *)
signature ARRAY =
   sig
      type 'a array = 'a array
      type 'a vector = 'a vector
      val all: ('a -> bool) -> 'a array -> bool
      val app: ('a -> unit) -> 'a array -> unit
      val appi: (int * 'a -> unit) -> 'a array -> unit
      val array: int * 'a -> 'a array
      val collate: ('a * 'a -> order) -> 'a array * 'a array -> order
      val copy: {di: int, dst: 'a array, src: 'a array} -> unit
      val copyVec: {di: int, dst: 'a array, src: 'a vector} -> unit
      val exists: ('a -> bool) -> 'a array -> bool
      val find: ('a -> bool) -> 'a array -> 'a option
      val findi: (int * 'a -> bool) -> 'a array -> (int * 'a) option
      val foldl: ('a * 'b -> 'b) -> 'b -> 'a array -> 'b
      val foldli: (int * 'a * 'b -> 'b) -> 'b -> 'a array -> 'b
      val foldr: ('a * 'b -> 'b) -> 'b -> 'a array -> 'b
      val foldri: (int * 'a * 'b -> 'b) -> 'b -> 'a array -> 'b
      val fromList: 'a list -> 'a array
      val length: 'a array -> int
      val maxLen: int
      val modify: ('a -> 'a) -> 'a array -> unit
      val modifyi: (int * 'a -> 'a) -> 'a array -> unit
      val sub: 'a array * int -> 'a
      val tabulate: int * (int -> 'a) -> 'a array
      val update: 'a array * int * 'a -> unit
      val vector: 'a array -> 'a vector
   end
   (* @ $(SML_LIB)/basis/libs/basis-2002/top-level/basis-sigs.sml 9.11-9.15 *)
signature ARRAY2 =
   sig
      eqtype 'a array
      type 'a region = {base: 'a _sig.array, col: int, ncols: int option, nrows: int option, row: int}
      datatype traversal = ColMajor | RowMajor
      val app: _sig.traversal -> ('a -> unit) -> 'a _sig.array -> unit
      val appi: _sig.traversal -> (int * int * 'a -> unit) -> {base: 'a _sig.array, col: int, ncols: int option, nrows: int option, row: int} -> unit
      val array: int * int * 'a -> 'a _sig.array
      val column: 'a _sig.array * int -> 'a vector
      val copy: {dst: 'a _sig.array, dst_col: int, dst_row: int, src: {base: 'a _sig.array, col: int, ncols: int option, nrows: int option, row: int}} -> unit
      val dimensions: 'a _sig.array -> int * int
      val fold: _sig.traversal -> ('a * 'b -> 'b) -> 'b -> 'a _sig.array -> 'b
      val foldi: _sig.traversal -> (int * int * 'a * 'b -> 'b) -> 'b -> {base: 'a _sig.array, col: int, ncols: int option, nrows: int option, row: int} -> 'b
      val fromList: 'a list list -> 'a _sig.array
      val modify: _sig.traversal -> ('a -> 'a) -> 'a _sig.array -> unit
      val modifyi: _sig.traversal -> (int * int * 'a -> 'a) -> {base: 'a _sig.array, col: int, ncols: int option, nrows: int option, row: int} -> unit
      val nCols: 'a _sig.array -> int
      val nRows: 'a _sig.array -> int
      val row: 'a _sig.array * int -> 'a vector
      val sub: 'a _sig.array * int * int -> 'a
      val tabulate: _sig.traversal -> int * int * (int * int -> 'a) -> 'a _sig.array
      val update: 'a _sig.array * int * int * 'a -> unit
   end
   (* @ $(SML_LIB)/basis/libs/basis-2002/top-level/basis-sigs.sml 52.11-52.16 *)
signature ARRAY_SLICE =
   sig
      type 'a slice
      val all: ('a -> bool) -> 'a _sig.slice -> bool
      val app: ('a -> unit) -> 'a _sig.slice -> unit
      val appi: (int * 'a -> unit) -> 'a _sig.slice -> unit
      val base: 'a _sig.slice -> 'a array * int * int
      val collate: ('a * 'a -> order) -> 'a _sig.slice * 'a _sig.slice -> order
      val copy: {di: int, dst: 'a array, src: 'a _sig.slice} -> unit
      val copyVec: {di: int, dst: 'a array, src: 'a VectorSlice.slice} -> unit
      val exists: ('a -> bool) -> 'a _sig.slice -> bool
      val find: ('a -> bool) -> 'a _sig.slice -> 'a option
      val findi: (int * 'a -> bool) -> 'a _sig.slice -> (int * 'a) option
      val foldl: ('a * 'b -> 'b) -> 'b -> 'a _sig.slice -> 'b
      val foldli: (int * 'a * 'b -> 'b) -> 'b -> 'a _sig.slice -> 'b
      val foldr: ('a * 'b -> 'b) -> 'b -> 'a _sig.slice -> 'b
      val foldri: (int * 'a * 'b -> 'b) -> 'b -> 'a _sig.slice -> 'b
      val full: 'a array -> 'a _sig.slice
      val getItem: 'a _sig.slice -> ('a * 'a _sig.slice) option
      val isEmpty: 'a _sig.slice -> bool
      val length: 'a _sig.slice -> int
      val modify: ('a -> 'a) -> 'a _sig.slice -> unit
      val modifyi: (int * 'a -> 'a) -> 'a _sig.slice -> unit
      val slice: 'a array * int * int option -> 'a _sig.slice
      val sub: 'a _sig.slice * int -> 'a
      val subslice: 'a _sig.slice * int * int option -> 'a _sig.slice
      val update: 'a _sig.slice * int * 'a -> unit
      val vector: 'a _sig.slice -> 'a vector
   end
   (* @ $(SML_LIB)/basis/libs/basis-2002/top-level/basis-sigs.sml 10.11-10.21 *)
signature BIN_IO =
   sig
      type elem = Word8.word
      type instream
      type outstream
      type vector = Word8Vector.vector
      val canInput: _sig.instream * int -> int option
      val closeIn: _sig.instream -> unit
      val closeOut: _sig.outstream -> unit
      val endOfStream: _sig.instream -> bool
      val flushOut: _sig.outstream -> unit
      val getInstream: _sig.instream -> _sig.StreamIO.instream
      val getOutstream: _sig.outstream -> _sig.StreamIO.outstream
      val getPosOut: _sig.outstream -> _sig.StreamIO.out_pos
      val input: _sig.instream -> Word8Vector.vector
      val input1: _sig.instream -> Word8.word option
      val inputAll: _sig.instream -> Word8Vector.vector
      val inputN: _sig.instream * int -> Word8Vector.vector
      val lookahead: _sig.instream -> Word8.word option
      val mkInstream: _sig.StreamIO.instream -> _sig.instream
      val mkOutstream: _sig.StreamIO.outstream -> _sig.outstream
      val openAppend: string -> _sig.outstream
      val openIn: string -> _sig.instream
      val openOut: string -> _sig.outstream
      val output: _sig.outstream * Word8Vector.vector -> unit
      val output1: _sig.outstream * Word8.word -> unit
      val setInstream: _sig.instream * _sig.StreamIO.instream -> unit
      val setOutstream: _sig.outstream * _sig.StreamIO.outstream -> unit
      val setPosOut: _sig.outstream * _sig.StreamIO.out_pos -> unit
      structure StreamIO: STREAM_IO where type elem = Word8.word where type vector = Word8Vector.vector
   end
   (* @ $(SML_LIB)/basis/libs/basis-2002/top-level/basis-sigs.sml 11.11-11.16 *)
signature BIT_FLAGS =
   sig
      eqtype flags
      val all: _sig.flags
      val allSet: _sig.flags * _sig.flags -> bool
      val anySet: _sig.flags * _sig.flags -> bool
      val clear: _sig.flags * _sig.flags -> _sig.flags
      val flags: _sig.flags list -> _sig.flags
      val fromWord: LargeWord.word -> _sig.flags
      val intersect: _sig.flags list -> _sig.flags
      val toWord: _sig.flags -> LargeWord.word
   end
   (* @ $(SML_LIB)/basis/libs/basis-2002/top-level/basis-sigs.sml 53.11-53.19 *)
signature BOOL =
   sig
      datatype bool = false | true (* = datatype bool *)
      val fromString: string -> bool option
      val not: bool -> bool
      val scan: ('a -> (char * 'a) option) -> 'a -> (bool * 'a) option
      val toString: bool -> string
   end
   (* @ $(SML_LIB)/basis/libs/basis-2002/top-level/basis-sigs.sml 12.11-12.14 *)
signature BYTE =
   sig
      val byteToChar: Word8.word -> char
      val bytesToString: Word8Vector.vector -> string
      val charToByte: char -> Word8.word
      val packString: Word8Array.array * int * char VectorSlice.slice -> unit
      val stringToBytes: string -> Word8Vector.vector
      val unpackString: Word8ArraySlice.slice -> string
      val unpackStringVec: Word8VectorSlice.slice -> string
   end
   (* @ $(SML_LIB)/basis/libs/basis-2002/top-level/basis-sigs.sml 13.11-13.14 *)
signature CHAR =
   sig
      eqtype char
      eqtype string
      val < : _sig.char * _sig.char -> bool
      val <= : _sig.char * _sig.char -> bool
      val > : _sig.char * _sig.char -> bool
      val >= : _sig.char * _sig.char -> bool
      val chr: int -> _sig.char
      val compare: _sig.char * _sig.char -> order
      val contains: _sig.string -> _sig.char -> bool
      val fromCString: string -> _sig.char option
      val fromString: string -> _sig.char option
      val isAlpha: _sig.char -> bool
      val isAlphaNum: _sig.char -> bool
      val isAscii: _sig.char -> bool
      val isCntrl: _sig.char -> bool
      val isDigit: _sig.char -> bool
      val isGraph: _sig.char -> bool
      val isHexDigit: _sig.char -> bool
      val isLower: _sig.char -> bool
      val isPrint: _sig.char -> bool
      val isPunct: _sig.char -> bool
      val isSpace: _sig.char -> bool
      val isUpper: _sig.char -> bool
      val maxChar: _sig.char
      val maxOrd: int
      val minChar: _sig.char
      val notContains: _sig.string -> _sig.char -> bool
      val ord: _sig.char -> int
      val pred: _sig.char -> _sig.char
      val scan: ('a -> (char * 'a) option) -> 'a -> (_sig.char * 'a) option
      val succ: _sig.char -> _sig.char
      val toCString: _sig.char -> string
      val toLower: _sig.char -> _sig.char
      val toString: _sig.char -> string
      val toUpper: _sig.char -> _sig.char
   end
   (* @ $(SML_LIB)/basis/libs/basis-2002/top-level/basis-sigs.sml 14.11-14.14 *)
signature COMMAND_LINE =
   sig
      val arguments: unit -> string list
      val name: unit -> string
   end
   (* @ $(SML_LIB)/basis/libs/basis-2002/top-level/basis-sigs.sml 15.11-15.22 *)
signature DATE =
   sig
      type date
      datatype month = Apr | Aug | Dec | Feb | Jan | Jul | Jun | Mar | May | Nov | Oct | Sep
      datatype weekday = Fri | Mon | Sat | Sun | Thu | Tue | Wed
      exception Date
      val compare: _sig.date * _sig.date -> order
      val date: {day: int, hour: int, minute: int, month: _sig.month, offset: Time.time option, second: int, year: int} -> _sig.date
      val day: _sig.date -> int
      val fmt: string -> _sig.date -> string
      val fromString: string -> _sig.date option
      val fromTimeLocal: Time.time -> _sig.date
      val fromTimeUniv: Time.time -> _sig.date
      val hour: _sig.date -> int
      val isDst: _sig.date -> bool option
      val localOffset: unit -> Time.time
      val minute: _sig.date -> int
      val month: _sig.date -> _sig.month
      val offset: _sig.date -> Time.time option
      val scan: ('a -> (char * 'a) option) -> 'a -> (_sig.date * 'a) option
      val second: _sig.date -> int
      val toString: _sig.date -> string
      val toTime: _sig.date -> Time.time
      val weekDay: _sig.date -> _sig.weekday
      val year: _sig.date -> int
      val yearDay: _sig.date -> int
   end
   (* @ $(SML_LIB)/basis/libs/basis-2002/top-level/basis-sigs.sml 16.11-16.14 *)
signature GENERAL =
   sig
      type exn
      datatype order = EQUAL | GREATER | LESS
      eqtype unit
      val ! : 'a ref -> 'a
      val := : 'a ref * 'a -> _sig.unit
      exception Bind
      exception Chr
      exception Div
      exception Domain
      exception Fail of string
      exception Match
      exception Overflow
      exception Size
      exception Span
      exception Subscript
      val before: 'a * _sig.unit -> 'a
      val exnMessage: _sig.exn -> string
      val exnName: _sig.exn -> string
      val ignore: 'a -> _sig.unit
      val o: ('a -> 'b) * ('c -> 'a) -> 'c -> 'b
   end
   (* @ $(SML_LIB)/basis/libs/basis-2002/top-level/basis-sigs.sml 17.11-17.17 *)
signature GENERIC_SOCK =
   sig
      val socket: NetHostDB.addr_family * Socket.SOCK.sock_type -> ('a, 'b) Socket.sock
      val socket': NetHostDB.addr_family * Socket.SOCK.sock_type * int -> ('a, 'b) Socket.sock
      val socketPair: NetHostDB.addr_family * Socket.SOCK.sock_type -> ('a, 'b) Socket.sock * ('a, 'b) Socket.sock
      val socketPair': NetHostDB.addr_family * Socket.SOCK.sock_type * int -> ('a, 'b) Socket.sock * ('a, 'b) Socket.sock
   end
   (* @ $(SML_LIB)/basis/libs/basis-2002/top-level/basis-sigs.sml 54.11-54.22 *)
signature IEEE_REAL =
   sig
      type decimal_approx = {class: _sig.float_class, digits: int list, exp: int, sign: bool}
      datatype float_class = INF | NAN | NORMAL | SUBNORMAL | ZERO
      datatype real_order = EQUAL | GREATER | LESS | UNORDERED
      datatype rounding_mode = TO_NEAREST | TO_NEGINF | TO_POSINF | TO_ZERO
      exception Unordered
      val fromString: string -> {class: _sig.float_class, digits: int list, exp: int, sign: bool} option
      val getRoundingMode: unit -> _sig.rounding_mode
      val scan: ('a -> (char * 'a) option) -> 'a -> ({class: _sig.float_class, digits: int list, exp: int, sign: bool} * 'a) option
      val setRoundingMode: _sig.rounding_mode -> unit
      val toString: {class: _sig.float_class, digits: int list, exp: int, sign: bool} -> string
   end
   (* @ $(SML_LIB)/basis/libs/basis-2002/top-level/basis-sigs.sml 18.11-18.19 *)
signature IMPERATIVE_IO =
   sig
      type elem = _sig.StreamIO.elem
      type instream
      type outstream
      type vector = _sig.StreamIO.vector
      val canInput: _sig.instream * int -> int option
      val closeIn: _sig.instream -> unit
      val closeOut: _sig.outstream -> unit
      val endOfStream: _sig.instream -> bool
      val flushOut: _sig.outstream -> unit
      val getInstream: _sig.instream -> _sig.StreamIO.instream
      val getOutstream: _sig.outstream -> _sig.StreamIO.outstream
      val getPosOut: _sig.outstream -> _sig.StreamIO.out_pos
      val input: _sig.instream -> _sig.StreamIO.vector
      val input1: _sig.instream -> _sig.StreamIO.elem option
      val inputAll: _sig.instream -> _sig.StreamIO.vector
      val inputN: _sig.instream * int -> _sig.StreamIO.vector
      val lookahead: _sig.instream -> _sig.StreamIO.elem option
      val mkInstream: _sig.StreamIO.instream -> _sig.instream
      val mkOutstream: _sig.StreamIO.outstream -> _sig.outstream
      val output: _sig.outstream * _sig.StreamIO.vector -> unit
      val output1: _sig.outstream * _sig.StreamIO.elem -> unit
      val setInstream: _sig.instream * _sig.StreamIO.instream -> unit
      val setOutstream: _sig.outstream * _sig.StreamIO.outstream -> unit
      val setPosOut: _sig.outstream * _sig.StreamIO.out_pos -> unit
      structure StreamIO: STREAM_IO
   end
   (* @ $(SML_LIB)/basis/libs/basis-2002/top-level/basis-sigs.sml 19.11-19.23 *)
signature INET_SOCK =
   sig
      type dgram_sock = (_sig.inet, Socket.dgram) Socket.sock
      type inet
      type 'a sock = (_sig.inet, 'a) Socket.sock
      type sock_addr = _sig.inet Socket.sock_addr
      type 'a stream_sock = (_sig.inet, 'a Socket.stream) Socket.sock
      val any: int -> _sig.inet Socket.sock_addr
      val fromAddr: _sig.inet Socket.sock_addr -> Word8.word vector * int
      val inetAF: NetHostDB.addr_family
      val toAddr: Word8.word vector * int -> _sig.inet Socket.sock_addr
      structure TCP:
         sig
            val getNODELAY: (_sig.inet, 'a Socket.stream) Socket.sock -> bool
            val setNODELAY: (_sig.inet, 'a Socket.stream) Socket.sock * bool -> unit
            val socket: unit -> (_sig.inet, 'a Socket.stream) Socket.sock
            val socket': int -> (_sig.inet, 'a Socket.stream) Socket.sock
         end
      structure UDP:
         sig
            val socket: unit -> (_sig.inet, Socket.dgram) Socket.sock
            val socket': int -> (_sig.inet, Socket.dgram) Socket.sock
         end
   end
   (* @ $(SML_LIB)/basis/libs/basis-2002/top-level/basis-sigs.sml 55.11-55.19 *)
signature INTEGER =
   sig
      eqtype int
      val * : _sig.int * _sig.int -> _sig.int
      val + : _sig.int * _sig.int -> _sig.int
      val - : _sig.int * _sig.int -> _sig.int
      val < : _sig.int * _sig.int -> bool
      val <= : _sig.int * _sig.int -> bool
      val > : _sig.int * _sig.int -> bool
      val >= : _sig.int * _sig.int -> bool
      val abs: _sig.int -> _sig.int
      val compare: _sig.int * _sig.int -> order
      val div: _sig.int * _sig.int -> _sig.int
      val fmt: StringCvt.radix -> _sig.int -> string
      val fromInt: int -> _sig.int
      val fromLarge: LargeInt.int -> _sig.int
      val fromString: string -> _sig.int option
      val max: _sig.int * _sig.int -> _sig.int
      val maxInt: _sig.int option
      val min: _sig.int * _sig.int -> _sig.int
      val minInt: _sig.int option
      val mod: _sig.int * _sig.int -> _sig.int
      val precision: int option
      val quot: _sig.int * _sig.int -> _sig.int
      val rem: _sig.int * _sig.int -> _sig.int
      val sameSign: _sig.int * _sig.int -> bool
      val scan: StringCvt.radix -> ('a -> (char * 'a) option) -> 'a -> (_sig.int * 'a) option
      val sign: _sig.int -> int
      val toInt: _sig.int -> int
      val toLarge: _sig.int -> LargeInt.int
      val toString: _sig.int -> string
      val ~ : _sig.int -> _sig.int
   end
   (* @ $(SML_LIB)/basis/libs/basis-2002/top-level/basis-sigs.sml 20.11-20.17 *)
signature INT_INF =
   sig
      eqtype int
      val * : _sig.int * _sig.int -> _sig.int
      val + : _sig.int * _sig.int -> _sig.int
      val - : _sig.int * _sig.int -> _sig.int
      val < : _sig.int * _sig.int -> bool
      val << : _sig.int * word -> _sig.int
      val <= : _sig.int * _sig.int -> bool
      val > : _sig.int * _sig.int -> bool
      val >= : _sig.int * _sig.int -> bool
      val abs: _sig.int -> _sig.int
      val andb: _sig.int * _sig.int -> _sig.int
      val compare: _sig.int * _sig.int -> order
      val div: _sig.int * _sig.int -> _sig.int
      val divMod: _sig.int * _sig.int -> _sig.int * _sig.int
      val fmt: StringCvt.radix -> _sig.int -> string
      val fromInt: int -> _sig.int
      val fromLarge: LargeInt.int -> _sig.int
      val fromString: string -> _sig.int option
      val log2: _sig.int -> int
      val max: _sig.int * _sig.int -> _sig.int
      val maxInt: _sig.int option
      val min: _sig.int * _sig.int -> _sig.int
      val minInt: _sig.int option
      val mod: _sig.int * _sig.int -> _sig.int
      val notb: _sig.int -> _sig.int
      val orb: _sig.int * _sig.int -> _sig.int
      val pow: _sig.int * int -> _sig.int
      val precision: int option
      val quot: _sig.int * _sig.int -> _sig.int
      val quotRem: _sig.int * _sig.int -> _sig.int * _sig.int
      val rem: _sig.int * _sig.int -> _sig.int
      val sameSign: _sig.int * _sig.int -> bool
      val scan: StringCvt.radix -> ('a -> (char * 'a) option) -> 'a -> (_sig.int * 'a) option
      val sign: _sig.int -> int
      val toInt: _sig.int -> int
      val toLarge: _sig.int -> LargeInt.int
      val toString: _sig.int -> string
      val xorb: _sig.int * _sig.int -> _sig.int
      val ~ : _sig.int -> _sig.int
      val ~>> : _sig.int * word -> _sig.int
   end
   (* @ $(SML_LIB)/basis/libs/basis-2002/top-level/basis-sigs.sml 56.11-56.17 *)
signature IO =
   sig
      datatype buffer_mode = BLOCK_BUF | LINE_BUF | NO_BUF
      exception BlockingNotSupported
      exception ClosedStream
      exception Io of {cause: exn, function: string, name: string}
      exception NonblockingNotSupported
      exception RandomAccessNotSupported
   end
   (* @ $(SML_LIB)/basis/libs/basis-2002/top-level/basis-sigs.sml 22.11-22.12 *)
signature LIST =
   sig
      datatype 'a list = :: of 'a * 'a list | nil (* = datatype 'a list *)
      val @ : 'a list * 'a list -> 'a list
      exception Empty
      val all: ('a -> bool) -> 'a list -> bool
      val app: ('a -> unit) -> 'a list -> unit
      val collate: ('a * 'a -> order) -> 'a list * 'a list -> order
      val concat: 'a list list -> 'a list
      val drop: 'a list * int -> 'a list
      val exists: ('a -> bool) -> 'a list -> bool
      val filter: ('a -> bool) -> 'a list -> 'a list
      val find: ('a -> bool) -> 'a list -> 'a option
      val foldl: ('a * 'b -> 'b) -> 'b -> 'a list -> 'b
      val foldr: ('a * 'b -> 'b) -> 'b -> 'a list -> 'b
      val getItem: 'a list -> ('a * 'a list) option
      val hd: 'a list -> 'a
      val last: 'a list -> 'a
      val length: 'a list -> int
      val map: ('a -> 'b) -> 'a list -> 'b list
      val mapPartial: ('a -> 'b option) -> 'a list -> 'b list
      val nth: 'a list * int -> 'a
      val null: 'a list -> bool
      val partition: ('a -> bool) -> 'a list -> 'a list * 'a list
      val rev: 'a list -> 'a list
      val revAppend: 'a list * 'a list -> 'a list
      val tabulate: int * (int -> 'a) -> 'a list
      val take: 'a list * int -> 'a list
      val tl: 'a list -> 'a list
   end
   (* @ $(SML_LIB)/basis/libs/basis-2002/top-level/basis-sigs.sml 23.11-23.14 *)
signature LIST_PAIR =
   sig
      exception UnequalLengths
      val all: ('a * 'b -> bool) -> 'a list * 'b list -> bool
      val allEq: ('a * 'b -> bool) -> 'a list * 'b list -> bool
      val app: ('a * 'b -> unit) -> 'a list * 'b list -> unit
      val appEq: ('a * 'b -> unit) -> 'a list * 'b list -> unit
      val exists: ('a * 'b -> bool) -> 'a list * 'b list -> bool
      val foldl: ('a * 'b * 'c -> 'c) -> 'c -> 'a list * 'b list -> 'c
      val foldlEq: ('a * 'b * 'c -> 'c) -> 'c -> 'a list * 'b list -> 'c
      val foldr: ('a * 'b * 'c -> 'c) -> 'c -> 'a list * 'b list -> 'c
      val foldrEq: ('a * 'b * 'c -> 'c) -> 'c -> 'a list * 'b list -> 'c
      val map: ('a * 'b -> 'c) -> 'a list * 'b list -> 'c list
      val mapEq: ('a * 'b -> 'c) -> 'a list * 'b list -> 'c list
      val unzip: ('a * 'b) list -> 'a list * 'b list
      val zip: 'a list * 'b list -> ('a * 'b) list
      val zipEq: 'a list * 'b list -> ('a * 'b) list
   end
   (* @ $(SML_LIB)/basis/libs/basis-2002/top-level/basis-sigs.sml 24.11-24.19 *)
signature MATH =
   sig
      type real
      val acos: _sig.real -> _sig.real
      val asin: _sig.real -> _sig.real
      val atan: _sig.real -> _sig.real
      val atan2: _sig.real * _sig.real -> _sig.real
      val cos: _sig.real -> _sig.real
      val cosh: _sig.real -> _sig.real
      val e: _sig.real
      val exp: _sig.real -> _sig.real
      val ln: _sig.real -> _sig.real
      val log10: _sig.real -> _sig.real
      val pi: _sig.real
      val pow: _sig.real * _sig.real -> _sig.real
      val sin: _sig.real -> _sig.real
      val sinh: _sig.real -> _sig.real
      val sqrt: _sig.real -> _sig.real
      val tan: _sig.real -> _sig.real
      val tanh: _sig.real -> _sig.real
   end
   (* @ $(SML_LIB)/basis/libs/basis-2002/top-level/basis-sigs.sml 25.11-25.14 *)
signature MLTON =
   sig
      val debug: bool
      val eq: 'a * 'a -> bool
      val equal: 'a * 'a -> bool
      val hash: 'a -> word
      val isMLton: bool
      val safe: bool
      val share: 'a -> unit
      val shareAll: unit -> unit
      val size: 'a -> int
      structure Array: MLTON_ARRAY
      structure BinIO: MLTON_TEXT_IO
      structure CharArray: MLTON_MONO_ARRAY
      structure CharVector: MLTON_MONO_VECTOR
      structure Cont: MLTON_CONT
      structure Exn: MLTON_EXN
      structure Finalizable: MLTON_FINALIZABLE
      structure GC: MLTON_GC
      structure IntInf: MLTON_INT_INF
      structure Itimer: MLTON_ITIMER
      structure LargeReal: MLTON_REAL
      structure LargeWord: MLTON_WORD
      structure Platform: MLTON_PLATFORM
      structure Pointer: MLTON_POINTER
      structure ProcEnv: MLTON_PROC_ENV
      structure Process: MLTON_PROCESS
      structure Profile: MLTON_PROFILE
      structure Random: MLTON_RANDOM
      structure Real: MLTON_REAL
      structure Real32:
         sig
            type t
            val castFromWord: word -> _sig.Real32.t
            val castToWord: _sig.Real32.t -> word
            val fromLargeWord: LargeWord.word -> _sig.Real32.t
            val fromWord: word -> _sig.Real32.t
            val toLargeWord: IEEEReal.rounding_mode -> _sig.Real32.t -> LargeWord.word
            val toWord: IEEEReal.rounding_mode -> _sig.Real32.t -> word
         end
      structure Real64:
         sig
            type t
            val castFromWord: LargeWord.word -> real
            val castToWord: real -> LargeWord.word
            val fromLargeWord: LargeWord.word -> _sig.Real64.t
            val fromWord: word -> _sig.Real64.t
            val toLargeWord: IEEEReal.rounding_mode -> _sig.Real64.t -> LargeWord.word
            val toWord: IEEEReal.rounding_mode -> _sig.Real64.t -> word
         end
      structure Rlimit: MLTON_RLIMIT
      structure Rusage: MLTON_RUSAGE
      structure Signal: MLTON_SIGNAL
      structure Syslog: MLTON_SYSLOG
      structure TextIO: MLTON_TEXT_IO
      structure Thread: MLTON_THREAD
      structure Vector: MLTON_VECTOR
      structure Weak: MLTON_WEAK
      structure Word: MLTON_WORD
      structure Word16: MLTON_WORD
      structure Word32: MLTON_WORD
      structure Word64: MLTON_WORD
      structure Word8: MLTON_WORD
      structure Word8Array: MLTON_MONO_ARRAY
      structure Word8Vector: MLTON_MONO_VECTOR
      structure World: MLTON_WORLD
   end
   (* @ $(SML_LIB)/basis/mlton.mlb 19.17-19.21 *)
signature MLTON_ARRAY =
   sig
      val unfoldi: int * 'a * (int * 'a -> 'b * 'a) -> 'b array * 'a
   end
   (* @ $(SML_LIB)/basis/mlton.mlb 20.17-20.27 *)
signature MLTON_BIN_IO =
   sig
      type instream
      type outstream
      val inFd: _sig.instream -> Posix.TTY.file_desc
      val mkstemp: string -> string * _sig.outstream
      val mkstemps: {prefix: string, suffix: string} -> string * _sig.outstream
      val newIn: Posix.TTY.file_desc * string -> _sig.instream
      val newOut: Posix.TTY.file_desc * string -> _sig.outstream
      val outFd: _sig.outstream -> Posix.TTY.file_desc
      val tempPrefix: string -> string
   end
   (* @ $(SML_LIB)/basis/mlton.mlb 21.17-21.28 *)
signature MLTON_CONT =
   sig
      type 'a t
      val callcc: ('a _sig.t -> 'a) -> 'a
      val isolate: ('a -> unit) -> 'a _sig.t
      val prepend: 'a _sig.t * ('b -> 'a) -> 'b _sig.t
      val throw: 'a _sig.t * 'a -> 'b
      val throw': 'a _sig.t * (unit -> 'a) -> 'b
   end
   (* @ $(SML_LIB)/basis/mlton.mlb 22.17-22.26 *)
signature MLTON_EXN =
   sig
      val addExnMessager: (exn -> string option) -> unit
      val defaultTopLevelHandler: exn -> 'a
      val getTopLevelHandler: unit -> exn -> unit
      val history: exn -> string list
      val setTopLevelHandler: (exn -> unit) -> unit
      val topLevelHandler: exn -> 'a
   end
   (* @ $(SML_LIB)/basis/mlton.mlb 23.17-23.25 *)
signature MLTON_FINALIZABLE =
   sig
      type 'a t
      val addFinalizer: 'a _sig.t * ('a -> unit) -> unit
      val finalizeBefore: 'a _sig.t * 'b _sig.t -> unit
      val new: 'a -> 'a _sig.t
      val touch: 'a _sig.t -> unit
      val withValue: 'a _sig.t * ('a -> 'b) -> 'b
   end
   (* @ $(SML_LIB)/basis/mlton.mlb 24.17-24.33 *)
signature MLTON_GC =
   sig
      val collect: unit -> unit
      val pack: unit -> unit
      val setMessages: bool -> unit
      val setSummary: bool -> unit
      val unpack: unit -> unit
      structure Statistics:
         sig
            val bytesAllocated: unit -> LargeInt.int
            val lastBytesLive: unit -> LargeInt.int
            val maxBytesLive: unit -> LargeInt.int
            val numCopyingGCs: unit -> LargeInt.int
            val numMarkCompactGCs: unit -> LargeInt.int
            val numMinorGCs: unit -> LargeInt.int
         end
   end
   (* @ $(SML_LIB)/basis/mlton.mlb 25.17-25.24 *)
signature MLTON_INT_INF =
   sig
      datatype rep = Big of _sig.BigWord.word vector | Small of _sig.SmallInt.int
      type t
      val areSmall: _sig.t * _sig.t -> bool
      val fromRep: _sig.rep -> _sig.t option
      val gcd: _sig.t * _sig.t -> _sig.t
      val isSmall: _sig.t -> bool
      val rep: _sig.t -> _sig.rep
      structure BigWord: WORD
      structure SmallInt: INTEGER
   end
   (* @ $(SML_LIB)/basis/mlton.mlb 26.17-26.29 *)
signature MLTON_IO =
   sig
      type instream
      type outstream
      val inFd: _sig.instream -> Posix.TTY.file_desc
      val mkstemp: string -> string * _sig.outstream
      val mkstemps: {prefix: string, suffix: string} -> string * _sig.outstream
      val newIn: Posix.TTY.file_desc * string -> _sig.instream
      val newOut: Posix.TTY.file_desc * string -> _sig.outstream
      val outFd: _sig.outstream -> Posix.TTY.file_desc
      val tempPrefix: string -> string
   end
   (* @ $(SML_LIB)/basis/mlton.mlb 27.17-27.24 *)
signature MLTON_ITIMER =
   sig
      datatype t = Prof | Real | Virtual
      val set: _sig.t * {interval: Time.time, value: Time.time} -> unit
      val signal: _sig.t -> Unix.signal
   end
   (* @ $(SML_LIB)/basis/mlton.mlb 28.17-28.28 *)
signature MLTON_MONO_ARRAY =
   sig
      type elem
      type t
      val fromPoly: _sig.elem array -> _sig.t
      val toPoly: _sig.t -> _sig.elem array
   end
   (* @ $(SML_LIB)/basis/mlton.mlb 29.17-29.32 *)
signature MLTON_MONO_VECTOR =
   sig
      type elem
      type t
      val fromPoly: _sig.elem vector -> _sig.t
      val toPoly: _sig.t -> _sig.elem vector
   end
   (* @ $(SML_LIB)/basis/mlton.mlb 30.17-30.33 *)
signature MLTON_PLATFORM =
   sig
      structure Arch:
         sig
            datatype t = AMD64 | ARM | ARM64 | Alpha | HPPA | IA64 | MIPS | PowerPC | PowerPC64 | S390 | Sparc | X86 | m68k
            val fromString: string -> _sig.Arch.t option
            val host: _sig.Arch.t
            val toString: _sig.Arch.t -> string
         end
      structure Format:
         sig
            datatype t = Archive | Executable | LibArchive | Library
            val fromString: string -> _sig.Format.t option
            val host: _sig.Format.t
            val toString: _sig.Format.t -> string
         end
      structure OS:
         sig
            datatype t = AIX | Cygwin | Darwin | FreeBSD | HPUX | Hurd | Linux | MinGW | NetBSD | OpenBSD | Solaris
            val fromString: string -> _sig.OS.t option
            val host: _sig.OS.t
            val toString: _sig.OS.t -> string
         end
   end
   (* @ $(SML_LIB)/basis/mlton.mlb 31.17-31.30 *)
signature MLTON_POINTER =
   sig
      eqtype t
      val add: _sig.t * word -> _sig.t
      val compare: _sig.t * _sig.t -> order
      val diff: _sig.t * _sig.t -> word
      val getInt16: _sig.t * int -> Int16.int
      val getInt32: _sig.t * int -> int
      val getInt64: _sig.t * int -> Int64.int
      val getInt8: _sig.t * int -> Int8.int
      val getPointer: _sig.t * int -> _sig.t
      val getReal32: _sig.t * int -> Real32.real
      val getReal64: _sig.t * int -> real
      val getWord16: _sig.t * int -> Word16.word
      val getWord32: _sig.t * int -> word
      val getWord64: _sig.t * int -> LargeWord.word
      val getWord8: _sig.t * int -> Word8.word
      val null: _sig.t
      val setInt16: _sig.t * int * Int16.int -> unit
      val setInt32: _sig.t * int * int -> unit
      val setInt64: _sig.t * int * Int64.int -> unit
      val setInt8: _sig.t * int * Int8.int -> unit
      val setPointer: _sig.t * int * _sig.t -> unit
      val setReal32: _sig.t * int * Real32.real -> unit
      val setReal64: _sig.t * int * real -> unit
      val setWord16: _sig.t * int * Word16.word -> unit
      val setWord32: _sig.t * int * word -> unit
      val setWord64: _sig.t * int * LargeWord.word -> unit
      val setWord8: _sig.t * int * Word8.word -> unit
      val sizeofPointer: word
      val sub: _sig.t * word -> _sig.t
   end
   (* @ $(SML_LIB)/basis/mlton.mlb 32.17-32.29 *)
signature MLTON_PROCESS =
   sig
      type any
      type chain
      type input
      type none
      type output
      type pid
      type ('a, 'b, 'c) t
      exception DoublyRedirected
      exception MisuseOfForget
      val create: {args: string list, env: string list option, path: string, stderr: ('a, _sig.output) _sig.Param.t, stdin: ('b, _sig.input) _sig.Param.t, stdout: ('c, _sig.output) _sig.Param.t} -> ('b, 'c, 'a) _sig.t
      val getStderr: ('a, 'b, 'c) _sig.t -> ('c, _sig.input) _sig.Child.t
      val getStdin: ('a, 'b, 'c) _sig.t -> ('a, _sig.output) _sig.Child.t
      val getStdout: ('a, 'b, 'c) _sig.t -> ('b, _sig.input) _sig.Child.t
      val kill: ('a, 'b, 'c) _sig.t * Unix.signal -> unit
      val reap: ('a, 'b, 'c) _sig.t -> Unix.exit_status
      val spawn: {args: string list, path: string} -> _sig.pid
      val spawne: {args: string list, env: string list, path: string} -> _sig.pid
      val spawnp: {args: string list, file: string} -> _sig.pid
      structure Child:
         sig
            type ('a, 'b) t
            val binIn: (BinIO.instream, _sig.input) _sig.Child.t -> BinIO.instream
            val binOut: (BinIO.outstream, _sig.output) _sig.Child.t -> BinIO.outstream
            val fd: (Posix.TTY.file_desc, 'a) _sig.Child.t -> Posix.TTY.file_desc
            val remember: (_sig.any, 'a) _sig.Child.t -> ('b, 'a) _sig.Child.t
            val textIn: (TextIO.instream, _sig.input) _sig.Child.t -> TextIO.instream
            val textOut: (TextIO.outstream, _sig.output) _sig.Child.t -> TextIO.outstream
         end
      structure Param:
         sig
            type ('a, 'b) t
            val child: (_sig.chain, 'a) _sig.Child.t -> (_sig.none, 'a) _sig.Param.t
            val fd: Posix.TTY.file_desc -> (_sig.none, 'a) _sig.Param.t
            val file: string -> (_sig.none, 'a) _sig.Param.t
            val forget: ('a, 'b) _sig.Param.t -> (_sig.any, 'b) _sig.Param.t
            val null: (_sig.none, 'a) _sig.Param.t
            val pipe: ('a, 'b) _sig.Param.t
            val self: (_sig.none, 'a) _sig.Param.t
         end
   end
   (* @ $(SML_LIB)/basis/mlton.mlb 34.17-34.29 *)
signature MLTON_PROC_ENV =
   sig
      type gid
      val setenv: {name: string, value: string} -> unit
      val setgroups: _sig.gid list -> unit
   end
   (* @ $(SML_LIB)/basis/mlton.mlb 33.17-33.30 *)
signature MLTON_PROFILE =
   sig
      val isOn: bool
      val withData: _sig.Data.t * (unit -> 'a) -> 'a
      structure Data:
         sig
            type t
            val equals: _sig.Data.t * _sig.Data.t -> bool
            val free: _sig.Data.t -> unit
            val malloc: unit -> _sig.Data.t
            val write: _sig.Data.t * string -> unit
         end
   end
   (* @ $(SML_LIB)/basis/mlton.mlb 35.17-35.29 *)
signature MLTON_RANDOM =
   sig
      val alphaNumChar: unit -> char
      val alphaNumString: int -> string
      val rand: unit -> word
      val seed: unit -> word option
      val srand: word -> unit
      val useed: unit -> word option
   end
   (* @ $(SML_LIB)/basis/mlton.mlb 36.17-36.28 *)
signature MLTON_REAL =
   sig
      type t
      val fromLargeWord: LargeWord.word -> _sig.t
      val fromWord: word -> _sig.t
      val toLargeWord: IEEEReal.rounding_mode -> _sig.t -> LargeWord.word
      val toWord: IEEEReal.rounding_mode -> _sig.t -> word
   end
   (* @ $(SML_LIB)/basis/mlton.mlb 37.17-37.26 *)
signature MLTON_RLIMIT =
   sig
      type t
      val coreFileSize: _sig.t
      val cpuTime: _sig.t
      val dataSize: _sig.t
      val fileSize: _sig.t
      val get: _sig.t -> {hard: _sig.RLim.t, soft: _sig.RLim.t}
      val infinity: _sig.RLim.t
      val lockedInMemorySize: _sig.t
      val numFiles: _sig.t
      val numProcesses: _sig.t
      val residentSetSize: _sig.t
      val set: _sig.t * {hard: _sig.RLim.t, soft: _sig.RLim.t} -> unit
      val stackSize: _sig.t
      val virtualMemorySize: _sig.t
      structure RLim:
         sig
            type t
            val castFromSysWord: LargeWord.word -> _sig.RLim.t
            val castToSysWord: _sig.RLim.t -> LargeWord.word
         end
   end
   (* @ $(SML_LIB)/basis/mlton.mlb 38.17-38.28 *)
signature MLTON_RUSAGE =
   sig
      type t = {stime: Time.time, utime: Time.time}
      val measureGC: bool -> unit
      val rusage: unit -> {children: {stime: Time.time, utime: Time.time}, gc: {stime: Time.time, utime: Time.time}, self: {stime: Time.time, utime: Time.time}}
   end
   (* @ $(SML_LIB)/basis/mlton.mlb 39.17-39.28 *)
signature MLTON_SIGNAL =
   sig
      type signal = _sig.t
      type t
      val getHandler: _sig.t -> _sig.Handler.t
      val handled: unit -> _sig.Mask.t
      val prof: _sig.t
      val restart: bool ref
      val setHandler: _sig.t * _sig.Handler.t -> unit
      val suspend: _sig.Mask.t -> unit
      val vtalrm: _sig.t
      structure Handler:
         sig
            type t
            val default: _sig.Handler.t
            val handler: (MLton.Thread.Runnable.t -> MLton.Thread.Runnable.t) -> _sig.Handler.t
            val ignore: _sig.Handler.t
            val isDefault: _sig.Handler.t -> bool
            val isIgnore: _sig.Handler.t -> bool
            val simple: (unit -> unit) -> _sig.Handler.t
         end
      structure Mask:
         sig
            type t
            val all: _sig.Mask.t
            val allBut: _sig.t list -> _sig.Mask.t
            val block: _sig.Mask.t -> unit
            val getBlocked: unit -> _sig.Mask.t
            val isMember: _sig.Mask.t * _sig.t -> bool
            val none: _sig.Mask.t
            val setBlocked: _sig.Mask.t -> unit
            val some: _sig.t list -> _sig.Mask.t
            val unblock: _sig.Mask.t -> unit
         end
   end
   (* @ $(SML_LIB)/basis/mlton.mlb 40.17-40.28 *)
signature MLTON_SYSLOG =
   sig
      type facility
      type loglevel
      type openflag
      val ALERT: _sig.loglevel
      val AUTHPRIV: _sig.facility
      val CONS: _sig.openflag
      val CRIT: _sig.loglevel
      val CRON: _sig.facility
      val DAEMON: _sig.facility
      val DEBUG: _sig.loglevel
      val EMERG: _sig.loglevel
      val ERR: _sig.loglevel
      val INFO: _sig.loglevel
      val KERN: _sig.facility
      val LOCAL0: _sig.facility
      val LOCAL1: _sig.facility
      val LOCAL2: _sig.facility
      val LOCAL3: _sig.facility
      val LOCAL4: _sig.facility
      val LOCAL5: _sig.facility
      val LOCAL6: _sig.facility
      val LOCAL7: _sig.facility
      val LPR: _sig.facility
      val MAIL: _sig.facility
      val NDELAY: _sig.openflag
      val NEWS: _sig.facility
      val NOTICE: _sig.loglevel
      val NOWAIT: _sig.openflag
      val ODELAY: _sig.openflag
      val PERROR: _sig.openflag
      val PID: _sig.openflag
      val SYSLOG: _sig.facility
      val USER: _sig.facility
      val UUCP: _sig.facility
      val WARNING: _sig.loglevel
      val closelog: unit -> unit
      val log: _sig.loglevel * string -> unit
      val openlog: string * _sig.openflag list * _sig.facility -> unit
   end
   (* @ $(SML_LIB)/basis/mlton.mlb 41.17-41.28 *)
signature MLTON_TEXT_IO =
   sig
      type instream
      type outstream
      val inFd: _sig.instream -> Posix.TTY.file_desc
      val mkstemp: string -> string * _sig.outstream
      val mkstemps: {prefix: string, suffix: string} -> string * _sig.outstream
      val newIn: Posix.TTY.file_desc * string -> _sig.instream
      val newOut: Posix.TTY.file_desc * string -> _sig.outstream
      val outFd: _sig.outstream -> Posix.TTY.file_desc
      val tempPrefix: string -> string
   end
   (* @ $(SML_LIB)/basis/mlton.mlb 42.17-42.29 *)
signature MLTON_THREAD =
   sig
      type 'a t
      val atomicBegin: unit -> unit
      val atomicEnd: unit -> unit
      val atomicState: unit -> _sig.AtomicState.t
      val atomicSwitch: ('a _sig.t -> _sig.Runnable.t) -> 'a
      val atomically: (unit -> 'a) -> 'a
      val new: ('a -> unit) -> 'a _sig.t
      val prepare: 'a _sig.t * 'a -> _sig.Runnable.t
      val prepend: 'a _sig.t * ('b -> 'a) -> 'b _sig.t
      val switch: ('a _sig.t -> _sig.Runnable.t) -> 'a
      structure AtomicState:
         sig
            datatype t = Atomic of int | NonAtomic
         end
      structure Runnable:
         sig
            type t
         end
   end
   (* @ $(SML_LIB)/basis/mlton.mlb 43.17-43.28 *)
signature MLTON_VECTOR =
   sig
      val create: int -> {done: unit -> 'a vector, sub: int -> 'a, update: int * 'a -> unit}
      val unfoldi: int * 'a * (int * 'a -> 'b * 'a) -> 'b vector * 'a
   end
   (* @ $(SML_LIB)/basis/mlton.mlb 44.17-44.28 *)
signature MLTON_WEAK =
   sig
      type 'a t
      val get: 'a _sig.t -> 'a option
      val new: 'a -> 'a _sig.t
   end
   (* @ $(SML_LIB)/basis/mlton.mlb 45.17-45.26 *)
signature MLTON_WORD =
   sig
      type t
      val bswap: _sig.t -> _sig.t
      val rol: _sig.t * word -> _sig.t
      val ror: _sig.t * word -> _sig.t
   end
   (* @ $(SML_LIB)/basis/mlton.mlb 46.17-46.26 *)
signature MLTON_WORLD =
   sig
      datatype status = Clone | Original
      val load: string -> 'a
      val save: string -> _sig.status
      val saveThread: string * MLton.Thread.Runnable.t -> unit
   end
   (* @ $(SML_LIB)/basis/mlton.mlb 47.17-47.27 *)
signature MONO_ARRAY =
   sig
      eqtype array
      type elem
      type vector
      val all: (_sig.elem -> bool) -> _sig.array -> bool
      val app: (_sig.elem -> unit) -> _sig.array -> unit
      val appi: (int * _sig.elem -> unit) -> _sig.array -> unit
      val array: int * _sig.elem -> _sig.array
      val collate: (_sig.elem * _sig.elem -> order) -> _sig.array * _sig.array -> order
      val copy: {di: int, dst: _sig.array, src: _sig.array} -> unit
      val copyVec: {di: int, dst: _sig.array, src: _sig.vector} -> unit
      val exists: (_sig.elem -> bool) -> _sig.array -> bool
      val find: (_sig.elem -> bool) -> _sig.array -> _sig.elem option
      val findi: (int * _sig.elem -> bool) -> _sig.array -> (int * _sig.elem) option
      val foldl: (_sig.elem * 'a -> 'a) -> 'a -> _sig.array -> 'a
      val foldli: (int * _sig.elem * 'a -> 'a) -> 'a -> _sig.array -> 'a
      val foldr: (_sig.elem * 'a -> 'a) -> 'a -> _sig.array -> 'a
      val foldri: (int * _sig.elem * 'a -> 'a) -> 'a -> _sig.array -> 'a
      val fromList: _sig.elem list -> _sig.array
      val length: _sig.array -> int
      val maxLen: int
      val modify: (_sig.elem -> _sig.elem) -> _sig.array -> unit
      val modifyi: (int * _sig.elem -> _sig.elem) -> _sig.array -> unit
      val sub: _sig.array * int -> _sig.elem
      val tabulate: int * (int -> _sig.elem) -> _sig.array
      val update: _sig.array * int * _sig.elem -> unit
      val vector: _sig.array -> _sig.vector
   end
   (* @ $(SML_LIB)/basis/libs/basis-2002/top-level/basis-sigs.sml 26.11-26.20 *)
signature MONO_ARRAY2 =
   sig
      eqtype array
      type elem
      type region = {base: _sig.array, col: int, ncols: int option, nrows: int option, row: int}
      datatype traversal = ColMajor | RowMajor (* = datatype Array2.traversal *)
      type vector
      val app: Array2.traversal -> (_sig.elem -> unit) -> _sig.array -> unit
      val appi: Array2.traversal -> (int * int * _sig.elem -> unit) -> {base: _sig.array, col: int, ncols: int option, nrows: int option, row: int} -> unit
      val array: int * int * _sig.elem -> _sig.array
      val column: _sig.array * int -> _sig.vector
      val copy: {dst: _sig.array, dst_col: int, dst_row: int, src: {base: _sig.array, col: int, ncols: int option, nrows: int option, row: int}} -> unit
      val dimensions: _sig.array -> int * int
      val fold: Array2.traversal -> (_sig.elem * 'a -> 'a) -> 'a -> _sig.array -> 'a
      val foldi: Array2.traversal -> (int * int * _sig.elem * 'a -> 'a) -> 'a -> {base: _sig.array, col: int, ncols: int option, nrows: int option, row: int} -> 'a
      val fromList: _sig.elem list list -> _sig.array
      val modify: Array2.traversal -> (_sig.elem -> _sig.elem) -> _sig.array -> unit
      val modifyi: Array2.traversal -> (int * int * _sig.elem -> _sig.elem) -> {base: _sig.array, col: int, ncols: int option, nrows: int option, row: int} -> unit
      val nCols: _sig.array -> int
      val nRows: _sig.array -> int
      val row: _sig.array * int -> _sig.vector
      val sub: _sig.array * int * int -> _sig.elem
      val tabulate: Array2.traversal -> int * int * (int * int -> _sig.elem) -> _sig.array
      val update: _sig.array * int * int * _sig.elem -> unit
   end
   (* @ $(SML_LIB)/basis/libs/basis-2002/top-level/basis-sigs.sml 57.11-57.21 *)
signature MONO_ARRAY_SLICE =
   sig
      type array
      type elem
      type slice
      type vector
      type vector_slice
      val all: (_sig.elem -> bool) -> _sig.slice -> bool
      val app: (_sig.elem -> unit) -> _sig.slice -> unit
      val appi: (int * _sig.elem -> unit) -> _sig.slice -> unit
      val base: _sig.slice -> _sig.array * int * int
      val collate: (_sig.elem * _sig.elem -> order) -> _sig.slice * _sig.slice -> order
      val copy: {di: int, dst: _sig.array, src: _sig.slice} -> unit
      val copyVec: {di: int, dst: _sig.array, src: _sig.vector_slice} -> unit
      val exists: (_sig.elem -> bool) -> _sig.slice -> bool
      val find: (_sig.elem -> bool) -> _sig.slice -> _sig.elem option
      val findi: (int * _sig.elem -> bool) -> _sig.slice -> (int * _sig.elem) option
      val foldl: (_sig.elem * 'a -> 'a) -> 'a -> _sig.slice -> 'a
      val foldli: (int * _sig.elem * 'a -> 'a) -> 'a -> _sig.slice -> 'a
      val foldr: (_sig.elem * 'a -> 'a) -> 'a -> _sig.slice -> 'a
      val foldri: (int * _sig.elem * 'a -> 'a) -> 'a -> _sig.slice -> 'a
      val full: _sig.array -> _sig.slice
      val getItem: _sig.slice -> (_sig.elem * _sig.slice) option
      val isEmpty: _sig.slice -> bool
      val length: _sig.slice -> int
      val modify: (_sig.elem -> _sig.elem) -> _sig.slice -> unit
      val modifyi: (int * _sig.elem -> _sig.elem) -> _sig.slice -> unit
      val slice: _sig.array * int * int option -> _sig.slice
      val sub: _sig.slice * int -> _sig.elem
      val subslice: _sig.slice * int * int option -> _sig.slice
      val update: _sig.slice * int * _sig.elem -> unit
      val vector: _sig.slice -> _sig.vector
   end
   (* @ $(SML_LIB)/basis/libs/basis-2002/top-level/basis-sigs.sml 27.11-27.26 *)
signature MONO_VECTOR =
   sig
      type elem
      type vector
      val all: (_sig.elem -> bool) -> _sig.vector -> bool
      val app: (_sig.elem -> unit) -> _sig.vector -> unit
      val appi: (int * _sig.elem -> unit) -> _sig.vector -> unit
      val collate: (_sig.elem * _sig.elem -> order) -> _sig.vector * _sig.vector -> order
      val concat: _sig.vector list -> _sig.vector
      val exists: (_sig.elem -> bool) -> _sig.vector -> bool
      val find: (_sig.elem -> bool) -> _sig.vector -> _sig.elem option
      val findi: (int * _sig.elem -> bool) -> _sig.vector -> (int * _sig.elem) option
      val foldl: (_sig.elem * 'a -> 'a) -> 'a -> _sig.vector -> 'a
      val foldli: (int * _sig.elem * 'a -> 'a) -> 'a -> _sig.vector -> 'a
      val foldr: (_sig.elem * 'a -> 'a) -> 'a -> _sig.vector -> 'a
      val foldri: (int * _sig.elem * 'a -> 'a) -> 'a -> _sig.vector -> 'a
      val fromList: _sig.elem list -> _sig.vector
      val length: _sig.vector -> int
      val map: (_sig.elem -> _sig.elem) -> _sig.vector -> _sig.vector
      val mapi: (int * _sig.elem -> _sig.elem) -> _sig.vector -> _sig.vector
      val maxLen: int
      val sub: _sig.vector * int -> _sig.elem
      val tabulate: int * (int -> _sig.elem) -> _sig.vector
      val update: _sig.vector * int * _sig.elem -> _sig.vector
   end
   (* @ $(SML_LIB)/basis/libs/basis-2002/top-level/basis-sigs.sml 28.11-28.21 *)
signature MONO_VECTOR_SLICE =
   sig
      type elem
      type slice
      type vector
      val all: (_sig.elem -> bool) -> _sig.slice -> bool
      val app: (_sig.elem -> unit) -> _sig.slice -> unit
      val appi: (int * _sig.elem -> unit) -> _sig.slice -> unit
      val base: _sig.slice -> _sig.vector * int * int
      val collate: (_sig.elem * _sig.elem -> order) -> _sig.slice * _sig.slice -> order
      val concat: _sig.slice list -> _sig.vector
      val exists: (_sig.elem -> bool) -> _sig.slice -> bool
      val find: (_sig.elem -> bool) -> _sig.slice -> _sig.elem option
      val findi: (int * _sig.elem -> bool) -> _sig.slice -> (int * _sig.elem) option
      val foldl: (_sig.elem * 'a -> 'a) -> 'a -> _sig.slice -> 'a
      val foldli: (int * _sig.elem * 'a -> 'a) -> 'a -> _sig.slice -> 'a
      val foldr: (_sig.elem * 'a -> 'a) -> 'a -> _sig.slice -> 'a
      val foldri: (int * _sig.elem * 'a -> 'a) -> 'a -> _sig.slice -> 'a
      val full: _sig.vector -> _sig.slice
      val getItem: _sig.slice -> (_sig.elem * _sig.slice) option
      val isEmpty: _sig.slice -> bool
      val length: _sig.slice -> int
      val map: (_sig.elem -> _sig.elem) -> _sig.slice -> _sig.vector
      val mapi: (int * _sig.elem -> _sig.elem) -> _sig.slice -> _sig.vector
      val slice: _sig.vector * int * int option -> _sig.slice
      val sub: _sig.slice * int -> _sig.elem
      val subslice: _sig.slice * int * int option -> _sig.slice
      val vector: _sig.slice -> _sig.vector
   end
   (* @ $(SML_LIB)/basis/libs/basis-2002/top-level/basis-sigs.sml 29.11-29.27 *)
signature NET_HOST_DB =
   sig
      eqtype addr_family
      type entry
      eqtype in_addr
      val addr: _sig.entry -> _sig.in_addr
      val addrType: _sig.entry -> _sig.addr_family
      val addrs: _sig.entry -> _sig.in_addr list
      val aliases: _sig.entry -> string list
      val fromString: string -> _sig.in_addr option
      val getByAddr: _sig.in_addr -> _sig.entry option
      val getByName: string -> _sig.entry option
      val getHostName: unit -> string
      val name: _sig.entry -> string
      val scan: ('a -> (char * 'a) option) -> 'a -> (_sig.in_addr * 'a) option
      val toString: _sig.in_addr -> string
   end
   (* @ $(SML_LIB)/basis/libs/basis-2002/top-level/basis-sigs.sml 58.11-58.21 *)
signature NET_PROT_DB =
   sig
      type entry
      val aliases: _sig.entry -> string list
      val getByName: string -> _sig.entry option
      val getByNumber: int -> _sig.entry option
      val name: _sig.entry -> string
      val protocol: _sig.entry -> int
   end
   (* @ $(SML_LIB)/basis/libs/basis-2002/top-level/basis-sigs.sml 59.11-59.21 *)
signature NET_SERV_DB =
   sig
      type entry
      val aliases: _sig.entry -> string list
      val getByName: string * string option -> _sig.entry option
      val getByPort: int * string option -> _sig.entry option
      val name: _sig.entry -> string
      val port: _sig.entry -> int
      val protocol: _sig.entry -> string
   end
   (* @ $(SML_LIB)/basis/libs/basis-2002/top-level/basis-sigs.sml 60.11-60.21 *)
signature OPTION =
   sig
      datatype 'a option = NONE | SOME of 'a
      exception Option
      val app: ('a -> unit) -> 'a _sig.option -> unit
      val compose: ('a -> 'b) * ('c -> 'a _sig.option) -> 'c -> 'b _sig.option
      val composePartial: ('a -> 'b _sig.option) * ('c -> 'a _sig.option) -> 'c -> 'b _sig.option
      val filter: ('a -> bool) -> 'a -> 'a _sig.option
      val getOpt: 'a _sig.option * 'a -> 'a
      val isSome: 'a _sig.option -> bool
      val join: 'a _sig.option _sig.option -> 'a _sig.option
      val map: ('a -> 'b) -> 'a _sig.option -> 'b _sig.option
      val mapPartial: ('a -> 'b _sig.option) -> 'a _sig.option -> 'b _sig.option
      val valOf: 'a _sig.option -> 'a
   end
   (* @ $(SML_LIB)/basis/libs/basis-2002/top-level/basis-sigs.sml 30.11-30.16 *)
signature OS =
   sig
      eqtype syserror
      exception SysErr of string * _sig.syserror option
      val errorMsg: _sig.syserror -> string
      val errorName: _sig.syserror -> string
      val syserror: string -> _sig.syserror option
      structure FileSys: OS_FILE_SYS
      structure IO: OS_IO
      structure Path: OS_PATH
      structure Process: OS_PROCESS
   end
   (* @ $(SML_LIB)/basis/libs/basis-2002/top-level/basis-sigs.sml 31.11-31.12 *)
signature OS_FILE_SYS =
   sig
      datatype access_mode = A_EXEC | A_READ | A_WRITE
      type dirstream
      eqtype file_id
      val access: string * _sig.access_mode list -> bool
      val chDir: string -> unit
      val closeDir: _sig.dirstream -> unit
      val compare: _sig.file_id * _sig.file_id -> order
      val fileId: string -> _sig.file_id
      val fileSize: string -> Int64.int
      val fullPath: string -> string
      val getDir: unit -> string
      val hash: _sig.file_id -> word
      val isDir: string -> bool
      val isLink: string -> bool
      val mkDir: string -> unit
      val modTime: string -> Time.time
      val openDir: string -> _sig.dirstream
      val readDir: _sig.dirstream -> string option
      val readLink: string -> string
      val realPath: string -> string
      val remove: string -> unit
      val rename: {new: string, old: string} -> unit
      val rewindDir: _sig.dirstream -> unit
      val rmDir: string -> unit
      val setTime: string * Time.time option -> unit
      val tmpName: unit -> string
   end
   (* @ $(SML_LIB)/basis/libs/basis-2002/top-level/basis-sigs.sml 32.11-32.21 *)
signature OS_IO =
   sig
      eqtype iodesc
      eqtype iodesc_kind
      eqtype poll_desc
      type poll_info
      exception Poll
      val compare: _sig.iodesc * _sig.iodesc -> order
      val hash: _sig.iodesc -> word
      val infoToPollDesc: _sig.poll_info -> _sig.poll_desc
      val isIn: _sig.poll_info -> bool
      val isOut: _sig.poll_info -> bool
      val isPri: _sig.poll_info -> bool
      val kind: _sig.iodesc -> _sig.iodesc_kind
      val poll: _sig.poll_desc list * Time.time option -> _sig.poll_info list
      val pollDesc: _sig.iodesc -> _sig.poll_desc option
      val pollIn: _sig.poll_desc -> _sig.poll_desc
      val pollOut: _sig.poll_desc -> _sig.poll_desc
      val pollPri: _sig.poll_desc -> _sig.poll_desc
      val pollToIODesc: _sig.poll_desc -> _sig.iodesc
      structure Kind:
         sig
            val device: _sig.iodesc_kind
            val dir: _sig.iodesc_kind
            val file: _sig.iodesc_kind
            val pipe: _sig.iodesc_kind
            val socket: _sig.iodesc_kind
            val symlink: _sig.iodesc_kind
            val tty: _sig.iodesc_kind
         end
   end
   (* @ $(SML_LIB)/basis/libs/basis-2002/top-level/basis-sigs.sml 33.11-33.15 *)
signature OS_PATH =
   sig
      exception InvalidArc
      exception Path
      val base: string -> string
      val concat: string * string -> string
      val currentArc: string
      val dir: string -> string
      val ext: string -> string option
      val file: string -> string
      val fromString: string -> {arcs: string list, isAbs: bool, vol: string}
      val fromUnixPath: string -> string
      val getParent: string -> string
      val getVolume: string -> string
      val isAbsolute: string -> bool
      val isCanonical: string -> bool
      val isRelative: string -> bool
      val isRoot: string -> bool
      val joinBaseExt: {base: string, ext: string option} -> string
      val joinDirFile: {dir: string, file: string} -> string
      val mkAbsolute: {path: string, relativeTo: string} -> string
      val mkCanonical: string -> string
      val mkRelative: {path: string, relativeTo: string} -> string
      val parentArc: string
      val splitBaseExt: string -> {base: string, ext: string option}
      val splitDirFile: string -> {dir: string, file: string}
      val toString: {arcs: string list, isAbs: bool, vol: string} -> string
      val toUnixPath: string -> string
      val validVolume: {isAbs: bool, vol: string} -> bool
   end
   (* @ $(SML_LIB)/basis/libs/basis-2002/top-level/basis-sigs.sml 34.11-34.17 *)
signature OS_PROCESS =
   sig
      type status
      val atExit: (unit -> unit) -> unit
      val exit: _sig.status -> 'a
      val failure: _sig.status
      val getEnv: string -> string option
      val isSuccess: _sig.status -> bool
      val sleep: Time.time -> unit
      val success: _sig.status
      val system: string -> _sig.status
      val terminate: _sig.status -> 'a
   end
   (* @ $(SML_LIB)/basis/libs/basis-2002/top-level/basis-sigs.sml 35.11-35.20 *)
signature PACK_REAL =
   sig
      type real
      val bytesPerElem: int
      val fromBytes: Word8Vector.vector -> _sig.real
      val isBigEndian: bool
      val subArr: Word8Array.array * int -> _sig.real
      val subVec: Word8Vector.vector * int -> _sig.real
      val toBytes: _sig.real -> Word8Vector.vector
      val update: Word8Array.array * int * _sig.real -> unit
   end
   (* @ $(SML_LIB)/basis/libs/basis-2002/top-level/basis-sigs.sml 61.11-61.19 *)
signature PACK_WORD =
   sig
      val bytesPerElem: int
      val isBigEndian: bool
      val subArr: Word8Array.array * int -> LargeWord.word
      val subArrX: Word8Array.array * int -> LargeWord.word
      val subVec: Word8Vector.vector * int -> LargeWord.word
      val subVecX: Word8Vector.vector * int -> LargeWord.word
      val update: Word8Array.array * int * LargeWord.word -> unit
   end
   (* @ $(SML_LIB)/basis/libs/basis-2002/top-level/basis-sigs.sml 62.11-62.19 *)
signature POSIX =
   sig
      structure Error: POSIX_ERROR
      structure FileSys: POSIX_FILE_SYS
      structure IO: POSIX_IO where type file_desc = _sig.FileSys.file_desc where type open_mode = _sig.FileSys.open_mode
      structure ProcEnv: POSIX_PROC_ENV where type file_desc = _sig.FileSys.file_desc where type gid = _sig.FileSys.gid where type pid = _sig.IO.pid where type uid = _sig.FileSys.uid
      structure Process: POSIX_PROCESS where type pid = _sig.IO.pid
      structure Signal: POSIX_SIGNAL where type signal = _sig.Process.signal
      structure SysDB: POSIX_SYS_DB where type gid = _sig.FileSys.gid where type uid = _sig.FileSys.uid
      structure TTY: POSIX_TTY where type file_desc = _sig.FileSys.file_desc where type pid = _sig.IO.pid
   end
   (* @ $(SML_LIB)/basis/libs/basis-2002/top-level/basis-sigs.sml 63.11-63.15 *)
signature POSIX_ERROR =
   sig
      eqtype syserror
      val acces: _sig.syserror
      val again: _sig.syserror
      val badf: _sig.syserror
      val badmsg: _sig.syserror
      val busy: _sig.syserror
      val canceled: _sig.syserror
      val child: _sig.syserror
      val deadlk: _sig.syserror
      val dom: _sig.syserror
      val errorMsg: _sig.syserror -> string
      val errorName: _sig.syserror -> string
      val exist: _sig.syserror
      val fault: _sig.syserror
      val fbig: _sig.syserror
      val fromWord: LargeWord.word -> _sig.syserror
      val inprogress: _sig.syserror
      val intr: _sig.syserror
      val inval: _sig.syserror
      val io: _sig.syserror
      val isdir: _sig.syserror
      val loop: _sig.syserror
      val mfile: _sig.syserror
      val mlink: _sig.syserror
      val msgsize: _sig.syserror
      val nametoolong: _sig.syserror
      val nfile: _sig.syserror
      val nodev: _sig.syserror
      val noent: _sig.syserror
      val noexec: _sig.syserror
      val nolck: _sig.syserror
      val nomem: _sig.syserror
      val nospc: _sig.syserror
      val nosys: _sig.syserror
      val notdir: _sig.syserror
      val notempty: _sig.syserror
      val notsup: _sig.syserror
      val notty: _sig.syserror
      val nxio: _sig.syserror
      val perm: _sig.syserror
      val pipe: _sig.syserror
      val range: _sig.syserror
      val rofs: _sig.syserror
      val spipe: _sig.syserror
      val srch: _sig.syserror
      val syserror: string -> _sig.syserror option
      val toWord: _sig.syserror -> LargeWord.word
      val toobig: _sig.syserror
      val xdev: _sig.syserror
   end
   (* @ $(SML_LIB)/basis/libs/basis-2002/top-level/basis-sigs.sml 64.11-64.21 *)
signature POSIX_FILE_SYS =
   sig
      datatype access_mode = A_EXEC | A_READ | A_WRITE
      eqtype dev
      type dirstream
      eqtype file_desc
      eqtype gid
      eqtype ino
      datatype open_mode = O_RDONLY | O_RDWR | O_WRONLY
      eqtype uid
      val access: string * _sig.access_mode list -> bool
      val chdir: string -> unit
      val chmod: string * _sig.S.mode -> unit
      val chown: string * _sig.uid * _sig.gid -> unit
      val closedir: _sig.dirstream -> unit
      val creat: string * _sig.S.mode -> _sig.file_desc
      val createf: string * _sig.open_mode * _sig.O.flags * _sig.S.mode -> _sig.file_desc
      val devToWord: _sig.dev -> LargeWord.word
      val fchmod: _sig.file_desc * _sig.S.mode -> unit
      val fchown: _sig.file_desc * _sig.uid * _sig.gid -> unit
      val fdToIOD: _sig.file_desc -> OS.IO.iodesc
      val fdToWord: _sig.file_desc -> LargeWord.word
      val fpathconf: _sig.file_desc * string -> LargeWord.word option
      val fstat: _sig.file_desc -> _sig.ST.stat
      val ftruncate: _sig.file_desc * Int64.int -> unit
      val getcwd: unit -> string
      val inoToWord: _sig.ino -> LargeWord.word
      val iodToFD: OS.IO.iodesc -> _sig.file_desc option
      val link: {new: string, old: string} -> unit
      val lstat: string -> _sig.ST.stat
      val mkdir: string * _sig.S.mode -> unit
      val mkfifo: string * _sig.S.mode -> unit
      val opendir: string -> _sig.dirstream
      val openf: string * _sig.open_mode * _sig.O.flags -> _sig.file_desc
      val pathconf: string * string -> LargeWord.word option
      val readdir: _sig.dirstream -> string option
      val readlink: string -> string
      val rename: {new: string, old: string} -> unit
      val rewinddir: _sig.dirstream -> unit
      val rmdir: string -> unit
      val stat: string -> _sig.ST.stat
      val stderr: _sig.file_desc
      val stdin: _sig.file_desc
      val stdout: _sig.file_desc
      val symlink: {new: string, old: string} -> unit
      val umask: _sig.S.mode -> _sig.S.mode
      val unlink: string -> unit
      val utime: string * {actime: Time.time, modtime: Time.time} option -> unit
      val wordToDev: LargeWord.word -> _sig.dev
      val wordToFD: LargeWord.word -> _sig.file_desc
      val wordToIno: LargeWord.word -> _sig.ino
      structure O:
         sig
            eqtype flags
            val all: _sig.O.flags
            val allSet: _sig.O.flags * _sig.O.flags -> bool
            val anySet: _sig.O.flags * _sig.O.flags -> bool
            val append: _sig.O.flags
            val clear: _sig.O.flags * _sig.O.flags -> _sig.O.flags
            val excl: _sig.O.flags
            val flags: _sig.O.flags list -> _sig.O.flags
            val fromWord: LargeWord.word -> _sig.O.flags
            val intersect: _sig.O.flags list -> _sig.O.flags
            val noctty: _sig.O.flags
            val nonblock: _sig.O.flags
            val sync: _sig.O.flags
            val toWord: _sig.O.flags -> LargeWord.word
            val trunc: _sig.O.flags
         end
      structure S:
         sig
            type flags = _sig.S.mode
            eqtype mode
            val all: _sig.S.mode
            val allSet: _sig.S.mode * _sig.S.mode -> bool
            val anySet: _sig.S.mode * _sig.S.mode -> bool
            val clear: _sig.S.mode * _sig.S.mode -> _sig.S.mode
            val flags: _sig.S.mode list -> _sig.S.mode
            val fromWord: LargeWord.word -> _sig.S.mode
            val intersect: _sig.S.mode list -> _sig.S.mode
            val irgrp: _sig.S.mode
            val iroth: _sig.S.mode
            val irusr: _sig.S.mode
            val irwxg: _sig.S.mode
            val irwxo: _sig.S.mode
            val irwxu: _sig.S.mode
            val isgid: _sig.S.mode
            val isuid: _sig.S.mode
            val iwgrp: _sig.S.mode
            val iwoth: _sig.S.mode
            val iwusr: _sig.S.mode
            val ixgrp: _sig.S.mode
            val ixoth: _sig.S.mode
            val ixusr: _sig.S.mode
            val toWord: _sig.S.mode -> LargeWord.word
         end
      structure ST:
         sig
            type stat
            val atime: _sig.ST.stat -> Time.time
            val ctime: _sig.ST.stat -> Time.time
            val dev: _sig.ST.stat -> _sig.dev
            val gid: _sig.ST.stat -> _sig.gid
            val ino: _sig.ST.stat -> _sig.ino
            val isBlk: _sig.ST.stat -> bool
            val isChr: _sig.ST.stat -> bool
            val isDir: _sig.ST.stat -> bool
            val isFIFO: _sig.ST.stat -> bool
            val isLink: _sig.ST.stat -> bool
            val isReg: _sig.ST.stat -> bool
            val isSock: _sig.ST.stat -> bool
            val mode: _sig.ST.stat -> _sig.S.mode
            val mtime: _sig.ST.stat -> Time.time
            val nlink: _sig.ST.stat -> int
            val size: _sig.ST.stat -> Int64.int
            val uid: _sig.ST.stat -> _sig.uid
         end
   end
   (* @ $(SML_LIB)/basis/libs/basis-2002/top-level/basis-sigs.sml 65.11-65.24 *)
signature POSIX_IO =
   sig
      eqtype file_desc
      datatype lock_type = F_RDLCK | F_UNLCK | F_WRLCK
      datatype open_mode = O_RDONLY | O_RDWR | O_WRONLY
      eqtype pid
      datatype whence = SEEK_CUR | SEEK_END | SEEK_SET
      val close: _sig.file_desc -> unit
      val dup: _sig.file_desc -> _sig.file_desc
      val dup2: {new: _sig.file_desc, old: _sig.file_desc} -> unit
      val dupfd: {base: _sig.file_desc, old: _sig.file_desc} -> _sig.file_desc
      val fsync: _sig.file_desc -> unit
      val getfd: _sig.file_desc -> _sig.FD.flags
      val getfl: _sig.file_desc -> _sig.O.flags * _sig.open_mode
      val getlk: _sig.file_desc * _sig.FLock.flock -> _sig.FLock.flock
      val lseek: _sig.file_desc * Int64.int * _sig.whence -> Int64.int
      val mkBinReader: {fd: _sig.file_desc, initBlkMode: bool, name: string} -> BinPrimIO.reader
      val mkBinWriter: {appendMode: bool, chunkSize: int, fd: _sig.file_desc, initBlkMode: bool, name: string} -> BinPrimIO.writer
      val mkTextReader: {fd: _sig.file_desc, initBlkMode: bool, name: string} -> TextPrimIO.reader
      val mkTextWriter: {appendMode: bool, chunkSize: int, fd: _sig.file_desc, initBlkMode: bool, name: string} -> TextPrimIO.writer
      val pipe: unit -> {infd: _sig.file_desc, outfd: _sig.file_desc}
      val readArr: _sig.file_desc * Word8ArraySlice.slice -> int
      val readVec: _sig.file_desc * int -> Word8Vector.vector
      val setfd: _sig.file_desc * _sig.FD.flags -> unit
      val setfl: _sig.file_desc * _sig.O.flags -> unit
      val setlk: _sig.file_desc * _sig.FLock.flock -> _sig.FLock.flock
      val setlkw: _sig.file_desc * _sig.FLock.flock -> _sig.FLock.flock
      val writeArr: _sig.file_desc * Word8ArraySlice.slice -> int
      val writeVec: _sig.file_desc * Word8VectorSlice.slice -> int
      structure FD:
         sig
            eqtype flags
            val all: _sig.FD.flags
            val allSet: _sig.FD.flags * _sig.FD.flags -> bool
            val anySet: _sig.FD.flags * _sig.FD.flags -> bool
            val clear: _sig.FD.flags * _sig.FD.flags -> _sig.FD.flags
            val cloexec: _sig.FD.flags
            val flags: _sig.FD.flags list -> _sig.FD.flags
            val fromWord: LargeWord.word -> _sig.FD.flags
            val intersect: _sig.FD.flags list -> _sig.FD.flags
            val toWord: _sig.FD.flags -> LargeWord.word
         end
      structure FLock:
         sig
            type flock
            val flock: {len: Int64.int, ltype: _sig.lock_type, pid: _sig.pid option, start: Int64.int, whence: _sig.whence} -> _sig.FLock.flock
            val len: _sig.FLock.flock -> Int64.int
            val ltype: _sig.FLock.flock -> _sig.lock_type
            val pid: _sig.FLock.flock -> _sig.pid option
            val start: _sig.FLock.flock -> Int64.int
            val whence: _sig.FLock.flock -> _sig.whence
         end
      structure O:
         sig
            eqtype flags
            val all: _sig.O.flags
            val allSet: _sig.O.flags * _sig.O.flags -> bool
            val anySet: _sig.O.flags * _sig.O.flags -> bool
            val append: _sig.O.flags
            val clear: _sig.O.flags * _sig.O.flags -> _sig.O.flags
            val flags: _sig.O.flags list -> _sig.O.flags
            val fromWord: LargeWord.word -> _sig.O.flags
            val intersect: _sig.O.flags list -> _sig.O.flags
            val nonblock: _sig.O.flags
            val sync: _sig.O.flags
            val toWord: _sig.O.flags -> LargeWord.word
         end
   end
   (* @ $(SML_LIB)/basis/libs/basis-2002/top-level/basis-sigs.sml 66.11-66.18 *)
signature POSIX_PROCESS =
   sig
      datatype exit_status = W_EXITED | W_EXITSTATUS of Word8.word | W_SIGNALED of _sig.signal | W_STOPPED of _sig.signal
      datatype killpid_arg = K_GROUP of _sig.pid | K_PROC of _sig.pid | K_SAME_GROUP
      eqtype pid
      eqtype signal
      datatype waitpid_arg = W_ANY_CHILD | W_CHILD of _sig.pid | W_GROUP of _sig.pid | W_SAME_GROUP
      val alarm: Time.time -> Time.time
      val exec: string * string list -> 'a
      val exece: string * string list * string list -> 'a
      val execp: string * string list -> 'a
      val exit: Word8.word -> 'a
      val fork: unit -> _sig.pid option
      val fromStatus: OS.Process.status -> _sig.exit_status
      val kill: _sig.killpid_arg * _sig.signal -> unit
      val pause: unit -> unit
      val pidToWord: _sig.pid -> LargeWord.word
      val sleep: Time.time -> Time.time
      val wait: unit -> _sig.pid * _sig.exit_status
      val waitpid: _sig.waitpid_arg * _sig.W.flags list -> _sig.pid * _sig.exit_status
      val waitpid_nh: _sig.waitpid_arg * _sig.W.flags list -> (_sig.pid * _sig.exit_status) option
      val wordToPid: LargeWord.word -> _sig.pid
      structure W:
         sig
            eqtype flags
            val all: _sig.W.flags
            val allSet: _sig.W.flags * _sig.W.flags -> bool
            val anySet: _sig.W.flags * _sig.W.flags -> bool
            val clear: _sig.W.flags * _sig.W.flags -> _sig.W.flags
            val flags: _sig.W.flags list -> _sig.W.flags
            val fromWord: LargeWord.word -> _sig.W.flags
            val intersect: _sig.W.flags list -> _sig.W.flags
            val toWord: _sig.W.flags -> LargeWord.word
            val untraced: _sig.W.flags
         end
   end
   (* @ $(SML_LIB)/basis/libs/basis-2002/top-level/basis-sigs.sml 68.11-68.23 *)
signature POSIX_PROC_ENV =
   sig
      eqtype file_desc
      eqtype gid
      eqtype pid
      eqtype uid
      val ctermid: unit -> string
      val environ: unit -> string list
      val getegid: unit -> _sig.gid
      val getenv: string -> string option
      val geteuid: unit -> _sig.uid
      val getgid: unit -> _sig.gid
      val getgroups: unit -> _sig.gid list
      val getlogin: unit -> string
      val getpgrp: unit -> _sig.pid
      val getpid: unit -> _sig.pid
      val getppid: unit -> _sig.pid
      val getuid: unit -> _sig.uid
      val gidToWord: _sig.gid -> LargeWord.word
      val isatty: _sig.file_desc -> bool
      val setgid: _sig.gid -> unit
      val setpgid: {pgid: _sig.pid option, pid: _sig.pid option} -> unit
      val setsid: unit -> _sig.pid
      val setuid: _sig.uid -> unit
      val sysconf: string -> LargeWord.word
      val time: unit -> Time.time
      val times: unit -> {cstime: Time.time, cutime: Time.time, elapsed: Time.time, stime: Time.time, utime: Time.time}
      val ttyname: _sig.file_desc -> string
      val uidToWord: _sig.uid -> LargeWord.word
      val uname: unit -> (string * string) list
      val wordToGid: LargeWord.word -> _sig.gid
      val wordToUid: LargeWord.word -> _sig.uid
   end
   (* @ $(SML_LIB)/basis/libs/basis-2002/top-level/basis-sigs.sml 67.11-67.24 *)
signature POSIX_SIGNAL =
   sig
      eqtype signal
      val abrt: _sig.signal
      val alrm: _sig.signal
      val bus: _sig.signal
      val chld: _sig.signal
      val cont: _sig.signal
      val fpe: _sig.signal
      val fromWord: LargeWord.word -> _sig.signal
      val hup: _sig.signal
      val ill: _sig.signal
      val int: _sig.signal
      val kill: _sig.signal
      val pipe: _sig.signal
      val quit: _sig.signal
      val segv: _sig.signal
      val stop: _sig.signal
      val term: _sig.signal
      val toWord: _sig.signal -> LargeWord.word
      val tstp: _sig.signal
      val ttin: _sig.signal
      val ttou: _sig.signal
      val usr1: _sig.signal
      val usr2: _sig.signal
   end
   (* @ $(SML_LIB)/basis/libs/basis-2002/top-level/basis-sigs.sml 69.11-69.22 *)
signature POSIX_SYS_DB =
   sig
      eqtype gid
      eqtype uid
      val getgrgid: _sig.gid -> _sig.Group.group
      val getgrnam: string -> _sig.Group.group
      val getpwnam: string -> _sig.Passwd.passwd
      val getpwuid: _sig.uid -> _sig.Passwd.passwd
      structure Group:
         sig
            type group
            val gid: _sig.Group.group -> _sig.gid
            val members: _sig.Group.group -> string list
            val name: _sig.Group.group -> string
         end
      structure Passwd:
         sig
            type passwd
            val gid: _sig.Passwd.passwd -> _sig.gid
            val home: _sig.Passwd.passwd -> string
            val name: _sig.Passwd.passwd -> string
            val shell: _sig.Passwd.passwd -> string
            val uid: _sig.Passwd.passwd -> _sig.uid
         end
   end
   (* @ $(SML_LIB)/basis/libs/basis-2002/top-level/basis-sigs.sml 70.11-70.22 *)
signature POSIX_TTY =
   sig
      eqtype file_desc
      eqtype pid
      eqtype speed
      type termios
      val b0: _sig.speed
      val b110: _sig.speed
      val b1200: _sig.speed
      val b134: _sig.speed
      val b150: _sig.speed
      val b1800: _sig.speed
      val b19200: _sig.speed
      val b200: _sig.speed
      val b2400: _sig.speed
      val b300: _sig.speed
      val b38400: _sig.speed
      val b4800: _sig.speed
      val b50: _sig.speed
      val b600: _sig.speed
      val b75: _sig.speed
      val b9600: _sig.speed
      val compareSpeed: _sig.speed * _sig.speed -> order
      val fieldsOf: _sig.termios -> {cc: _sig.V.cc, cflag: _sig.C.flags, iflag: _sig.I.flags, ispeed: _sig.speed, lflag: _sig.L.flags, oflag: _sig.O.flags, ospeed: _sig.speed}
      val getcc: _sig.termios -> _sig.V.cc
      val getcflag: _sig.termios -> _sig.C.flags
      val getiflag: _sig.termios -> _sig.I.flags
      val getlflag: _sig.termios -> _sig.L.flags
      val getoflag: _sig.termios -> _sig.O.flags
      val speedToWord: _sig.speed -> LargeWord.word
      val termios: {cc: _sig.V.cc, cflag: _sig.C.flags, iflag: _sig.I.flags, ispeed: _sig.speed, lflag: _sig.L.flags, oflag: _sig.O.flags, ospeed: _sig.speed} -> _sig.termios
      val wordToSpeed: LargeWord.word -> _sig.speed
      structure C:
         sig
            eqtype flags
            val all: _sig.C.flags
            val allSet: _sig.C.flags * _sig.C.flags -> bool
            val anySet: _sig.C.flags * _sig.C.flags -> bool
            val clear: _sig.C.flags * _sig.C.flags -> _sig.C.flags
            val clocal: _sig.C.flags
            val cread: _sig.C.flags
            val cs5: _sig.C.flags
            val cs6: _sig.C.flags
            val cs7: _sig.C.flags
            val cs8: _sig.C.flags
            val csize: _sig.C.flags
            val cstopb: _sig.C.flags
            val flags: _sig.C.flags list -> _sig.C.flags
            val fromWord: LargeWord.word -> _sig.C.flags
            val hupcl: _sig.C.flags
            val intersect: _sig.C.flags list -> _sig.C.flags
            val parenb: _sig.C.flags
            val parodd: _sig.C.flags
            val toWord: _sig.C.flags -> LargeWord.word
         end
      structure CF:
         sig
            val getispeed: _sig.termios -> _sig.speed
            val getospeed: _sig.termios -> _sig.speed
            val setispeed: _sig.termios * _sig.speed -> _sig.termios
            val setospeed: _sig.termios * _sig.speed -> _sig.termios
         end
      structure I:
         sig
            eqtype flags
            val all: _sig.I.flags
            val allSet: _sig.I.flags * _sig.I.flags -> bool
            val anySet: _sig.I.flags * _sig.I.flags -> bool
            val brkint: _sig.I.flags
            val clear: _sig.I.flags * _sig.I.flags -> _sig.I.flags
            val flags: _sig.I.flags list -> _sig.I.flags
            val fromWord: LargeWord.word -> _sig.I.flags
            val icrnl: _sig.I.flags
            val ignbrk: _sig.I.flags
            val igncr: _sig.I.flags
            val ignpar: _sig.I.flags
            val inlcr: _sig.I.flags
            val inpck: _sig.I.flags
            val intersect: _sig.I.flags list -> _sig.I.flags
            val istrip: _sig.I.flags
            val ixoff: _sig.I.flags
            val ixon: _sig.I.flags
            val parmrk: _sig.I.flags
            val toWord: _sig.I.flags -> LargeWord.word
         end
      structure L:
         sig
            eqtype flags
            val all: _sig.L.flags
            val allSet: _sig.L.flags * _sig.L.flags -> bool
            val anySet: _sig.L.flags * _sig.L.flags -> bool
            val clear: _sig.L.flags * _sig.L.flags -> _sig.L.flags
            val echo: _sig.L.flags
            val echoe: _sig.L.flags
            val echok: _sig.L.flags
            val echonl: _sig.L.flags
            val flags: _sig.L.flags list -> _sig.L.flags
            val fromWord: LargeWord.word -> _sig.L.flags
            val icanon: _sig.L.flags
            val iexten: _sig.L.flags
            val intersect: _sig.L.flags list -> _sig.L.flags
            val isig: _sig.L.flags
            val noflsh: _sig.L.flags
            val toWord: _sig.L.flags -> LargeWord.word
            val tostop: _sig.L.flags
         end
      structure O:
         sig
            eqtype flags
            val all: _sig.O.flags
            val allSet: _sig.O.flags * _sig.O.flags -> bool
            val anySet: _sig.O.flags * _sig.O.flags -> bool
            val clear: _sig.O.flags * _sig.O.flags -> _sig.O.flags
            val flags: _sig.O.flags list -> _sig.O.flags
            val fromWord: LargeWord.word -> _sig.O.flags
            val intersect: _sig.O.flags list -> _sig.O.flags
            val opost: _sig.O.flags
            val toWord: _sig.O.flags -> LargeWord.word
         end
      structure TC:
         sig
            eqtype flow_action
            eqtype queue_sel
            eqtype set_action
            val drain: _sig.file_desc -> unit
            val flow: _sig.file_desc * _sig.TC.flow_action -> unit
            val flush: _sig.file_desc * _sig.TC.queue_sel -> unit
            val getattr: _sig.file_desc -> _sig.termios
            val getpgrp: _sig.file_desc -> _sig.pid
            val iflush: _sig.TC.queue_sel
            val ioff: _sig.TC.flow_action
            val ioflush: _sig.TC.queue_sel
            val ion: _sig.TC.flow_action
            val oflush: _sig.TC.queue_sel
            val ooff: _sig.TC.flow_action
            val oon: _sig.TC.flow_action
            val sadrain: _sig.TC.set_action
            val saflush: _sig.TC.set_action
            val sanow: _sig.TC.set_action
            val sendbreak: _sig.file_desc * int -> unit
            val setattr: _sig.file_desc * _sig.TC.set_action * _sig.termios -> unit
            val setpgrp: _sig.file_desc * _sig.pid -> unit
         end
      structure V:
         sig
            type cc
            val cc: (int * char) list -> _sig.V.cc
            val eof: int
            val eol: int
            val erase: int
            val intr: int
            val kill: int
            val min: int
            val nccs: int
            val quit: int
            val start: int
            val stop: int
            val sub: _sig.V.cc * int -> char
            val susp: int
            val time: int
            val update: _sig.V.cc * (int * char) list -> _sig.V.cc
         end
   end
   (* @ $(SML_LIB)/basis/libs/basis-2002/top-level/basis-sigs.sml 71.11-71.19 *)
signature PRIM_IO =
   sig
      type array
      type array_slice
      type elem
      eqtype pos
      datatype reader = RD of {avail: unit -> int option, block: (unit -> unit) option, canInput: (unit -> bool) option, chunkSize: int, close: unit -> unit, endPos: (unit -> _sig.pos) option, getPos: (unit -> _sig.pos) option, ioDesc: OS.IO.iodesc option, name: string, readArr: (_sig.array_slice -> int) option, readArrNB: (_sig.array_slice -> int option) option, readVec: (int -> _sig.vector) option, readVecNB: (int -> _sig.vector option) option, setPos: (_sig.pos -> unit) option, verifyPos: (unit -> _sig.pos) option}
      type vector
      type vector_slice
      datatype writer = WR of {block: (unit -> unit) option, canOutput: (unit -> bool) option, chunkSize: int, close: unit -> unit, endPos: (unit -> _sig.pos) option, getPos: (unit -> _sig.pos) option, ioDesc: OS.IO.iodesc option, name: string, setPos: (_sig.pos -> unit) option, verifyPos: (unit -> _sig.pos) option, writeArr: (_sig.array_slice -> int) option, writeArrNB: (_sig.array_slice -> int option) option, writeVec: (_sig.vector_slice -> int) option, writeVecNB: (_sig.vector_slice -> int option) option}
      val augmentReader: _sig.reader -> _sig.reader
      val augmentWriter: _sig.writer -> _sig.writer
      val compare: _sig.pos * _sig.pos -> order
      val nullRd: unit -> _sig.reader
      val nullWr: unit -> _sig.writer
      val openVector: _sig.vector -> _sig.reader
   end
   (* @ $(SML_LIB)/basis/libs/basis-2002/top-level/basis-sigs.sml 36.11-36.17 *)
signature REAL =
   sig
      type real
      val != : _sig.real * _sig.real -> bool
      val * : _sig.real * _sig.real -> _sig.real
      val *+ : _sig.real * _sig.real * _sig.real -> _sig.real
      val *- : _sig.real * _sig.real * _sig.real -> _sig.real
      val + : _sig.real * _sig.real -> _sig.real
      val - : _sig.real * _sig.real -> _sig.real
      val / : _sig.real * _sig.real -> _sig.real
      val < : _sig.real * _sig.real -> bool
      val <= : _sig.real * _sig.real -> bool
      val == : _sig.real * _sig.real -> bool
      val > : _sig.real * _sig.real -> bool
      val >= : _sig.real * _sig.real -> bool
      val ?= : _sig.real * _sig.real -> bool
      val abs: _sig.real -> _sig.real
      val ceil: _sig.real -> int
      val checkFloat: _sig.real -> _sig.real
      val class: _sig.real -> IEEEReal.float_class
      val compare: _sig.real * _sig.real -> order
      val compareReal: _sig.real * _sig.real -> IEEEReal.real_order
      val copySign: _sig.real * _sig.real -> _sig.real
      val floor: _sig.real -> int
      val fmt: StringCvt.realfmt -> _sig.real -> string
      val fromDecimal: {class: IEEEReal.float_class, digits: int list, exp: int, sign: bool} -> _sig.real option
      val fromInt: int -> _sig.real
      val fromLarge: IEEEReal.rounding_mode -> real -> _sig.real
      val fromLargeInt: LargeInt.int -> _sig.real
      val fromManExp: {exp: int, man: _sig.real} -> _sig.real
      val fromString: string -> _sig.real option
      val isFinite: _sig.real -> bool
      val isNan: _sig.real -> bool
      val isNormal: _sig.real -> bool
      val max: _sig.real * _sig.real -> _sig.real
      val maxFinite: _sig.real
      val min: _sig.real * _sig.real -> _sig.real
      val minNormalPos: _sig.real
      val minPos: _sig.real
      val negInf: _sig.real
      val nextAfter: _sig.real * _sig.real -> _sig.real
      val posInf: _sig.real
      val precision: int
      val radix: int
      val realCeil: _sig.real -> _sig.real
      val realFloor: _sig.real -> _sig.real
      val realMod: _sig.real -> _sig.real
      val realRound: _sig.real -> _sig.real
      val realTrunc: _sig.real -> _sig.real
      val rem: _sig.real * _sig.real -> _sig.real
      val round: _sig.real -> int
      val sameSign: _sig.real * _sig.real -> bool
      val scan: ('a -> (char * 'a) option) -> 'a -> (_sig.real * 'a) option
      val sign: _sig.real -> int
      val signBit: _sig.real -> bool
      val split: _sig.real -> {frac: _sig.real, whole: _sig.real}
      val toDecimal: _sig.real -> {class: IEEEReal.float_class, digits: int list, exp: int, sign: bool}
      val toInt: IEEEReal.rounding_mode -> _sig.real -> int
      val toLarge: _sig.real -> real
      val toLargeInt: IEEEReal.rounding_mode -> _sig.real -> LargeInt.int
      val toManExp: _sig.real -> {exp: int, man: _sig.real}
      val toString: _sig.real -> string
      val trunc: _sig.real -> int
      val unordered: _sig.real * _sig.real -> bool
      val ~ : _sig.real -> _sig.real
      structure Math: MATH where type real = _sig.real
   end
   (* @ $(SML_LIB)/basis/libs/basis-2002/top-level/basis-sigs.sml 37.11-37.14 *)
signature SML_OF_NJ =
   sig
      val exnHistory: exn -> string list
      val exportFn: string * (string * string list -> OS.Process.status) -> unit
      val exportML: string -> bool
      val getAllArgs: unit -> string list
      val getArgs: unit -> string list
      val getCmdName: unit -> string
      structure Cont:
         sig
            type 'a cont
            val callcc: ('a _sig.Cont.cont -> 'a) -> 'a
            val isolate: ('a -> unit) -> 'a _sig.Cont.cont
            val throw: 'a _sig.Cont.cont -> 'a -> 'b
         end
      structure SysInfo:
         sig
            datatype os_kind = BEOS | MACOS | OS2 | UNIX | WIN32
            exception UNKNOWN
            val getHostArch: unit -> string
            val getOSKind: unit -> _sig.SysInfo.os_kind
            val getOSName: unit -> string
         end
   end
   (* @ $(SML_LIB)/basis/sml-nj.mlb 18.17-18.25 *)
signature SOCKET =
   sig
      type active
      type dgram
      type in_flags = {oob: bool, peek: bool}
      type out_flags = {don't_route: bool, oob: bool}
      type passive
      datatype shutdown_mode = NO_RECVS | NO_RECVS_OR_SENDS | NO_SENDS
      type ('a, 'b) sock
      type 'a sock_addr
      type sock_desc
      type 'a stream
      val accept: ('a, _sig.passive _sig.stream) _sig.sock -> ('a, _sig.active _sig.stream) _sig.sock * 'a _sig.sock_addr
      val acceptNB: ('a, _sig.passive _sig.stream) _sig.sock -> (('a, _sig.active _sig.stream) _sig.sock * 'a _sig.sock_addr) option
      val bind: ('a, 'b) _sig.sock * 'a _sig.sock_addr -> unit
      val close: ('a, 'b) _sig.sock -> unit
      val connect: ('a, 'b) _sig.sock * 'a _sig.sock_addr -> unit
      val connectNB: ('a, 'b) _sig.sock * 'a _sig.sock_addr -> bool
      val familyOfAddr: 'a _sig.sock_addr -> NetHostDB.addr_family
      val ioDesc: ('a, 'b) _sig.sock -> OS.IO.iodesc
      val listen: ('a, _sig.passive _sig.stream) _sig.sock * int -> unit
      val recvArr: ('a, _sig.active _sig.stream) _sig.sock * Word8ArraySlice.slice -> int
      val recvArr': ('a, _sig.active _sig.stream) _sig.sock * Word8ArraySlice.slice * {oob: bool, peek: bool} -> int
      val recvArrFrom: ('a, _sig.dgram) _sig.sock * Word8ArraySlice.slice -> int * 'a _sig.sock_addr
      val recvArrFrom': ('a, _sig.dgram) _sig.sock * Word8ArraySlice.slice * {oob: bool, peek: bool} -> int * 'a _sig.sock_addr
      val recvArrFromNB: ('a, _sig.dgram) _sig.sock * Word8ArraySlice.slice -> (int * 'a _sig.sock_addr) option
      val recvArrFromNB': ('a, _sig.dgram) _sig.sock * Word8ArraySlice.slice * {oob: bool, peek: bool} -> (int * 'a _sig.sock_addr) option
      val recvArrNB: ('a, _sig.active _sig.stream) _sig.sock * Word8ArraySlice.slice -> int option
      val recvArrNB': ('a, _sig.active _sig.stream) _sig.sock * Word8ArraySlice.slice * {oob: bool, peek: bool} -> int option
      val recvVec: ('a, _sig.active _sig.stream) _sig.sock * int -> Word8Vector.vector
      val recvVec': ('a, _sig.active _sig.stream) _sig.sock * int * {oob: bool, peek: bool} -> Word8Vector.vector
      val recvVecFrom: ('a, _sig.dgram) _sig.sock * int -> Word8Vector.vector * 'a _sig.sock_addr
      val recvVecFrom': ('a, _sig.dgram) _sig.sock * int * {oob: bool, peek: bool} -> Word8Vector.vector * 'a _sig.sock_addr
      val recvVecFromNB: ('a, _sig.dgram) _sig.sock * int -> (Word8Vector.vector * 'a _sig.sock_addr) option
      val recvVecFromNB': ('a, _sig.dgram) _sig.sock * int * {oob: bool, peek: bool} -> (Word8Vector.vector * 'a _sig.sock_addr) option
      val recvVecNB: ('a, _sig.active _sig.stream) _sig.sock * int -> Word8Vector.vector option
      val recvVecNB': ('a, _sig.active _sig.stream) _sig.sock * int * {oob: bool, peek: bool} -> Word8Vector.vector option
      val sameAddr: 'a _sig.sock_addr * 'a _sig.sock_addr -> bool
      val sameDesc: _sig.sock_desc * _sig.sock_desc -> bool
      val select: {exs: _sig.sock_desc list, rds: _sig.sock_desc list, timeout: Time.time option, wrs: _sig.sock_desc list} -> {exs: _sig.sock_desc list, rds: _sig.sock_desc list, wrs: _sig.sock_desc list}
      val sendArr: ('a, _sig.active _sig.stream) _sig.sock * Word8ArraySlice.slice -> int
      val sendArr': ('a, _sig.active _sig.stream) _sig.sock * Word8ArraySlice.slice * {don't_route: bool, oob: bool} -> int
      val sendArrNB: ('a, _sig.active _sig.stream) _sig.sock * Word8ArraySlice.slice -> int option
      val sendArrNB': ('a, _sig.active _sig.stream) _sig.sock * Word8ArraySlice.slice * {don't_route: bool, oob: bool} -> int option
      val sendArrTo: ('a, _sig.dgram) _sig.sock * 'a _sig.sock_addr * Word8ArraySlice.slice -> unit
      val sendArrTo': ('a, _sig.dgram) _sig.sock * 'a _sig.sock_addr * Word8ArraySlice.slice * {don't_route: bool, oob: bool} -> unit
      val sendArrToNB: ('a, _sig.dgram) _sig.sock * 'a _sig.sock_addr * Word8ArraySlice.slice -> bool
      val sendArrToNB': ('a, _sig.dgram) _sig.sock * 'a _sig.sock_addr * Word8ArraySlice.slice * {don't_route: bool, oob: bool} -> bool
      val sendVec: ('a, _sig.active _sig.stream) _sig.sock * Word8VectorSlice.slice -> int
      val sendVec': ('a, _sig.active _sig.stream) _sig.sock * Word8VectorSlice.slice * {don't_route: bool, oob: bool} -> int
      val sendVecNB: ('a, _sig.active _sig.stream) _sig.sock * Word8VectorSlice.slice -> int option
      val sendVecNB': ('a, _sig.active _sig.stream) _sig.sock * Word8VectorSlice.slice * {don't_route: bool, oob: bool} -> int option
      val sendVecTo: ('a, _sig.dgram) _sig.sock * 'a _sig.sock_addr * Word8VectorSlice.slice -> unit
      val sendVecTo': ('a, _sig.dgram) _sig.sock * 'a _sig.sock_addr * Word8VectorSlice.slice * {don't_route: bool, oob: bool} -> unit
      val sendVecToNB: ('a, _sig.dgram) _sig.sock * 'a _sig.sock_addr * Word8VectorSlice.slice -> bool
      val sendVecToNB': ('a, _sig.dgram) _sig.sock * 'a _sig.sock_addr * Word8VectorSlice.slice * {don't_route: bool, oob: bool} -> bool
      val shutdown: ('a, 'b _sig.stream) _sig.sock * _sig.shutdown_mode -> unit
      val sockDesc: ('a, 'b) _sig.sock -> _sig.sock_desc
      structure AF:
         sig
            type addr_family = NetHostDB.addr_family
            val fromString: string -> NetHostDB.addr_family option
            val list: unit -> (string * NetHostDB.addr_family) list
            val toString: NetHostDB.addr_family -> string
         end
      structure Ctl:
         sig
            val getATMARK: ('a, _sig.active _sig.stream) _sig.sock -> bool
            val getBROADCAST: ('a, 'b) _sig.sock -> bool
            val getDEBUG: ('a, 'b) _sig.sock -> bool
            val getDONTROUTE: ('a, 'b) _sig.sock -> bool
            val getERROR: ('a, 'b) _sig.sock -> bool
            val getKEEPALIVE: ('a, 'b) _sig.sock -> bool
            val getLINGER: ('a, 'b) _sig.sock -> Time.time option
            val getNREAD: ('a, 'b) _sig.sock -> int
            val getOOBINLINE: ('a, 'b) _sig.sock -> bool
            val getPeerName: ('a, 'b) _sig.sock -> 'a _sig.sock_addr
            val getRCVBUF: ('a, 'b) _sig.sock -> int
            val getREUSEADDR: ('a, 'b) _sig.sock -> bool
            val getSNDBUF: ('a, 'b) _sig.sock -> int
            val getSockName: ('a, 'b) _sig.sock -> 'a _sig.sock_addr
            val getTYPE: ('a, 'b) _sig.sock -> _sig.SOCK.sock_type
            val setBROADCAST: ('a, 'b) _sig.sock * bool -> unit
            val setDEBUG: ('a, 'b) _sig.sock * bool -> unit
            val setDONTROUTE: ('a, 'b) _sig.sock * bool -> unit
            val setKEEPALIVE: ('a, 'b) _sig.sock * bool -> unit
            val setLINGER: ('a, 'b) _sig.sock * Time.time option -> unit
            val setOOBINLINE: ('a, 'b) _sig.sock * bool -> unit
            val setRCVBUF: ('a, 'b) _sig.sock * int -> unit
            val setREUSEADDR: ('a, 'b) _sig.sock * bool -> unit
            val setSNDBUF: ('a, 'b) _sig.sock * int -> unit
         end
      structure SOCK:
         sig
            eqtype sock_type
            val dgram: _sig.SOCK.sock_type
            val fromString: string -> _sig.SOCK.sock_type option
            val list: unit -> (string * _sig.SOCK.sock_type) list
            val stream: _sig.SOCK.sock_type
            val toString: _sig.SOCK.sock_type -> string
         end
   end
   (* @ $(SML_LIB)/basis/libs/basis-2002/top-level/basis-sigs.sml 72.11-72.16 *)
signature STREAM_IO =
   sig
      type elem
      type instream
      type out_pos
      type outstream
      type pos
      type reader
      type vector
      type writer
      val canInput: _sig.instream * int -> int option
      val closeIn: _sig.instream -> unit
      val closeOut: _sig.outstream -> unit
      val endOfStream: _sig.instream -> bool
      val filePosIn: _sig.instream -> _sig.pos
      val filePosOut: _sig.out_pos -> _sig.pos
      val flushOut: _sig.outstream -> unit
      val getBufferMode: _sig.outstream -> IO.buffer_mode
      val getPosOut: _sig.outstream -> _sig.out_pos
      val getReader: _sig.instream -> _sig.reader * _sig.vector
      val getWriter: _sig.outstream -> _sig.writer * IO.buffer_mode
      val input: _sig.instream -> _sig.vector * _sig.instream
      val input1: _sig.instream -> (_sig.elem * _sig.instream) option
      val inputAll: _sig.instream -> _sig.vector * _sig.instream
      val inputN: _sig.instream * int -> _sig.vector * _sig.instream
      val mkInstream: _sig.reader * _sig.vector -> _sig.instream
      val mkOutstream: _sig.writer * IO.buffer_mode -> _sig.outstream
      val output: _sig.outstream * _sig.vector -> unit
      val output1: _sig.outstream * _sig.elem -> unit
      val setBufferMode: _sig.outstream * IO.buffer_mode -> unit
      val setPosOut: _sig.out_pos -> _sig.outstream
   end
   (* @ $(SML_LIB)/basis/libs/basis-2002/top-level/basis-sigs.sml 38.11-38.19 *)
signature STRING =
   sig
      eqtype char
      eqtype string
      val < : _sig.string * _sig.string -> bool
      val <= : _sig.string * _sig.string -> bool
      val > : _sig.string * _sig.string -> bool
      val >= : _sig.string * _sig.string -> bool
      val ^ : _sig.string * _sig.string -> _sig.string
      val collate: (_sig.char * _sig.char -> order) -> _sig.string * _sig.string -> order
      val compare: _sig.string * _sig.string -> order
      val concat: _sig.string list -> _sig.string
      val concatWith: _sig.string -> _sig.string list -> _sig.string
      val explode: _sig.string -> _sig.char list
      val extract: _sig.string * int * int option -> _sig.string
      val fields: (_sig.char -> bool) -> _sig.string -> _sig.string list
      val fromCString: string -> _sig.string option
      val fromString: string -> _sig.string option
      val implode: _sig.char list -> _sig.string
      val isPrefix: _sig.string -> _sig.string -> bool
      val isSubstring: _sig.string -> _sig.string -> bool
      val isSuffix: _sig.string -> _sig.string -> bool
      val map: (_sig.char -> _sig.char) -> _sig.string -> _sig.string
      val maxSize: int
      val scan: ('a -> (char * 'a) option) -> 'a -> (_sig.string * 'a) option
      val size: _sig.string -> int
      val str: _sig.char -> _sig.string
      val sub: _sig.string * int -> _sig.char
      val substring: _sig.string * int * int -> _sig.string
      val toCString: _sig.string -> string
      val toString: _sig.string -> string
      val tokens: (_sig.char -> bool) -> _sig.string -> _sig.string list
      val translate: (_sig.char -> _sig.string) -> _sig.string -> _sig.string
   end
   (* @ $(SML_LIB)/basis/libs/basis-2002/top-level/basis-sigs.sml 39.11-39.16 *)
signature STRING_CVT =
   sig
      type cs
      datatype radix = BIN | DEC | HEX | OCT
      type ('a, 'b) reader = 'b -> ('a * 'b) option
      datatype realfmt = EXACT | FIX of int option | GEN of int option | SCI of int option
      val dropl: (char -> bool) -> ('a -> (char * 'a) option) -> 'a -> 'a
      val padLeft: char -> int -> string -> string
      val padRight: char -> int -> string -> string
      val scanString: ((_sig.cs -> (char * _sig.cs) option) -> _sig.cs -> ('a * _sig.cs) option) -> string -> 'a option
      val skipWS: ('a -> (char * 'a) option) -> 'a -> 'a
      val splitl: (char -> bool) -> ('a -> (char * 'a) option) -> 'a -> string * 'a
      val takel: (char -> bool) -> ('a -> (char * 'a) option) -> 'a -> string
   end
   (* @ $(SML_LIB)/basis/libs/basis-2002/top-level/basis-sigs.sml 40.11-40.20 *)
signature SUBSTRING =
   sig
      eqtype char
      eqtype string
      type substring
      val app: (_sig.char -> unit) -> _sig.substring -> unit
      val base: _sig.substring -> _sig.string * int * int
      val collate: (_sig.char * _sig.char -> order) -> _sig.substring * _sig.substring -> order
      val compare: _sig.substring * _sig.substring -> order
      val concat: _sig.substring list -> _sig.string
      val concatWith: _sig.string -> _sig.substring list -> _sig.string
      val dropl: (_sig.char -> bool) -> _sig.substring -> _sig.substring
      val dropr: (_sig.char -> bool) -> _sig.substring -> _sig.substring
      val explode: _sig.substring -> _sig.char list
      val extract: _sig.string * int * int option -> _sig.substring
      val fields: (_sig.char -> bool) -> _sig.substring -> _sig.substring list
      val first: _sig.substring -> _sig.char option
      val foldl: (_sig.char * 'a -> 'a) -> 'a -> _sig.substring -> 'a
      val foldr: (_sig.char * 'a -> 'a) -> 'a -> _sig.substring -> 'a
      val full: _sig.string -> _sig.substring
      val getc: _sig.substring -> (_sig.char * _sig.substring) option
      val isEmpty: _sig.substring -> bool
      val isPrefix: _sig.string -> _sig.substring -> bool
      val isSubstring: _sig.string -> _sig.substring -> bool
      val isSuffix: _sig.string -> _sig.substring -> bool
      val position: _sig.string -> _sig.substring -> _sig.substring * _sig.substring
      val size: _sig.substring -> int
      val slice: _sig.substring * int * int option -> _sig.substring
      val span: _sig.substring * _sig.substring -> _sig.substring
      val splitAt: _sig.substring * int -> _sig.substring * _sig.substring
      val splitl: (_sig.char -> bool) -> _sig.substring -> _sig.substring * _sig.substring
      val splitr: (_sig.char -> bool) -> _sig.substring -> _sig.substring * _sig.substring
      val string: _sig.substring -> _sig.string
      val sub: _sig.substring * int -> _sig.char
      val substring: _sig.string * int * int -> _sig.substring
      val takel: (_sig.char -> bool) -> _sig.substring -> _sig.substring
      val taker: (_sig.char -> bool) -> _sig.substring -> _sig.substring
      val tokens: (_sig.char -> bool) -> _sig.substring -> _sig.substring list
      val translate: (_sig.char -> _sig.string) -> _sig.substring -> _sig.string
      val triml: int -> _sig.substring -> _sig.substring
      val trimr: int -> _sig.substring -> _sig.substring
   end
   (* @ $(SML_LIB)/basis/libs/basis-2002/top-level/basis-sigs.sml 41.11-41.19 *)
signature TEXT =
   sig
      structure Char: CHAR
      structure CharArray: MONO_ARRAY where type elem = _sig.Char.char where type vector = _sig.Char.string
      structure CharArraySlice: MONO_ARRAY_SLICE where type array = _sig.CharArray.array where type elem = _sig.Char.char where type vector = _sig.Char.string
      structure CharVector: MONO_VECTOR where type elem = _sig.Char.char where type vector = _sig.Char.string
      structure CharVectorSlice: MONO_VECTOR_SLICE where type elem = _sig.Char.char where type slice = _sig.CharArraySlice.vector_slice where type vector = _sig.Char.string
      structure String: STRING where type char = _sig.Char.char where type string = _sig.Char.string
      structure Substring: SUBSTRING where type char = _sig.Char.char where type string = _sig.Char.string
   end
   (* @ $(SML_LIB)/basis/libs/basis-2002/top-level/basis-sigs.sml 42.11-42.14 *)
signature TEXT_IO =
   sig
      type elem = char
      type instream
      type outstream
      type vector = string
      val canInput: _sig.instream * int -> int option
      val closeIn: _sig.instream -> unit
      val closeOut: _sig.outstream -> unit
      val endOfStream: _sig.instream -> bool
      val flushOut: _sig.outstream -> unit
      val getInstream: _sig.instream -> _sig.StreamIO.instream
      val getOutstream: _sig.outstream -> _sig.StreamIO.outstream
      val getPosOut: _sig.outstream -> _sig.StreamIO.out_pos
      val input: _sig.instream -> string
      val input1: _sig.instream -> char option
      val inputAll: _sig.instream -> string
      val inputLine: _sig.instream -> string option
      val inputN: _sig.instream * int -> string
      val lookahead: _sig.instream -> char option
      val mkInstream: _sig.StreamIO.instream -> _sig.instream
      val mkOutstream: _sig.StreamIO.outstream -> _sig.outstream
      val openAppend: string -> _sig.outstream
      val openIn: string -> _sig.instream
      val openOut: string -> _sig.outstream
      val openString: string -> _sig.instream
      val output: _sig.outstream * string -> unit
      val output1: _sig.outstream * char -> unit
      val outputSubstr: _sig.outstream * char VectorSlice.slice -> unit
      val print: string -> unit
      val scanStream: ((_sig.StreamIO.instream -> (char * _sig.StreamIO.instream) option) -> _sig.StreamIO.instream -> ('a * _sig.StreamIO.instream) option) -> _sig.instream -> 'a option
      val setInstream: _sig.instream * _sig.StreamIO.instream -> unit
      val setOutstream: _sig.outstream * _sig.StreamIO.outstream -> unit
      val setPosOut: _sig.outstream * _sig.StreamIO.out_pos -> unit
      val stdErr: _sig.outstream
      val stdIn: _sig.instream
      val stdOut: _sig.outstream
      structure StreamIO: TEXT_STREAM_IO where type pos = Int64.int where type reader = TextPrimIO.reader where type writer = TextPrimIO.writer
   end
   (* @ $(SML_LIB)/basis/libs/basis-2002/top-level/basis-sigs.sml 43.11-43.17 *)
signature TEXT_STREAM_IO =
   sig
      type elem = char
      type instream
      type out_pos
      type outstream
      type pos
      type reader
      type vector = string
      type writer
      val canInput: _sig.instream * int -> int option
      val closeIn: _sig.instream -> unit
      val closeOut: _sig.outstream -> unit
      val endOfStream: _sig.instream -> bool
      val filePosIn: _sig.instream -> _sig.pos
      val filePosOut: _sig.out_pos -> _sig.pos
      val flushOut: _sig.outstream -> unit
      val getBufferMode: _sig.outstream -> IO.buffer_mode
      val getPosOut: _sig.outstream -> _sig.out_pos
      val getReader: _sig.instream -> _sig.reader * string
      val getWriter: _sig.outstream -> _sig.writer * IO.buffer_mode
      val input: _sig.instream -> string * _sig.instream
      val input1: _sig.instream -> (char * _sig.instream) option
      val inputAll: _sig.instream -> string * _sig.instream
      val inputLine: _sig.instream -> (string * _sig.instream) option
      val inputN: _sig.instream * int -> string * _sig.instream
      val mkInstream: _sig.reader * string -> _sig.instream
      val mkOutstream: _sig.writer * IO.buffer_mode -> _sig.outstream
      val output: _sig.outstream * string -> unit
      val output1: _sig.outstream * char -> unit
      val outputSubstr: _sig.outstream * char VectorSlice.slice -> unit
      val setBufferMode: _sig.outstream * IO.buffer_mode -> unit
      val setPosOut: _sig.out_pos -> _sig.outstream
   end
   (* @ $(SML_LIB)/basis/libs/basis-2002/top-level/basis-sigs.sml 44.11-44.24 *)
signature TIME =
   sig
      eqtype time
      val + : _sig.time * _sig.time -> _sig.time
      val - : _sig.time * _sig.time -> _sig.time
      val < : _sig.time * _sig.time -> bool
      val <= : _sig.time * _sig.time -> bool
      val > : _sig.time * _sig.time -> bool
      val >= : _sig.time * _sig.time -> bool
      exception Time
      val compare: _sig.time * _sig.time -> order
      val fmt: int -> _sig.time -> string
      val fromMicroseconds: LargeInt.int -> _sig.time
      val fromMilliseconds: LargeInt.int -> _sig.time
      val fromNanoseconds: LargeInt.int -> _sig.time
      val fromReal: real -> _sig.time
      val fromSeconds: LargeInt.int -> _sig.time
      val fromString: string -> _sig.time option
      val now: unit -> _sig.time
      val scan: ('a -> (char * 'a) option) -> 'a -> (_sig.time * 'a) option
      val toMicroseconds: _sig.time -> LargeInt.int
      val toMilliseconds: _sig.time -> LargeInt.int
      val toNanoseconds: _sig.time -> LargeInt.int
      val toReal: _sig.time -> real
      val toSeconds: _sig.time -> LargeInt.int
      val toString: _sig.time -> string
      val zeroTime: _sig.time
   end
   (* @ $(SML_LIB)/basis/libs/basis-2002/top-level/basis-sigs.sml 45.11-45.14 *)
signature TIMER =
   sig
      type cpu_timer
      type real_timer
      val checkCPUTimer: _sig.cpu_timer -> {sys: Time.time, usr: Time.time}
      val checkCPUTimes: _sig.cpu_timer -> {gc: {sys: Time.time, usr: Time.time}, nongc: {sys: Time.time, usr: Time.time}}
      val checkGCTime: _sig.cpu_timer -> Time.time
      val checkRealTimer: _sig.real_timer -> Time.time
      val startCPUTimer: unit -> _sig.cpu_timer
      val startRealTimer: unit -> _sig.real_timer
      val totalCPUTimer: unit -> _sig.cpu_timer
      val totalRealTimer: unit -> _sig.real_timer
   end
   (* @ $(SML_LIB)/basis/libs/basis-2002/top-level/basis-sigs.sml 46.11-46.15 *)
signature UNIX =
   sig
      datatype exit_status = W_EXITED | W_EXITSTATUS of Word8.word | W_SIGNALED of _sig.signal | W_STOPPED of _sig.signal
      type ('a, 'b) proc
      type signal
      val binInstreamOf: (BinIO.instream, 'a) _sig.proc -> BinIO.instream
      val binOutstreamOf: ('a, BinIO.outstream) _sig.proc -> BinIO.outstream
      val execute: string * string list -> ('a, 'b) _sig.proc
      val executeInEnv: string * string list * string list -> ('a, 'b) _sig.proc
      val exit: Word8.word -> 'a
      val fromStatus: OS.Process.status -> _sig.exit_status
      val kill: ('a, 'b) _sig.proc * _sig.signal -> unit
      val reap: ('a, 'b) _sig.proc -> OS.Process.status
      val streamsOf: (TextIO.instream, TextIO.outstream) _sig.proc -> TextIO.instream * TextIO.outstream
      val textInstreamOf: (TextIO.instream, 'a) _sig.proc -> TextIO.instream
      val textOutstreamOf: ('a, TextIO.outstream) _sig.proc -> TextIO.outstream
   end
   (* @ $(SML_LIB)/basis/libs/basis-2002/top-level/basis-sigs.sml 73.11-73.14 *)
signature UNIX_SOCK =
   sig
      type dgram_sock = (_sig.unix, Socket.dgram) Socket.sock
      type 'a sock = (_sig.unix, 'a) Socket.sock
      type sock_addr = _sig.unix Socket.sock_addr
      type 'a stream_sock = (_sig.unix, 'a Socket.stream) Socket.sock
      type unix
      val fromAddr: _sig.unix Socket.sock_addr -> string
      val toAddr: string -> _sig.unix Socket.sock_addr
      val unixAF: NetHostDB.addr_family
      structure DGrm:
         sig
            val socket: unit -> (_sig.unix, Socket.dgram) Socket.sock
            val socketPair: unit -> (_sig.unix, Socket.dgram) Socket.sock * (_sig.unix, Socket.dgram) Socket.sock
         end
      structure Strm:
         sig
            val socket: unit -> (_sig.unix, 'a Socket.stream) Socket.sock
            val socketPair: unit -> (_sig.unix, 'a Socket.stream) Socket.sock * (_sig.unix, 'a Socket.stream) Socket.sock
         end
   end
   (* @ $(SML_LIB)/basis/libs/basis-2002/top-level/basis-sigs.sml 74.11-74.19 *)
signature UNSAFE =
   sig
      structure Array:
         sig
            val alloc: int -> 'a array
            val create: int * 'a -> 'a array
            val sub: 'a array * int -> 'a
            val uninit: 'a array * int -> unit
            val uninitIsNop: 'a array -> bool
            val update: 'a array * int * 'a -> unit
            structure Raw:
               sig
                  type 'a rawarr
                  val alloc: int -> 'a _sig.Array.Raw.rawarr
                  val toArray: 'a _sig.Array.Raw.rawarr -> 'a array
                  val uninit: 'a _sig.Array.Raw.rawarr * int -> unit
                  val uninitIsNop: 'a _sig.Array.Raw.rawarr -> bool
               end
         end
      structure BoolArray:
         sig
            type array
            type elem
            val create: int -> _sig.BoolArray.array
            val sub: _sig.BoolArray.array * int -> _sig.BoolArray.elem
            val update: _sig.BoolArray.array * int * _sig.BoolArray.elem -> unit
         end
      structure BoolVector:
         sig
            type elem
            type vector
            val sub: _sig.BoolVector.vector * int -> _sig.BoolVector.elem
         end
      structure CharArray:
         sig
            type array
            type elem
            val create: int -> _sig.CharArray.array
            val sub: _sig.CharArray.array * int -> _sig.CharArray.elem
            val update: _sig.CharArray.array * int * _sig.CharArray.elem -> unit
         end
      structure CharVector:
         sig
            type elem
            type vector
            val sub: _sig.CharVector.vector * int -> _sig.CharVector.elem
         end
      structure Int16Array:
         sig
            type array
            type elem
            val create: int -> _sig.Int16Array.array
            val sub: _sig.Int16Array.array * int -> _sig.Int16Array.elem
            val update: _sig.Int16Array.array * int * _sig.Int16Array.elem -> unit
         end
      structure Int16Vector:
         sig
            type elem
            type vector
            val sub: _sig.Int16Vector.vector * int -> _sig.Int16Vector.elem
         end
      structure Int32Array:
         sig
            type array
            type elem
            val create: int -> _sig.Int32Array.array
            val sub: _sig.Int32Array.array * int -> _sig.Int32Array.elem
            val update: _sig.Int32Array.array * int * _sig.Int32Array.elem -> unit
         end
      structure Int32Vector:
         sig
            type elem
            type vector
            val sub: _sig.Int32Vector.vector * int -> _sig.Int32Vector.elem
         end
      structure Int64Array:
         sig
            type array
            type elem
            val create: int -> _sig.Int64Array.array
            val sub: _sig.Int64Array.array * int -> _sig.Int64Array.elem
            val update: _sig.Int64Array.array * int * _sig.Int64Array.elem -> unit
         end
      structure Int64Vector:
         sig
            type elem
            type vector
            val sub: _sig.Int64Vector.vector * int -> _sig.Int64Vector.elem
         end
      structure Int8Array:
         sig
            type array
            type elem
            val create: int -> _sig.Int8Array.array
            val sub: _sig.Int8Array.array * int -> _sig.Int8Array.elem
            val update: _sig.Int8Array.array * int * _sig.Int8Array.elem -> unit
         end
      structure Int8Vector:
         sig
            type elem
            type vector
            val sub: _sig.Int8Vector.vector * int -> _sig.Int8Vector.elem
         end
      structure IntArray:
         sig
            type array
            type elem
            val create: int -> _sig.IntArray.array
            val sub: _sig.IntArray.array * int -> _sig.IntArray.elem
            val update: _sig.IntArray.array * int * _sig.IntArray.elem -> unit
         end
      structure IntInfArray:
         sig
            type array
            type elem
            val create: int -> _sig.IntInfArray.array
            val sub: _sig.IntInfArray.array * int -> _sig.IntInfArray.elem
            val update: _sig.IntInfArray.array * int * _sig.IntInfArray.elem -> unit
         end
      structure IntInfVector:
         sig
            type elem
            type vector
            val sub: _sig.IntInfVector.vector * int -> _sig.IntInfVector.elem
         end
      structure IntVector:
         sig
            type elem
            type vector
            val sub: _sig.IntVector.vector * int -> _sig.IntVector.elem
         end
      structure LargeIntArray:
         sig
            type array
            type elem
            val create: int -> _sig.LargeIntArray.array
            val sub: _sig.LargeIntArray.array * int -> _sig.LargeIntArray.elem
            val update: _sig.LargeIntArray.array * int * _sig.LargeIntArray.elem -> unit
         end
      structure LargeIntVector:
         sig
            type elem
            type vector
            val sub: _sig.LargeIntVector.vector * int -> _sig.LargeIntVector.elem
         end
      structure LargeRealArray:
         sig
            type array
            type elem
            val create: int -> _sig.LargeRealArray.array
            val sub: _sig.LargeRealArray.array * int -> _sig.LargeRealArray.elem
            val update: _sig.LargeRealArray.array * int * _sig.LargeRealArray.elem -> unit
         end
      structure LargeRealVector:
         sig
            type elem
            type vector
            val sub: _sig.LargeRealVector.vector * int -> _sig.LargeRealVector.elem
         end
      structure LargeWordArray:
         sig
            type array
            type elem
            val create: int -> _sig.LargeWordArray.array
            val sub: _sig.LargeWordArray.array * int -> _sig.LargeWordArray.elem
            val update: _sig.LargeWordArray.array * int * _sig.LargeWordArray.elem -> unit
         end
      structure LargeWordVector:
         sig
            type elem
            type vector
            val sub: _sig.LargeWordVector.vector * int -> _sig.LargeWordVector.elem
         end
      structure PackReal32Big: PACK_REAL
      structure PackReal32Little: PACK_REAL
      structure PackReal64Big: PACK_REAL
      structure PackReal64Little: PACK_REAL
      structure PackRealBig: PACK_REAL
      structure PackRealLittle: PACK_REAL
      structure PackWord16Big: PACK_WORD
      structure PackWord16Little: PACK_WORD
      structure PackWord32Big: PACK_WORD
      structure PackWord32Little: PACK_WORD
      structure PackWord64Big: PACK_WORD
      structure PackWord64Little: PACK_WORD
      structure Real32Array:
         sig
            type array
            type elem
            val create: int -> _sig.Real32Array.array
            val sub: _sig.Real32Array.array * int -> _sig.Real32Array.elem
            val update: _sig.Real32Array.array * int * _sig.Real32Array.elem -> unit
         end
      structure Real32Vector:
         sig
            type elem
            type vector
            val sub: _sig.Real32Vector.vector * int -> _sig.Real32Vector.elem
         end
      structure Real64Array:
         sig
            type array
            type elem
            val create: int -> _sig.Real64Array.array
            val sub: _sig.Real64Array.array * int -> _sig.Real64Array.elem
            val update: _sig.Real64Array.array * int * _sig.Real64Array.elem -> unit
         end
      structure Real64Vector:
         sig
            type elem
            type vector
            val sub: _sig.Real64Vector.vector * int -> _sig.Real64Vector.elem
         end
      structure RealArray:
         sig
            type array
            type elem
            val create: int -> _sig.RealArray.array
            val sub: _sig.RealArray.array * int -> _sig.RealArray.elem
            val update: _sig.RealArray.array * int * _sig.RealArray.elem -> unit
         end
      structure RealVector:
         sig
            type elem
            type vector
            val sub: _sig.RealVector.vector * int -> _sig.RealVector.elem
         end
      structure Vector:
         sig
            val sub: 'a vector * int -> 'a
         end
      structure Word16Array:
         sig
            type array
            type elem
            val create: int -> _sig.Word16Array.array
            val sub: _sig.Word16Array.array * int -> _sig.Word16Array.elem
            val update: _sig.Word16Array.array * int * _sig.Word16Array.elem -> unit
         end
      structure Word16Vector:
         sig
            type elem
            type vector
            val sub: _sig.Word16Vector.vector * int -> _sig.Word16Vector.elem
         end
      structure Word32Array:
         sig
            type array
            type elem
            val create: int -> _sig.Word32Array.array
            val sub: _sig.Word32Array.array * int -> _sig.Word32Array.elem
            val update: _sig.Word32Array.array * int * _sig.Word32Array.elem -> unit
         end
      structure Word32Vector:
         sig
            type elem
            type vector
            val sub: _sig.Word32Vector.vector * int -> _sig.Word32Vector.elem
         end
      structure Word64Array:
         sig
            type array
            type elem
            val create: int -> _sig.Word64Array.array
            val sub: _sig.Word64Array.array * int -> _sig.Word64Array.elem
            val update: _sig.Word64Array.array * int * _sig.Word64Array.elem -> unit
         end
      structure Word64Vector:
         sig
            type elem
            type vector
            val sub: _sig.Word64Vector.vector * int -> _sig.Word64Vector.elem
         end
      structure Word8Array:
         sig
            type array
            type elem
            val create: int -> _sig.Word8Array.array
            val sub: _sig.Word8Array.array * int -> _sig.Word8Array.elem
            val update: _sig.Word8Array.array * int * _sig.Word8Array.elem -> unit
         end
      structure Word8Vector:
         sig
            type elem
            type vector
            val sub: _sig.Word8Vector.vector * int -> _sig.Word8Vector.elem
         end
      structure WordArray:
         sig
            type array
            type elem
            val create: int -> _sig.WordArray.array
            val sub: _sig.WordArray.array * int -> _sig.WordArray.elem
            val update: _sig.WordArray.array * int * _sig.WordArray.elem -> unit
         end
      structure WordVector:
         sig
            type elem
            type vector
            val sub: _sig.WordVector.vector * int -> _sig.WordVector.elem
         end
   end
   (* @ $(SML_LIB)/basis/unsafe.mlb 18.17-18.22 *)
signature VECTOR =
   sig
      type 'a vector = 'a vector
      val all: ('a -> bool) -> 'a vector -> bool
      val app: ('a -> unit) -> 'a vector -> unit
      val appi: (int * 'a -> unit) -> 'a vector -> unit
      val collate: ('a * 'a -> order) -> 'a vector * 'a vector -> order
      val concat: 'a vector list -> 'a vector
      val exists: ('a -> bool) -> 'a vector -> bool
      val find: ('a -> bool) -> 'a vector -> 'a option
      val findi: (int * 'a -> bool) -> 'a vector -> (int * 'a) option
      val foldl: ('a * 'b -> 'b) -> 'b -> 'a vector -> 'b
      val foldli: (int * 'a * 'b -> 'b) -> 'b -> 'a vector -> 'b
      val foldr: ('a * 'b -> 'b) -> 'b -> 'a vector -> 'b
      val foldri: (int * 'a * 'b -> 'b) -> 'b -> 'a vector -> 'b
      val fromList: 'a list -> 'a vector
      val length: 'a vector -> int
      val map: ('a -> 'b) -> 'a vector -> 'b vector
      val mapi: (int * 'a -> 'b) -> 'a vector -> 'b vector
      val maxLen: int
      val sub: 'a vector * int -> 'a
      val tabulate: int * (int -> 'a) -> 'a vector
      val update: 'a vector * int * 'a -> 'a vector
   end
   (* @ $(SML_LIB)/basis/libs/basis-2002/top-level/basis-sigs.sml 47.11-47.16 *)
signature VECTOR_SLICE =
   sig
      type 'a slice
      val all: ('a -> bool) -> 'a _sig.slice -> bool
      val app: ('a -> unit) -> 'a _sig.slice -> unit
      val appi: (int * 'a -> unit) -> 'a _sig.slice -> unit
      val base: 'a _sig.slice -> 'a vector * int * int
      val collate: ('a * 'a -> order) -> 'a _sig.slice * 'a _sig.slice -> order
      val concat: 'a _sig.slice list -> 'a vector
      val exists: ('a -> bool) -> 'a _sig.slice -> bool
      val find: ('a -> bool) -> 'a _sig.slice -> 'a option
      val findi: (int * 'a -> bool) -> 'a _sig.slice -> (int * 'a) option
      val foldl: ('a * 'b -> 'b) -> 'b -> 'a _sig.slice -> 'b
      val foldli: (int * 'a * 'b -> 'b) -> 'b -> 'a _sig.slice -> 'b
      val foldr: ('a * 'b -> 'b) -> 'b -> 'a _sig.slice -> 'b
      val foldri: (int * 'a * 'b -> 'b) -> 'b -> 'a _sig.slice -> 'b
      val full: 'a vector -> 'a _sig.slice
      val getItem: 'a _sig.slice -> ('a * 'a _sig.slice) option
      val isEmpty: 'a _sig.slice -> bool
      val length: 'a _sig.slice -> int
      val map: ('a -> 'b) -> 'a _sig.slice -> 'b vector
      val mapi: (int * 'a -> 'b) -> 'a _sig.slice -> 'b vector
      val slice: 'a vector * int * int option -> 'a _sig.slice
      val sub: 'a _sig.slice * int -> 'a
      val subslice: 'a _sig.slice * int * int option -> 'a _sig.slice
      val vector: 'a _sig.slice -> 'a vector
   end
   (* @ $(SML_LIB)/basis/libs/basis-2002/top-level/basis-sigs.sml 48.11-48.22 *)
signature WORD =
   sig
      eqtype word
      val * : _sig.word * _sig.word -> _sig.word
      val + : _sig.word * _sig.word -> _sig.word
      val - : _sig.word * _sig.word -> _sig.word
      val < : _sig.word * _sig.word -> bool
      val << : _sig.word * word -> _sig.word
      val <= : _sig.word * _sig.word -> bool
      val > : _sig.word * _sig.word -> bool
      val >= : _sig.word * _sig.word -> bool
      val >> : _sig.word * word -> _sig.word
      val andb: _sig.word * _sig.word -> _sig.word
      val compare: _sig.word * _sig.word -> order
      val div: _sig.word * _sig.word -> _sig.word
      val fmt: StringCvt.radix -> _sig.word -> string
      val fromInt: int -> _sig.word
      val fromLarge: LargeWord.word -> _sig.word
      val fromLargeInt: LargeInt.int -> _sig.word
      val fromLargeWord: LargeWord.word -> _sig.word
      val fromString: string -> _sig.word option
      val max: _sig.word * _sig.word -> _sig.word
      val min: _sig.word * _sig.word -> _sig.word
      val mod: _sig.word * _sig.word -> _sig.word
      val notb: _sig.word -> _sig.word
      val orb: _sig.word * _sig.word -> _sig.word
      val scan: StringCvt.radix -> ('a -> (char * 'a) option) -> 'a -> (_sig.word * 'a) option
      val toInt: _sig.word -> int
      val toIntX: _sig.word -> int
      val toLarge: _sig.word -> LargeWord.word
      val toLargeInt: _sig.word -> LargeInt.int
      val toLargeIntX: _sig.word -> LargeInt.int
      val toLargeWord: _sig.word -> LargeWord.word
      val toLargeWordX: _sig.word -> LargeWord.word
      val toLargeX: _sig.word -> LargeWord.word
      val toString: _sig.word -> string
      val wordSize: int
      val xorb: _sig.word * _sig.word -> _sig.word
      val ~ : _sig.word -> _sig.word
      val ~>> : _sig.word * word -> _sig.word
   end
   (* @ $(SML_LIB)/basis/libs/basis-2002/top-level/basis-sigs.sml 49.11-49.14 *)
structure Array: ARRAY (* @ $(SML_LIB)/basis/libs/basis-2002/top-level/top-level.sml 73.11-73.15 *)
type 'a Array.array = 'a array (* @ $(SML_LIB)/basis/arrays-and-vectors/array.sml 21.15-21.19 *)
type 'a Array.vector = 'a vector (* @ $(SML_LIB)/basis/arrays-and-vectors/array.sml 22.15-22.20 *)
val Array.all: ('a -> bool) -> 'a array -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 476.13-476.15 *)
val Array.app: ('a -> unit) -> 'a array -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 464.13-464.15 *)
val Array.appi: (int * 'a -> unit) -> 'a array -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 463.13-463.16 *)
val Array.array: int * 'a -> 'a array (* @ $(SML_LIB)/basis/arrays-and-vectors/array.sml 34.11-34.15 *)
val Array.collate: ('a * 'a -> order) -> 'a array * 'a array -> order (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 477.13-477.19 *)
val Array.copy: {di: int, dst: 'a array, src: 'a array} -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 457.13-457.16 *)
val Array.copyVec: {di: int, dst: 'a array, src: 'a vector} -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array.sml 37.11-37.17 *)
val Array.exists: ('a -> bool) -> 'a array -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 474.13-474.18 *)
val Array.find: ('a -> bool) -> 'a array -> 'a option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 472.13-472.16 *)
val Array.findi: (int * 'a -> bool) -> 'a array -> (int * 'a) option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 471.13-471.17 *)
val Array.foldl: ('a * 'b -> 'b) -> 'b -> 'a array -> 'b (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 468.13-468.17 *)
val Array.foldli: (int * 'a * 'b -> 'b) -> 'b -> 'a array -> 'b (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 467.13-467.18 *)
val Array.foldr: ('a * 'b -> 'b) -> 'b -> 'a array -> 'b (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 470.13-470.17 *)
val Array.foldri: (int * 'a * 'b -> 'b) -> 'b -> 'a array -> 'b (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 469.13-469.18 *)
val Array.fromList: 'a list -> 'a array (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 122.11-122.18 *)
val Array.length: 'a array -> int (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 90.11-90.16 *)
val Array.maxLen: int (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 88.11-88.16 *)
val Array.modify: ('a -> 'a) -> 'a array -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array.sml 40.11-40.16 *)
val Array.modifyi: (int * 'a -> 'a) -> 'a array -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array.sml 39.11-39.17 *)
val Array.sub: 'a array * int -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 450.13-450.15 *)
val Array.tabulate: int * (int -> 'a) -> 'a array (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 114.11-114.18 *)
val Array.update: 'a array * int * 'a -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 452.13-452.18 *)
val Array.vector: 'a array -> 'a vector (* @ $(SML_LIB)/basis/arrays-and-vectors/array.sml 36.11-36.16 *)
structure Array2: ARRAY2 where type 'a array = 'a Array2.array where type traversal = Array2.traversal (* @ $(SML_LIB)/basis/libs/basis-2002/top-level/top-level.sml 74.11-74.16 *)
type 'a Array2.array = 'a Array2.array (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 28.15-28.19 *)
type 'a Array2.region = {base: 'a Array2.array, col: int, ncols: int option, nrows: int option, row: int} (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 40.15-40.20 *)
datatype Array2.traversal = ColMajor | RowMajor (* = datatype Array2.traversal *) (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 106.16-106.24 *)
con Array2.ColMajor: Array2.traversal (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 106.39-106.46 *)
con Array2.RowMajor: Array2.traversal (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 106.28-106.35 *)
val Array2.app: Array2.traversal -> ('a -> unit) -> 'a Array2.array -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 294.11-294.13 *)
val Array2.appi: Array2.traversal -> (int * int * 'a -> unit) -> {base: 'a Array2.array, col: int, ncols: int option, nrows: int option, row: int} -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 291.11-291.14 *)
val Array2.array: int * int * 'a -> 'a Array2.array (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 140.14-140.18 *)
val Array2.column: 'a Array2.array * int -> 'a vector (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 237.11-237.16 *)
val Array2.copy: {dst: 'a Array2.array, dst_col: int, dst_row: int, src: {base: 'a Array2.array, col: int, ncols: int option, nrows: int option, row: int}} -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 309.11-309.14 *)
val Array2.dimensions: 'a Array2.array -> int * int (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 33.11-33.20 *)
val Array2.fold: Array2.traversal -> ('a * 'b -> 'b) -> 'b -> 'a Array2.array -> 'b (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 288.11-288.14 *)
val Array2.foldi: Array2.traversal -> (int * int * 'a * 'b -> 'b) -> 'b -> {base: 'a Array2.array, col: int, ncols: int option, nrows: int option, row: int} -> 'b (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 283.11-283.15 *)
val Array2.fromList: 'a list list -> 'a Array2.array (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 188.14-188.21 *)
val Array2.modify: Array2.traversal -> ('a -> 'a) -> 'a Array2.array -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 299.11-299.16 *)
val Array2.modifyi: Array2.traversal -> (int * int * 'a -> 'a) -> {base: 'a Array2.array, col: int, ncols: int option, nrows: int option, row: int} -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 296.11-296.17 *)
val Array2.nCols: 'a Array2.array -> int (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 38.11-38.15 *)
val Array2.nRows: 'a Array2.array -> int (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 36.11-36.15 *)
val Array2.row: 'a Array2.array * int -> 'a vector (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 222.11-222.13 *)
val Array2.sub: 'a Array2.array * int * int -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 182.14-182.16 *)
val Array2.tabulate: Array2.traversal -> int * int * (int * int -> 'a) -> 'a Array2.array (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 301.11-301.18 *)
val Array2.update: 'a Array2.array * int * int * 'a -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 184.14-184.19 *)
structure ArraySlice: ARRAY_SLICE where type 'a slice = 'a ArraySlice.slice (* @ $(SML_LIB)/basis/libs/basis-extra/top-level/basis.sml 12.17-12.26 *)
type 'a ArraySlice.slice = 'a ArraySlice.slice (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 132.21-132.25 *)
val ArraySlice.all: ('a -> bool) -> 'a ArraySlice.slice -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 235.17-235.19 *)
val ArraySlice.app: ('a -> unit) -> 'a ArraySlice.slice -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 226.17-226.19 *)
val ArraySlice.appi: (int * 'a -> unit) -> 'a ArraySlice.slice -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 225.17-225.20 *)
val ArraySlice.base: 'a ArraySlice.slice -> 'a array * int * int (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 208.17-208.20 *)
val ArraySlice.collate: ('a * 'a -> order) -> 'a ArraySlice.slice * 'a ArraySlice.slice -> order (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 236.17-236.23 *)
val ArraySlice.copy: {di: int, dst: 'a array, src: 'a ArraySlice.slice} -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 185.17-185.20 *)
val ArraySlice.copyVec: {di: int, dst: 'a array, src: 'a VectorSlice.slice} -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array.sml 28.17-28.23 *)
val ArraySlice.exists: ('a -> bool) -> 'a ArraySlice.slice -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 233.17-233.22 *)
val ArraySlice.find: ('a -> bool) -> 'a ArraySlice.slice -> 'a option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 231.17-231.20 *)
val ArraySlice.findi: (int * 'a -> bool) -> 'a ArraySlice.slice -> (int * 'a) option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 229.17-229.21 *)
val ArraySlice.foldl: ('a * 'b -> 'b) -> 'b -> 'a ArraySlice.slice -> 'b (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 223.17-223.21 *)
val ArraySlice.foldli: (int * 'a * 'b -> 'b) -> 'b -> 'a ArraySlice.slice -> 'b (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 221.17-221.22 *)
val ArraySlice.foldr: ('a * 'b -> 'b) -> 'b -> 'a ArraySlice.slice -> 'b (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 224.17-224.21 *)
val ArraySlice.foldri: (int * 'a * 'b -> 'b) -> 'b -> 'a ArraySlice.slice -> 'b (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 222.17-222.22 *)
val ArraySlice.full: 'a array -> 'a ArraySlice.slice (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 192.17-192.20 *)
val ArraySlice.getItem: 'a ArraySlice.slice -> ('a * 'a ArraySlice.slice) option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 220.17-220.23 *)
val ArraySlice.isEmpty: 'a ArraySlice.slice -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 219.17-219.23 *)
val ArraySlice.length: 'a ArraySlice.slice -> int (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 134.17-134.22 *)
val ArraySlice.modify: ('a -> 'a) -> 'a ArraySlice.slice -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array.sml 31.17-31.22 *)
val ArraySlice.modifyi: (int * 'a -> 'a) -> 'a ArraySlice.slice -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array.sml 30.17-30.23 *)
val ArraySlice.slice: 'a array * int * int option -> 'a ArraySlice.slice (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 206.17-206.21 *)
val ArraySlice.sub: 'a ArraySlice.slice * int -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 142.17-142.19 *)
val ArraySlice.subslice: 'a ArraySlice.slice * int * int option -> 'a ArraySlice.slice (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 199.17-199.24 *)
val ArraySlice.update: 'a ArraySlice.slice * int * 'a -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 155.17-155.22 *)
val ArraySlice.vector: 'a ArraySlice.slice -> 'a vector (* @ $(SML_LIB)/basis/arrays-and-vectors/array.sml 27.17-27.22 *)
structure BinIO: BIN_IO where type StreamIO.instream = BinIO.StreamIO.instream where type StreamIO.out_pos = BinIO.StreamIO.out_pos where type StreamIO.outstream = BinIO.StreamIO.outstream where type StreamIO.pos = Int64.int where type StreamIO.reader = BinPrimIO.reader where type StreamIO.writer = BinPrimIO.writer where type instream = BinIO.instream where type outstream = BinIO.outstream (* @ $(SML_LIB)/basis/libs/basis-extra/top-level/basis.sml 13.17-13.21 *)
type BinIO.elem = Word8.word (* @ $(SML_LIB)/basis/io/imperative-io.fun 73.6-73.9 *)
type BinIO.instream = BinIO.instream (* @ $(SML_LIB)/basis/io/imperative-io.fun 213.10-213.17 *)
type BinIO.outstream = BinIO.outstream (* @ $(SML_LIB)/basis/io/imperative-io.fun 100.6-100.14 *)
type BinIO.vector = Word8Vector.vector (* @ $(SML_LIB)/basis/io/imperative-io.fun 74.6-74.11 *)
val BinIO.canInput: BinIO.instream * int -> int option (* @ $(SML_LIB)/basis/io/imperative-io.fun 515.5-515.12 *)
val BinIO.closeIn: BinIO.instream -> unit (* @ $(SML_LIB)/basis/io/imperative-io.fun 718.5-718.11 *)
val BinIO.closeOut: BinIO.outstream -> unit (* @ $(SML_LIB)/basis/io/imperative-io.fun 105.5-105.12 *)
val BinIO.endOfStream: BinIO.instream -> bool (* @ $(SML_LIB)/basis/io/imperative-io.fun 601.5-601.15 *)
val BinIO.flushOut: BinIO.outstream -> unit (* @ $(SML_LIB)/basis/io/imperative-io.fun 104.5-104.12 *)
val BinIO.getInstream: BinIO.instream -> BinIO.StreamIO.instream (* @ $(SML_LIB)/basis/io/imperative-io.fun 646.5-646.15 *)
val BinIO.getOutstream: BinIO.outstream -> BinIO.StreamIO.outstream (* @ $(SML_LIB)/basis/io/imperative-io.fun 107.5-107.16 *)
val BinIO.getPosOut: BinIO.outstream -> BinIO.StreamIO.out_pos (* @ $(SML_LIB)/basis/io/imperative-io.fun 109.5-109.13 *)
val BinIO.input: BinIO.instream -> Word8Vector.vector (* @ $(SML_LIB)/basis/io/imperative-io.fun 285.5-285.9 *)
val BinIO.input1: BinIO.instream -> Word8.word option (* @ $(SML_LIB)/basis/io/imperative-io.fun 316.5-316.10 *)
val BinIO.inputAll: BinIO.instream -> Word8Vector.vector (* @ $(SML_LIB)/basis/io/imperative-io.fun 413.5-413.12 *)
val BinIO.inputN: BinIO.instream * int -> Word8Vector.vector (* @ $(SML_LIB)/basis/io/imperative-io.fun 350.5-350.10 *)
val BinIO.lookahead: BinIO.instream -> Word8.word option (* @ $(SML_LIB)/basis/io/imperative-io.fun 569.5-569.13 *)
val BinIO.mkInstream: BinIO.StreamIO.instream -> BinIO.instream (* @ $(SML_LIB)/basis/io/imperative-io.fun 227.8-227.17 *)
val BinIO.mkOutstream: BinIO.StreamIO.outstream -> BinIO.outstream (* @ $(SML_LIB)/basis/io/imperative-io.fun 106.5-106.15 *)
val BinIO.openAppend: string -> BinIO.outstream (* @ $(SML_LIB)/basis/io/imperative-io.fun 181.8-181.17 *)
val BinIO.openIn: string -> BinIO.instream (* @ $(SML_LIB)/basis/io/imperative-io.fun 745.5-745.10 *)
val BinIO.openOut: string -> BinIO.outstream (* @ $(SML_LIB)/basis/io/imperative-io.fun 168.8-168.14 *)
val BinIO.output: BinIO.outstream * Word8Vector.vector -> unit (* @ $(SML_LIB)/basis/io/imperative-io.fun 101.5-101.10 *)
val BinIO.output1: BinIO.outstream * Word8.word -> unit (* @ $(SML_LIB)/basis/io/imperative-io.fun 102.5-102.11 *)
val BinIO.setInstream: BinIO.instream * BinIO.StreamIO.instream -> unit (* @ $(SML_LIB)/basis/io/imperative-io.fun 235.5-235.15 *)
val BinIO.setOutstream: BinIO.outstream * BinIO.StreamIO.outstream -> unit (* @ $(SML_LIB)/basis/io/imperative-io.fun 108.5-108.16 *)
val BinIO.setPosOut: BinIO.outstream * BinIO.StreamIO.out_pos -> unit (* @ $(SML_LIB)/basis/io/imperative-io.fun 110.5-110.13 *)
structure BinIO.StreamIO: STREAM_IO where type elem = Word8.word where type instream = BinIO.StreamIO.instream where type out_pos = BinIO.StreamIO.out_pos where type outstream = BinIO.StreamIO.outstream where type pos = Int64.int where type reader = BinPrimIO.reader where type vector = Word8Vector.vector where type writer = BinPrimIO.writer (* @ $(SML_LIB)/basis/io/imperative-io.fun 64.11-64.18 *)
type BinIO.StreamIO.elem = Word8.word (* @ $(SML_LIB)/basis/io/stream-io.fun 51.12-51.15 *)
type BinIO.StreamIO.instream = BinIO.StreamIO.instream (* @ $(SML_LIB)/basis/io/stream-io.fun 389.16-389.23 *)
type BinIO.StreamIO.out_pos = BinIO.StreamIO.out_pos (* @ $(SML_LIB)/basis/io/stream-io.fun 357.16-357.22 *)
type BinIO.StreamIO.outstream = BinIO.StreamIO.outstream (* @ $(SML_LIB)/basis/io/stream-io.fun 83.16-83.24 *)
type BinIO.StreamIO.pos = Int64.int (* @ $(SML_LIB)/basis/io/stream-io.fun 56.12-56.14 *)
type BinIO.StreamIO.reader = BinPrimIO.reader (* @ $(SML_LIB)/basis/io/stream-io.fun 54.12-54.17 *)
type BinIO.StreamIO.vector = Word8Vector.vector (* @ $(SML_LIB)/basis/io/stream-io.fun 52.12-52.17 *)
type BinIO.StreamIO.writer = BinPrimIO.writer (* @ $(SML_LIB)/basis/io/stream-io.fun 55.12-55.17 *)
val BinIO.StreamIO.canInput: BinIO.StreamIO.instream * int -> int option (* @ $(SML_LIB)/basis/io/stream-io.fun 649.11-649.18 *)
val BinIO.StreamIO.closeIn: BinIO.StreamIO.instream -> unit (* @ $(SML_LIB)/basis/io/stream-io.fun 953.11-953.17 *)
val BinIO.StreamIO.closeOut: BinIO.StreamIO.outstream -> unit (* @ $(SML_LIB)/basis/io/stream-io.fun 896.11-896.18 *)
val BinIO.StreamIO.endOfStream: BinIO.StreamIO.instream -> bool (* @ $(SML_LIB)/basis/io/stream-io.fun 724.11-724.21 *)
val BinIO.StreamIO.filePosIn: BinIO.StreamIO.instream -> Int64.int (* @ $(SML_LIB)/basis/io/stream-io.fun 784.11-784.19 *)
val BinIO.StreamIO.filePosOut: BinIO.StreamIO.out_pos -> Int64.int (* @ $(SML_LIB)/basis/io/stream-io.fun 374.11-374.20 *)
val BinIO.StreamIO.flushOut: BinIO.StreamIO.outstream -> unit (* @ $(SML_LIB)/basis/io/stream-io.fun 267.11-267.18 *)
val BinIO.StreamIO.getBufferMode: BinIO.StreamIO.outstream -> IO.buffer_mode (* @ $(SML_LIB)/basis/io/stream-io.fun 299.11-299.23 *)
val BinIO.StreamIO.getPosOut: BinIO.StreamIO.outstream -> BinIO.StreamIO.out_pos (* @ $(SML_LIB)/basis/io/stream-io.fun 360.11-360.19 *)
val BinIO.StreamIO.getReader: BinIO.StreamIO.instream -> BinPrimIO.reader * Word8Vector.vector (* @ $(SML_LIB)/basis/io/stream-io.fun 776.11-776.19 *)
val BinIO.StreamIO.getWriter: BinIO.StreamIO.outstream -> BinPrimIO.writer * IO.buffer_mode (* @ $(SML_LIB)/basis/io/stream-io.fun 345.11-345.19 *)
val BinIO.StreamIO.input: BinIO.StreamIO.instream -> Word8Vector.vector * BinIO.StreamIO.instream (* @ $(SML_LIB)/basis/io/stream-io.fun 471.11-471.15 *)
val BinIO.StreamIO.input1: BinIO.StreamIO.instream -> (Word8.word * BinIO.StreamIO.instream) option (* @ $(SML_LIB)/basis/io/stream-io.fun 554.11-554.16 *)
val BinIO.StreamIO.inputAll: BinIO.StreamIO.instream -> Word8Vector.vector * BinIO.StreamIO.instream (* @ $(SML_LIB)/basis/io/stream-io.fun 559.11-559.18 *)
val BinIO.StreamIO.inputN: BinIO.StreamIO.instream * int -> Word8Vector.vector * BinIO.StreamIO.instream (* @ $(SML_LIB)/basis/io/stream-io.fun 486.11-486.16 *)
val BinIO.StreamIO.mkInstream: BinPrimIO.reader * Word8Vector.vector -> BinIO.StreamIO.instream (* @ $(SML_LIB)/basis/io/stream-io.fun 947.11-947.20 *)
val BinIO.StreamIO.mkOutstream: BinPrimIO.writer * IO.buffer_mode -> BinIO.StreamIO.outstream (* @ $(SML_LIB)/basis/io/stream-io.fun 891.11-891.21 *)
val BinIO.StreamIO.output: BinIO.StreamIO.outstream * Word8Vector.vector -> unit (* @ $(SML_LIB)/basis/io/stream-io.fun 139.11-139.16 *)
val BinIO.StreamIO.output1: BinIO.StreamIO.outstream * Word8.word -> unit (* @ $(SML_LIB)/basis/io/stream-io.fun 185.14-185.20 *)
val BinIO.StreamIO.setBufferMode: BinIO.StreamIO.outstream * IO.buffer_mode -> unit (* @ $(SML_LIB)/basis/io/stream-io.fun 305.11-305.23 *)
val BinIO.StreamIO.setPosOut: BinIO.StreamIO.out_pos -> BinIO.StreamIO.outstream (* @ $(SML_LIB)/basis/io/stream-io.fun 367.11-367.19 *)
structure BinPrimIO: PRIM_IO where type array = Word8Array.array where type array_slice = Word8ArraySlice.slice where type elem = Word8.word where type pos = Int64.int where type reader = BinPrimIO.reader where type vector = Word8Vector.vector where type vector_slice = Word8VectorSlice.slice where type writer = BinPrimIO.writer (* @ $(SML_LIB)/basis/libs/basis-extra/top-level/basis.sml 14.17-14.25 *)
type BinPrimIO.array = Word8Array.array (* @ $(SML_LIB)/basis/io/prim-io.fun 39.12-39.16 *)
type BinPrimIO.array_slice = Word8ArraySlice.slice (* @ $(SML_LIB)/basis/io/prim-io.fun 40.12-40.22 *)
type BinPrimIO.elem = Word8.word (* @ $(SML_LIB)/basis/io/prim-io.fun 36.12-36.15 *)
type BinPrimIO.pos = Int64.int (* @ $(SML_LIB)/basis/io/prim-io.fun 41.12-41.14 *)
datatype BinPrimIO.reader = RD of {avail: unit -> int option, block: (unit -> unit) option, canInput: (unit -> bool) option, chunkSize: int, close: unit -> unit, endPos: (unit -> Int64.int) option, getPos: (unit -> Int64.int) option, ioDesc: OS.IO.iodesc option, name: string, readArr: (Word8ArraySlice.slice -> int) option, readArrNB: (Word8ArraySlice.slice -> int option) option, readVec: (int -> Word8Vector.vector) option, readVecNB: (int -> Word8Vector.vector option) option, setPos: (Int64.int -> unit) option, verifyPos: (unit -> Int64.int) option} (* = datatype BinPrimIO.reader *) (* @ $(SML_LIB)/basis/io/prim-io.fun 44.16-44.21 *)
type BinPrimIO.vector = Word8Vector.vector (* @ $(SML_LIB)/basis/io/prim-io.fun 37.12-37.17 *)
type BinPrimIO.vector_slice = Word8VectorSlice.slice (* @ $(SML_LIB)/basis/io/prim-io.fun 38.12-38.23 *)
datatype BinPrimIO.writer = WR of {block: (unit -> unit) option, canOutput: (unit -> bool) option, chunkSize: int, close: unit -> unit, endPos: (unit -> Int64.int) option, getPos: (unit -> Int64.int) option, ioDesc: OS.IO.iodesc option, name: string, setPos: (Int64.int -> unit) option, verifyPos: (unit -> Int64.int) option, writeArr: (Word8ArraySlice.slice -> int) option, writeArrNB: (Word8ArraySlice.slice -> int option) option, writeVec: (Word8VectorSlice.slice -> int) option, writeVecNB: (Word8VectorSlice.slice -> int option) option} (* = datatype BinPrimIO.writer *) (* @ $(SML_LIB)/basis/io/prim-io.fun 61.16-61.21 *)
con BinPrimIO.RD: {avail: unit -> int option, block: (unit -> unit) option, canInput: (unit -> bool) option, chunkSize: int, close: unit -> unit, endPos: (unit -> Int64.int) option, getPos: (unit -> Int64.int) option, ioDesc: OS.IO.iodesc option, name: string, readArr: (Word8ArraySlice.slice -> int) option, readArrNB: (Word8ArraySlice.slice -> int option) option, readVec: (int -> Word8Vector.vector) option, readVecNB: (int -> Word8Vector.vector option) option, setPos: (Int64.int -> unit) option, verifyPos: (unit -> Int64.int) option} -> BinPrimIO.reader (* @ $(SML_LIB)/basis/io/prim-io.fun 45.10-45.11 *)
con BinPrimIO.WR: {block: (unit -> unit) option, canOutput: (unit -> bool) option, chunkSize: int, close: unit -> unit, endPos: (unit -> Int64.int) option, getPos: (unit -> Int64.int) option, ioDesc: OS.IO.iodesc option, name: string, setPos: (Int64.int -> unit) option, verifyPos: (unit -> Int64.int) option, writeArr: (Word8ArraySlice.slice -> int) option, writeArrNB: (Word8ArraySlice.slice -> int option) option, writeVec: (Word8VectorSlice.slice -> int) option, writeVecNB: (Word8VectorSlice.slice -> int option) option} -> BinPrimIO.writer (* @ $(SML_LIB)/basis/io/prim-io.fun 62.10-62.11 *)
val BinPrimIO.augmentReader: BinPrimIO.reader -> BinPrimIO.reader (* @ $(SML_LIB)/basis/io/prim-io.fun 187.11-187.23 *)
val BinPrimIO.augmentWriter: BinPrimIO.writer -> BinPrimIO.writer (* @ $(SML_LIB)/basis/io/prim-io.fun 271.11-271.23 *)
val BinPrimIO.compare: Int64.int * Int64.int -> order (* @ $(SML_LIB)/basis/io/prim-io.fun 42.11-42.17 *)
val BinPrimIO.nullRd: unit -> BinPrimIO.reader (* @ $(SML_LIB)/basis/io/prim-io.fun 129.11-129.16 *)
val BinPrimIO.nullWr: unit -> BinPrimIO.writer (* @ $(SML_LIB)/basis/io/prim-io.fun 156.11-156.16 *)
val BinPrimIO.openVector: Word8Vector.vector -> BinPrimIO.reader (* @ $(SML_LIB)/basis/io/prim-io.fun 82.11-82.20 *)
structure Bool: BOOL (* @ $(SML_LIB)/basis/libs/basis-extra/top-level/basis.sml 15.17-15.20 *)
datatype Bool.bool = false | true (* = datatype bool *) (* @ $(SML_LIB)/basis/general/bool.sml 11.16-11.19 *)
con Bool.false: bool (* @ <bogus> ~1.~1 *)
val Bool.fromString: string -> bool option (* @ $(SML_LIB)/basis/general/bool.sml 30.11-30.20 *)
val Bool.not: bool -> bool (* @ $(SML_LIB)/basis/general/bool.sml 13.11-13.13 *)
val Bool.scan: ('a -> (char * 'a) option) -> 'a -> (bool * 'a) option (* @ $(SML_LIB)/basis/general/bool.sml 15.11-15.14 *)
val Bool.toString: bool -> string (* @ $(SML_LIB)/basis/general/bool.sml 32.11-32.18 *)
con Bool.true: bool (* @ <bogus> ~1.~1 *)
structure BoolArray: MONO_ARRAY where type array = BoolArray.array where type elem = bool where type vector = BoolVector.vector (* @ $(SML_LIB)/basis/libs/basis-2002/top-level/top-level.sml 19.11-19.19 *)
type BoolArray.array = BoolArray.array (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array.fun 23.12-23.16 *)
type BoolArray.elem = bool (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array.fun 22.12-22.15 *)
type BoolArray.vector = BoolVector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array.fun 24.12-24.17 *)
val BoolArray.all: (bool -> bool) -> BoolArray.array -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 476.13-476.15 *)
val BoolArray.app: (bool -> unit) -> BoolArray.array -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 464.13-464.15 *)
val BoolArray.appi: (int * bool -> unit) -> BoolArray.array -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 463.13-463.16 *)
val BoolArray.array: int * bool -> BoolArray.array (* @ $(SML_LIB)/basis/arrays-and-vectors/array.sml 34.11-34.15 *)
val BoolArray.collate: (bool * bool -> order) -> BoolArray.array * BoolArray.array -> order (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 477.13-477.19 *)
val BoolArray.copy: {di: int, dst: BoolArray.array, src: BoolArray.array} -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 457.13-457.16 *)
val BoolArray.copyVec: {di: int, dst: BoolArray.array, src: BoolVector.vector} -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array.sml 37.11-37.17 *)
val BoolArray.exists: (bool -> bool) -> BoolArray.array -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 474.13-474.18 *)
val BoolArray.find: (bool -> bool) -> BoolArray.array -> bool option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 472.13-472.16 *)
val BoolArray.findi: (int * bool -> bool) -> BoolArray.array -> (int * bool) option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 471.13-471.17 *)
val BoolArray.foldl: (bool * 'a -> 'a) -> 'a -> BoolArray.array -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 468.13-468.17 *)
val BoolArray.foldli: (int * bool * 'a -> 'a) -> 'a -> BoolArray.array -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 467.13-467.18 *)
val BoolArray.foldr: (bool * 'a -> 'a) -> 'a -> BoolArray.array -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 470.13-470.17 *)
val BoolArray.foldri: (int * bool * 'a -> 'a) -> 'a -> BoolArray.array -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 469.13-469.18 *)
val BoolArray.fromList: bool list -> BoolArray.array (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 122.11-122.18 *)
val BoolArray.length: BoolArray.array -> int (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 90.11-90.16 *)
val BoolArray.maxLen: int (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 88.11-88.16 *)
val BoolArray.modify: (bool -> bool) -> BoolArray.array -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array.sml 40.11-40.16 *)
val BoolArray.modifyi: (int * bool -> bool) -> BoolArray.array -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array.sml 39.11-39.17 *)
val BoolArray.sub: BoolArray.array * int -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 450.13-450.15 *)
val BoolArray.tabulate: int * (int -> bool) -> BoolArray.array (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 114.11-114.18 *)
val BoolArray.update: BoolArray.array * int * bool -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 452.13-452.18 *)
val BoolArray.vector: BoolArray.array -> BoolVector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/array.sml 36.11-36.16 *)
structure BoolArray2: MONO_ARRAY2 where type array = BoolArray2.array where type elem = bool where type vector = BoolVector.vector (* @ $(SML_LIB)/basis/libs/basis-2002/top-level/top-level.sml 20.11-20.20 *)
type BoolArray2.array = BoolArray2.array (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array2.fun 18.12-18.16 *)
type BoolArray2.elem = bool (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array2.fun 15.12-15.15 *)
type BoolArray2.region = {base: BoolArray2.array, col: int, ncols: int option, nrows: int option, row: int} (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array2.fun 19.12-19.17 *)
datatype BoolArray2.traversal = ColMajor | RowMajor (* = datatype Array2.traversal *) (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 106.16-106.24 *)
type BoolArray2.vector = BoolVector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array2.fun 16.12-16.17 *)
con BoolArray2.ColMajor: Array2.traversal (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 106.39-106.46 *)
con BoolArray2.RowMajor: Array2.traversal (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 106.28-106.35 *)
val BoolArray2.app: Array2.traversal -> (bool -> unit) -> BoolArray2.array -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 294.11-294.13 *)
val BoolArray2.appi: Array2.traversal -> (int * int * bool -> unit) -> {base: BoolArray2.array, col: int, ncols: int option, nrows: int option, row: int} -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 291.11-291.14 *)
val BoolArray2.array: int * int * bool -> BoolArray2.array (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 140.14-140.18 *)
val BoolArray2.column: BoolArray2.array * int -> BoolVector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 237.11-237.16 *)
val BoolArray2.copy: {dst: BoolArray2.array, dst_col: int, dst_row: int, src: {base: BoolArray2.array, col: int, ncols: int option, nrows: int option, row: int}} -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 309.11-309.14 *)
val BoolArray2.dimensions: BoolArray2.array -> int * int (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 33.11-33.20 *)
val BoolArray2.fold: Array2.traversal -> (bool * 'a -> 'a) -> 'a -> BoolArray2.array -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 288.11-288.14 *)
val BoolArray2.foldi: Array2.traversal -> (int * int * bool * 'a -> 'a) -> 'a -> {base: BoolArray2.array, col: int, ncols: int option, nrows: int option, row: int} -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 283.11-283.15 *)
val BoolArray2.fromList: bool list list -> BoolArray2.array (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 188.14-188.21 *)
val BoolArray2.modify: Array2.traversal -> (bool -> bool) -> BoolArray2.array -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 299.11-299.16 *)
val BoolArray2.modifyi: Array2.traversal -> (int * int * bool -> bool) -> {base: BoolArray2.array, col: int, ncols: int option, nrows: int option, row: int} -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 296.11-296.17 *)
val BoolArray2.nCols: BoolArray2.array -> int (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 38.11-38.15 *)
val BoolArray2.nRows: BoolArray2.array -> int (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 36.11-36.15 *)
val BoolArray2.row: BoolArray2.array * int -> BoolVector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 222.11-222.13 *)
val BoolArray2.sub: BoolArray2.array * int * int -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 182.14-182.16 *)
val BoolArray2.tabulate: Array2.traversal -> int * int * (int * int -> bool) -> BoolArray2.array (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 301.11-301.18 *)
val BoolArray2.update: BoolArray2.array * int * int * bool -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 184.14-184.19 *)
structure BoolArraySlice: MONO_ARRAY_SLICE where type array = BoolArray.array where type elem = bool where type slice = BoolArraySlice.slice where type vector = BoolVector.vector where type vector_slice = BoolVectorSlice.slice (* @ $(SML_LIB)/basis/libs/basis-extra/top-level/basis.sml 59.17-59.30 *)
type BoolArraySlice.array = BoolArray.array (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array.fun 35.18-35.22 *)
type BoolArraySlice.elem = bool (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array.fun 34.18-34.21 *)
type BoolArraySlice.slice = BoolArraySlice.slice (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array.fun 36.18-36.22 *)
type BoolArraySlice.vector = BoolVector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array.fun 37.18-37.23 *)
type BoolArraySlice.vector_slice = BoolVectorSlice.slice (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array.fun 38.18-38.29 *)
val BoolArraySlice.all: (bool -> bool) -> BoolArraySlice.slice -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 235.17-235.19 *)
val BoolArraySlice.app: (bool -> unit) -> BoolArraySlice.slice -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 226.17-226.19 *)
val BoolArraySlice.appi: (int * bool -> unit) -> BoolArraySlice.slice -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 225.17-225.20 *)
val BoolArraySlice.base: BoolArraySlice.slice -> BoolArray.array * int * int (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 208.17-208.20 *)
val BoolArraySlice.collate: (bool * bool -> order) -> BoolArraySlice.slice * BoolArraySlice.slice -> order (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 236.17-236.23 *)
val BoolArraySlice.copy: {di: int, dst: BoolArray.array, src: BoolArraySlice.slice} -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 185.17-185.20 *)
val BoolArraySlice.copyVec: {di: int, dst: BoolArray.array, src: BoolVectorSlice.slice} -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array.sml 28.17-28.23 *)
val BoolArraySlice.exists: (bool -> bool) -> BoolArraySlice.slice -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 233.17-233.22 *)
val BoolArraySlice.find: (bool -> bool) -> BoolArraySlice.slice -> bool option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 231.17-231.20 *)
val BoolArraySlice.findi: (int * bool -> bool) -> BoolArraySlice.slice -> (int * bool) option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 229.17-229.21 *)
val BoolArraySlice.foldl: (bool * 'a -> 'a) -> 'a -> BoolArraySlice.slice -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 223.17-223.21 *)
val BoolArraySlice.foldli: (int * bool * 'a -> 'a) -> 'a -> BoolArraySlice.slice -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 221.17-221.22 *)
val BoolArraySlice.foldr: (bool * 'a -> 'a) -> 'a -> BoolArraySlice.slice -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 224.17-224.21 *)
val BoolArraySlice.foldri: (int * bool * 'a -> 'a) -> 'a -> BoolArraySlice.slice -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 222.17-222.22 *)
val BoolArraySlice.full: BoolArray.array -> BoolArraySlice.slice (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 192.17-192.20 *)
val BoolArraySlice.getItem: BoolArraySlice.slice -> (bool * BoolArraySlice.slice) option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 220.17-220.23 *)
val BoolArraySlice.isEmpty: BoolArraySlice.slice -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 219.17-219.23 *)
val BoolArraySlice.length: BoolArraySlice.slice -> int (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 134.17-134.22 *)
val BoolArraySlice.modify: (bool -> bool) -> BoolArraySlice.slice -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array.sml 31.17-31.22 *)
val BoolArraySlice.modifyi: (int * bool -> bool) -> BoolArraySlice.slice -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array.sml 30.17-30.23 *)
val BoolArraySlice.slice: BoolArray.array * int * int option -> BoolArraySlice.slice (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 206.17-206.21 *)
val BoolArraySlice.sub: BoolArraySlice.slice * int -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 142.17-142.19 *)
val BoolArraySlice.subslice: BoolArraySlice.slice * int * int option -> BoolArraySlice.slice (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 199.17-199.24 *)
val BoolArraySlice.update: BoolArraySlice.slice * int * bool -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 155.17-155.22 *)
val BoolArraySlice.vector: BoolArraySlice.slice -> BoolVector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/array.sml 27.17-27.22 *)
structure BoolVector: MONO_VECTOR where type elem = bool where type vector = BoolVector.vector (* @ $(SML_LIB)/basis/libs/basis-2002/top-level/top-level.sml 21.11-21.20 *)
type BoolVector.elem = bool (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-vector.fun 35.12-35.15 *)
type BoolVector.vector = BoolVector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-vector.fun 36.12-36.17 *)
val BoolVector.all: (bool -> bool) -> BoolVector.vector -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 476.13-476.15 *)
val BoolVector.app: (bool -> unit) -> BoolVector.vector -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 464.13-464.15 *)
val BoolVector.appi: (int * bool -> unit) -> BoolVector.vector -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 463.13-463.16 *)
val BoolVector.collate: (bool * bool -> order) -> BoolVector.vector * BoolVector.vector -> order (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 477.13-477.19 *)
val BoolVector.concat: BoolVector.vector list -> BoolVector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 462.13-462.18 *)
val BoolVector.exists: (bool -> bool) -> BoolVector.vector -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 474.13-474.18 *)
val BoolVector.find: (bool -> bool) -> BoolVector.vector -> bool option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 472.13-472.16 *)
val BoolVector.findi: (int * bool -> bool) -> BoolVector.vector -> (int * bool) option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 471.13-471.17 *)
val BoolVector.foldl: (bool * 'a -> 'a) -> 'a -> BoolVector.vector -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 468.13-468.17 *)
val BoolVector.foldli: (int * bool * 'a -> 'a) -> 'a -> BoolVector.vector -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 467.13-467.18 *)
val BoolVector.foldr: (bool * 'a -> 'a) -> 'a -> BoolVector.vector -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 470.13-470.17 *)
val BoolVector.foldri: (int * bool * 'a -> 'a) -> 'a -> BoolVector.vector -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 469.13-469.18 *)
val BoolVector.fromList: bool list -> BoolVector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 122.11-122.18 *)
val BoolVector.length: BoolVector.vector -> int (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 90.11-90.16 *)
val BoolVector.map: (bool -> bool) -> BoolVector.vector -> BoolVector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 466.13-466.15 *)
val BoolVector.mapi: (int * bool -> bool) -> BoolVector.vector -> BoolVector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 465.13-465.16 *)
val BoolVector.maxLen: int (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 88.11-88.16 *)
val BoolVector.sub: BoolVector.vector * int -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 450.13-450.15 *)
val BoolVector.tabulate: int * (int -> bool) -> BoolVector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 114.11-114.18 *)
val BoolVector.update: BoolVector.vector * int * bool -> BoolVector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/vector.sml 30.11-30.16 *)
structure BoolVectorSlice: MONO_VECTOR_SLICE where type elem = bool where type slice = BoolVectorSlice.slice where type vector = BoolVector.vector (* @ $(SML_LIB)/basis/libs/basis-extra/top-level/basis.sml 61.17-61.31 *)
type BoolVectorSlice.elem = bool (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-vector.fun 43.18-43.21 *)
type BoolVectorSlice.slice = BoolVectorSlice.slice (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-vector.fun 45.18-45.22 *)
type BoolVectorSlice.vector = BoolVector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-vector.fun 44.18-44.23 *)
val BoolVectorSlice.all: (bool -> bool) -> BoolVectorSlice.slice -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 235.17-235.19 *)
val BoolVectorSlice.app: (bool -> unit) -> BoolVectorSlice.slice -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 226.17-226.19 *)
val BoolVectorSlice.appi: (int * bool -> unit) -> BoolVectorSlice.slice -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 225.17-225.20 *)
val BoolVectorSlice.base: BoolVectorSlice.slice -> BoolVector.vector * int * int (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 208.17-208.20 *)
val BoolVectorSlice.collate: (bool * bool -> order) -> BoolVectorSlice.slice * BoolVectorSlice.slice -> order (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 236.17-236.23 *)
val BoolVectorSlice.concat: BoolVectorSlice.slice list -> BoolVector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 240.17-240.22 *)
val BoolVectorSlice.exists: (bool -> bool) -> BoolVectorSlice.slice -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 233.17-233.22 *)
val BoolVectorSlice.find: (bool -> bool) -> BoolVectorSlice.slice -> bool option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 231.17-231.20 *)
val BoolVectorSlice.findi: (int * bool -> bool) -> BoolVectorSlice.slice -> (int * bool) option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 229.17-229.21 *)
val BoolVectorSlice.foldl: (bool * 'a -> 'a) -> 'a -> BoolVectorSlice.slice -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 223.17-223.21 *)
val BoolVectorSlice.foldli: (int * bool * 'a -> 'a) -> 'a -> BoolVectorSlice.slice -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 221.17-221.22 *)
val BoolVectorSlice.foldr: (bool * 'a -> 'a) -> 'a -> BoolVectorSlice.slice -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 224.17-224.21 *)
val BoolVectorSlice.foldri: (int * bool * 'a -> 'a) -> 'a -> BoolVectorSlice.slice -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 222.17-222.22 *)
val BoolVectorSlice.full: BoolVector.vector -> BoolVectorSlice.slice (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 192.17-192.20 *)
val BoolVectorSlice.getItem: BoolVectorSlice.slice -> (bool * BoolVectorSlice.slice) option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 220.17-220.23 *)
val BoolVectorSlice.isEmpty: BoolVectorSlice.slice -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 219.17-219.23 *)
val BoolVectorSlice.length: BoolVectorSlice.slice -> int (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 134.17-134.22 *)
val BoolVectorSlice.map: (bool -> bool) -> BoolVectorSlice.slice -> BoolVector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 228.17-228.19 *)
val BoolVectorSlice.mapi: (int * bool -> bool) -> BoolVectorSlice.slice -> BoolVector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 227.17-227.20 *)
val BoolVectorSlice.slice: BoolVector.vector * int * int option -> BoolVectorSlice.slice (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 206.17-206.21 *)
val BoolVectorSlice.sub: BoolVectorSlice.slice * int -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 142.17-142.19 *)
val BoolVectorSlice.subslice: BoolVectorSlice.slice * int * int option -> BoolVectorSlice.slice (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 199.17-199.24 *)
val BoolVectorSlice.vector: BoolVectorSlice.slice -> BoolVector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/vector.sml 21.17-21.22 *)
structure Byte: BYTE (* @ $(SML_LIB)/basis/libs/basis-extra/top-level/basis.sml 16.17-16.20 *)
val Byte.byteToChar: Word8.word -> char (* @ $(SML_LIB)/basis/text/byte.sml 11.11-11.20 *)
val Byte.bytesToString: Word8Vector.vector -> string (* @ $(SML_LIB)/basis/text/byte.sml 13.11-13.23 *)
val Byte.charToByte: char -> Word8.word (* @ $(SML_LIB)/basis/text/byte.sml 15.11-15.20 *)
val Byte.packString: Word8Array.array * int * char VectorSlice.slice -> unit (* @ $(SML_LIB)/basis/text/byte.sml 17.11-17.20 *)
val Byte.stringToBytes: string -> Word8Vector.vector (* @ $(SML_LIB)/basis/text/byte.sml 22.11-22.23 *)
val Byte.unpackString: Word8ArraySlice.slice -> string (* @ $(SML_LIB)/basis/text/byte.sml 28.14-28.25 *)
val Byte.unpackStringVec: Word8VectorSlice.slice -> string (* @ $(SML_LIB)/basis/text/byte.sml 29.14-29.28 *)
structure Char: CHAR where type char = char where type string = string (* @ $(SML_LIB)/basis/libs/basis-extra/top-level/basis.sml 17.17-17.20 *)
type Char.char = char (* @ $(SML_LIB)/basis/primitive/prim-basis.sml 57.12-57.15 *)
type Char.string = string (* @ $(SML_LIB)/basis/text/char.sml 25.12-25.17 *)
val Char.< : char * char -> bool (* @ $(SML_LIB)/basis/util/integral-comparisons.sml 11.11-11.11 *)
val Char.<= : char * char -> bool (* @ $(SML_LIB)/basis/util/integral-comparisons.sml 12.11-12.12 *)
val Char.> : char * char -> bool (* @ $(SML_LIB)/basis/util/integral-comparisons.sml 13.11-13.11 *)
val Char.>= : char * char -> bool (* @ $(SML_LIB)/basis/util/integral-comparisons.sml 14.11-14.12 *)
val Char.chr: int -> char (* @ $(SML_LIB)/basis/text/char.sml 50.11-50.13 *)
val Char.compare: char * char -> order (* @ $(SML_LIB)/basis/util/integral-comparisons.sml 16.11-16.17 *)
val Char.contains: string -> char -> bool (* @ $(SML_LIB)/basis/text/char.sml 59.11-59.18 *)
val Char.fromCString: string -> char option (* @ $(SML_LIB)/basis/text/char.sml 272.11-272.21 *)
val Char.fromString: string -> char option (* @ $(SML_LIB)/basis/text/char.sml 217.11-217.20 *)
val Char.isAlpha: char -> bool (* @ $(SML_LIB)/basis/text/char.sml 90.11-90.17 *)
val Char.isAlphaNum: char -> bool (* @ $(SML_LIB)/basis/text/char.sml 91.11-91.20 *)
val Char.isAscii: char -> bool (* @ $(SML_LIB)/basis/text/char.sml 87.11-87.17 *)
val Char.isCntrl: char -> bool (* @ $(SML_LIB)/basis/text/char.sml 86.11-86.17 *)
val Char.isDigit: char -> bool (* @ $(SML_LIB)/basis/text/char.sml 83.11-83.17 *)
val Char.isGraph: char -> bool (* @ $(SML_LIB)/basis/text/char.sml 84.11-84.17 *)
val Char.isHexDigit: char -> bool (* @ $(SML_LIB)/basis/text/char.sml 96.11-96.20 *)
val Char.isLower: char -> bool (* @ $(SML_LIB)/basis/text/char.sml 81.11-81.17 *)
val Char.isPrint: char -> bool (* @ $(SML_LIB)/basis/text/char.sml 85.11-85.17 *)
val Char.isPunct: char -> bool (* @ $(SML_LIB)/basis/text/char.sml 102.11-102.17 *)
val Char.isSpace: char -> bool (* @ $(SML_LIB)/basis/text/char.sml 101.11-101.17 *)
val Char.isUpper: char -> bool (* @ $(SML_LIB)/basis/text/char.sml 82.11-82.17 *)
val Char.maxChar: char (* @ $(SML_LIB)/basis/text/char0.sml 57.44-57.50 *)
val Char.maxOrd: int (* @ $(SML_LIB)/basis/text/char.sml 26.11-26.16 *)
val Char.minChar: char (* @ $(SML_LIB)/basis/text/char0.sml 57.35-57.41 *)
val Char.notContains: string -> char -> bool (* @ $(SML_LIB)/basis/text/char.sml 74.11-74.21 *)
val Char.ord: char -> int (* @ $(SML_LIB)/basis/text/char0.sml 57.30-57.32 *)
val Char.pred: char -> char (* @ $(SML_LIB)/basis/text/char.sml 38.11-38.14 *)
val Char.scan: ('a -> (char * 'a) option) -> 'a -> (char * 'a) option (* @ $(SML_LIB)/basis/text/char.sml 160.14-160.17 *)
val Char.succ: char -> char (* @ $(SML_LIB)/basis/text/char.sml 32.11-32.14 *)
val Char.toCString: char -> string (* @ $(SML_LIB)/basis/text/char.sml 324.11-324.19 *)
val Char.toLower: char -> char (* @ $(SML_LIB)/basis/text/char.sml 109.14-109.20 *)
val Char.toString: char -> string (* @ $(SML_LIB)/basis/text/char.sml 292.11-292.18 *)
val Char.toUpper: char -> char (* @ $(SML_LIB)/basis/text/char.sml 110.14-110.20 *)
structure CharArray: MONO_ARRAY where type array = CharArray.array where type elem = char where type vector = string (* @ $(SML_LIB)/basis/libs/basis-2002/top-level/top-level.sml 23.11-23.19 *)
type CharArray.array = CharArray.array (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array.fun 23.12-23.16 *)
type CharArray.elem = char (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array.fun 22.12-22.15 *)
type CharArray.vector = string (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array.fun 24.12-24.17 *)
val CharArray.all: (char -> bool) -> CharArray.array -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 476.13-476.15 *)
val CharArray.app: (char -> unit) -> CharArray.array -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 464.13-464.15 *)
val CharArray.appi: (int * char -> unit) -> CharArray.array -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 463.13-463.16 *)
val CharArray.array: int * char -> CharArray.array (* @ $(SML_LIB)/basis/arrays-and-vectors/array.sml 34.11-34.15 *)
val CharArray.collate: (char * char -> order) -> CharArray.array * CharArray.array -> order (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 477.13-477.19 *)
val CharArray.copy: {di: int, dst: CharArray.array, src: CharArray.array} -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 457.13-457.16 *)
val CharArray.copyVec: {di: int, dst: CharArray.array, src: string} -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array.sml 37.11-37.17 *)
val CharArray.exists: (char -> bool) -> CharArray.array -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 474.13-474.18 *)
val CharArray.find: (char -> bool) -> CharArray.array -> char option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 472.13-472.16 *)
val CharArray.findi: (int * char -> bool) -> CharArray.array -> (int * char) option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 471.13-471.17 *)
val CharArray.foldl: (char * 'a -> 'a) -> 'a -> CharArray.array -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 468.13-468.17 *)
val CharArray.foldli: (int * char * 'a -> 'a) -> 'a -> CharArray.array -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 467.13-467.18 *)
val CharArray.foldr: (char * 'a -> 'a) -> 'a -> CharArray.array -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 470.13-470.17 *)
val CharArray.foldri: (int * char * 'a -> 'a) -> 'a -> CharArray.array -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 469.13-469.18 *)
val CharArray.fromList: char list -> CharArray.array (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 122.11-122.18 *)
val CharArray.length: CharArray.array -> int (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 90.11-90.16 *)
val CharArray.maxLen: int (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 88.11-88.16 *)
val CharArray.modify: (char -> char) -> CharArray.array -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array.sml 40.11-40.16 *)
val CharArray.modifyi: (int * char -> char) -> CharArray.array -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array.sml 39.11-39.17 *)
val CharArray.sub: CharArray.array * int -> char (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 450.13-450.15 *)
val CharArray.tabulate: int * (int -> char) -> CharArray.array (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 114.11-114.18 *)
val CharArray.update: CharArray.array * int * char -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 452.13-452.18 *)
val CharArray.vector: CharArray.array -> string (* @ $(SML_LIB)/basis/arrays-and-vectors/array.sml 36.11-36.16 *)
structure CharArray2: MONO_ARRAY2 where type array = CharArray2.array where type elem = char where type vector = string (* @ $(SML_LIB)/basis/libs/basis-2002/top-level/top-level.sml 24.11-24.20 *)
type CharArray2.array = CharArray2.array (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array2.fun 18.12-18.16 *)
type CharArray2.elem = char (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array2.fun 15.12-15.15 *)
type CharArray2.region = {base: CharArray2.array, col: int, ncols: int option, nrows: int option, row: int} (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array2.fun 19.12-19.17 *)
datatype CharArray2.traversal = ColMajor | RowMajor (* = datatype Array2.traversal *) (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 106.16-106.24 *)
type CharArray2.vector = string (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array2.fun 16.12-16.17 *)
con CharArray2.ColMajor: Array2.traversal (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 106.39-106.46 *)
con CharArray2.RowMajor: Array2.traversal (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 106.28-106.35 *)
val CharArray2.app: Array2.traversal -> (char -> unit) -> CharArray2.array -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 294.11-294.13 *)
val CharArray2.appi: Array2.traversal -> (int * int * char -> unit) -> {base: CharArray2.array, col: int, ncols: int option, nrows: int option, row: int} -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 291.11-291.14 *)
val CharArray2.array: int * int * char -> CharArray2.array (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 140.14-140.18 *)
val CharArray2.column: CharArray2.array * int -> string (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 237.11-237.16 *)
val CharArray2.copy: {dst: CharArray2.array, dst_col: int, dst_row: int, src: {base: CharArray2.array, col: int, ncols: int option, nrows: int option, row: int}} -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 309.11-309.14 *)
val CharArray2.dimensions: CharArray2.array -> int * int (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 33.11-33.20 *)
val CharArray2.fold: Array2.traversal -> (char * 'a -> 'a) -> 'a -> CharArray2.array -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 288.11-288.14 *)
val CharArray2.foldi: Array2.traversal -> (int * int * char * 'a -> 'a) -> 'a -> {base: CharArray2.array, col: int, ncols: int option, nrows: int option, row: int} -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 283.11-283.15 *)
val CharArray2.fromList: char list list -> CharArray2.array (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 188.14-188.21 *)
val CharArray2.modify: Array2.traversal -> (char -> char) -> CharArray2.array -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 299.11-299.16 *)
val CharArray2.modifyi: Array2.traversal -> (int * int * char -> char) -> {base: CharArray2.array, col: int, ncols: int option, nrows: int option, row: int} -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 296.11-296.17 *)
val CharArray2.nCols: CharArray2.array -> int (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 38.11-38.15 *)
val CharArray2.nRows: CharArray2.array -> int (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 36.11-36.15 *)
val CharArray2.row: CharArray2.array * int -> string (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 222.11-222.13 *)
val CharArray2.sub: CharArray2.array * int * int -> char (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 182.14-182.16 *)
val CharArray2.tabulate: Array2.traversal -> int * int * (int * int -> char) -> CharArray2.array (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 301.11-301.18 *)
val CharArray2.update: CharArray2.array * int * int * char -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 184.14-184.19 *)
structure CharArraySlice: MONO_ARRAY_SLICE where type array = CharArray.array where type elem = char where type slice = CharArraySlice.slice where type vector = string where type vector_slice = char VectorSlice.slice (* @ $(SML_LIB)/basis/libs/basis-2002/top-level/top-level.sml 22.11-22.24 *)
type CharArraySlice.array = CharArray.array (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array.fun 35.18-35.22 *)
type CharArraySlice.elem = char (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array.fun 34.18-34.21 *)
type CharArraySlice.slice = CharArraySlice.slice (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array.fun 36.18-36.22 *)
type CharArraySlice.vector = string (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array.fun 37.18-37.23 *)
type CharArraySlice.vector_slice = char VectorSlice.slice (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array.fun 38.18-38.29 *)
val CharArraySlice.all: (char -> bool) -> CharArraySlice.slice -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 235.17-235.19 *)
val CharArraySlice.app: (char -> unit) -> CharArraySlice.slice -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 226.17-226.19 *)
val CharArraySlice.appi: (int * char -> unit) -> CharArraySlice.slice -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 225.17-225.20 *)
val CharArraySlice.base: CharArraySlice.slice -> CharArray.array * int * int (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 208.17-208.20 *)
val CharArraySlice.collate: (char * char -> order) -> CharArraySlice.slice * CharArraySlice.slice -> order (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 236.17-236.23 *)
val CharArraySlice.copy: {di: int, dst: CharArray.array, src: CharArraySlice.slice} -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 185.17-185.20 *)
val CharArraySlice.copyVec: {di: int, dst: CharArray.array, src: char VectorSlice.slice} -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array.sml 28.17-28.23 *)
val CharArraySlice.exists: (char -> bool) -> CharArraySlice.slice -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 233.17-233.22 *)
val CharArraySlice.find: (char -> bool) -> CharArraySlice.slice -> char option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 231.17-231.20 *)
val CharArraySlice.findi: (int * char -> bool) -> CharArraySlice.slice -> (int * char) option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 229.17-229.21 *)
val CharArraySlice.foldl: (char * 'a -> 'a) -> 'a -> CharArraySlice.slice -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 223.17-223.21 *)
val CharArraySlice.foldli: (int * char * 'a -> 'a) -> 'a -> CharArraySlice.slice -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 221.17-221.22 *)
val CharArraySlice.foldr: (char * 'a -> 'a) -> 'a -> CharArraySlice.slice -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 224.17-224.21 *)
val CharArraySlice.foldri: (int * char * 'a -> 'a) -> 'a -> CharArraySlice.slice -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 222.17-222.22 *)
val CharArraySlice.full: CharArray.array -> CharArraySlice.slice (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 192.17-192.20 *)
val CharArraySlice.getItem: CharArraySlice.slice -> (char * CharArraySlice.slice) option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 220.17-220.23 *)
val CharArraySlice.isEmpty: CharArraySlice.slice -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 219.17-219.23 *)
val CharArraySlice.length: CharArraySlice.slice -> int (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 134.17-134.22 *)
val CharArraySlice.modify: (char -> char) -> CharArraySlice.slice -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array.sml 31.17-31.22 *)
val CharArraySlice.modifyi: (int * char -> char) -> CharArraySlice.slice -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array.sml 30.17-30.23 *)
val CharArraySlice.slice: CharArray.array * int * int option -> CharArraySlice.slice (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 206.17-206.21 *)
val CharArraySlice.sub: CharArraySlice.slice * int -> char (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 142.17-142.19 *)
val CharArraySlice.subslice: CharArraySlice.slice * int * int option -> CharArraySlice.slice (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 199.17-199.24 *)
val CharArraySlice.update: CharArraySlice.slice * int * char -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 155.17-155.22 *)
val CharArraySlice.vector: CharArraySlice.slice -> string (* @ $(SML_LIB)/basis/arrays-and-vectors/array.sml 27.17-27.22 *)
structure CharVector: MONO_VECTOR where type elem = char where type vector = string (* @ $(SML_LIB)/basis/libs/basis-extra/top-level/basis.sml 20.17-20.26 *)
type CharVector.elem = char (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-vector.fun 35.12-35.15 *)
type CharVector.vector = string (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-vector.fun 36.12-36.17 *)
val CharVector.all: (char -> bool) -> string -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 476.13-476.15 *)
val CharVector.app: (char -> unit) -> string -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 464.13-464.15 *)
val CharVector.appi: (int * char -> unit) -> string -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 463.13-463.16 *)
val CharVector.collate: (char * char -> order) -> string * string -> order (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 477.13-477.19 *)
val CharVector.concat: string list -> string (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 462.13-462.18 *)
val CharVector.exists: (char -> bool) -> string -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 474.13-474.18 *)
val CharVector.find: (char -> bool) -> string -> char option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 472.13-472.16 *)
val CharVector.findi: (int * char -> bool) -> string -> (int * char) option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 471.13-471.17 *)
val CharVector.foldl: (char * 'a -> 'a) -> 'a -> string -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 468.13-468.17 *)
val CharVector.foldli: (int * char * 'a -> 'a) -> 'a -> string -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 467.13-467.18 *)
val CharVector.foldr: (char * 'a -> 'a) -> 'a -> string -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 470.13-470.17 *)
val CharVector.foldri: (int * char * 'a -> 'a) -> 'a -> string -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 469.13-469.18 *)
val CharVector.fromList: char list -> string (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 122.11-122.18 *)
val CharVector.length: string -> int (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 90.11-90.16 *)
val CharVector.map: (char -> char) -> string -> string (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 466.13-466.15 *)
val CharVector.mapi: (int * char -> char) -> string -> string (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 465.13-465.16 *)
val CharVector.maxLen: int (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 88.11-88.16 *)
val CharVector.sub: string * int -> char (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 450.13-450.15 *)
val CharVector.tabulate: int * (int -> char) -> string (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 114.11-114.18 *)
val CharVector.update: string * int * char -> string (* @ $(SML_LIB)/basis/arrays-and-vectors/vector.sml 30.11-30.16 *)
structure CharVectorSlice: MONO_VECTOR_SLICE where type elem = char where type slice = char VectorSlice.slice where type vector = string (* @ $(SML_LIB)/basis/libs/basis-extra/top-level/basis.sml 21.17-21.31 *)
type CharVectorSlice.elem = char (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-vector.fun 43.18-43.21 *)
type CharVectorSlice.slice = char VectorSlice.slice (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-vector.fun 45.18-45.22 *)
type CharVectorSlice.vector = string (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-vector.fun 44.18-44.23 *)
val CharVectorSlice.all: (char -> bool) -> char VectorSlice.slice -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 235.17-235.19 *)
val CharVectorSlice.app: (char -> unit) -> char VectorSlice.slice -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 226.17-226.19 *)
val CharVectorSlice.appi: (int * char -> unit) -> char VectorSlice.slice -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 225.17-225.20 *)
val CharVectorSlice.base: char VectorSlice.slice -> string * int * int (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 208.17-208.20 *)
val CharVectorSlice.collate: (char * char -> order) -> char VectorSlice.slice * char VectorSlice.slice -> order (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 236.17-236.23 *)
val CharVectorSlice.concat: char VectorSlice.slice list -> string (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 240.17-240.22 *)
val CharVectorSlice.exists: (char -> bool) -> char VectorSlice.slice -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 233.17-233.22 *)
val CharVectorSlice.find: (char -> bool) -> char VectorSlice.slice -> char option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 231.17-231.20 *)
val CharVectorSlice.findi: (int * char -> bool) -> char VectorSlice.slice -> (int * char) option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 229.17-229.21 *)
val CharVectorSlice.foldl: (char * 'a -> 'a) -> 'a -> char VectorSlice.slice -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 223.17-223.21 *)
val CharVectorSlice.foldli: (int * char * 'a -> 'a) -> 'a -> char VectorSlice.slice -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 221.17-221.22 *)
val CharVectorSlice.foldr: (char * 'a -> 'a) -> 'a -> char VectorSlice.slice -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 224.17-224.21 *)
val CharVectorSlice.foldri: (int * char * 'a -> 'a) -> 'a -> char VectorSlice.slice -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 222.17-222.22 *)
val CharVectorSlice.full: string -> char VectorSlice.slice (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 192.17-192.20 *)
val CharVectorSlice.getItem: char VectorSlice.slice -> (char * char VectorSlice.slice) option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 220.17-220.23 *)
val CharVectorSlice.isEmpty: char VectorSlice.slice -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 219.17-219.23 *)
val CharVectorSlice.length: char VectorSlice.slice -> int (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 134.17-134.22 *)
val CharVectorSlice.map: (char -> char) -> char VectorSlice.slice -> string (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 228.17-228.19 *)
val CharVectorSlice.mapi: (int * char -> char) -> char VectorSlice.slice -> string (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 227.17-227.20 *)
val CharVectorSlice.slice: string * int * int option -> char VectorSlice.slice (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 206.17-206.21 *)
val CharVectorSlice.sub: char VectorSlice.slice * int -> char (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 142.17-142.19 *)
val CharVectorSlice.subslice: char VectorSlice.slice * int * int option -> char VectorSlice.slice (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 199.17-199.24 *)
val CharVectorSlice.vector: char VectorSlice.slice -> string (* @ $(SML_LIB)/basis/arrays-and-vectors/vector.sml 21.17-21.22 *)
structure CommandLine: COMMAND_LINE (* @ $(SML_LIB)/basis/libs/basis-extra/top-level/basis.sml 22.17-22.27 *)
val CommandLine.arguments: unit -> string list (* @ $(SML_LIB)/basis/system/command-line.sml 16.11-16.19 *)
val CommandLine.name: unit -> string (* @ $(SML_LIB)/basis/system/command-line.sml 13.11-13.14 *)
structure Date: DATE where type date = Date.date where type month = Date.month where type weekday = Date.weekday (* @ $(SML_LIB)/basis/libs/basis-extra/top-level/basis.sml 23.17-23.20 *)
type Date.date = Date.date (* @ $(SML_LIB)/basis/system/date.sml 44.10-44.13 *)
datatype Date.month = Apr | Aug | Dec | Feb | Jan | Jul | Jun | Mar | May | Nov | Oct | Sep (* = datatype Date.month *) (* @ $(SML_LIB)/basis/system/date.sml 29.14-29.18 *)
datatype Date.weekday = Fri | Mon | Sat | Sun | Thu | Tue | Wed (* = datatype Date.weekday *) (* @ $(SML_LIB)/basis/system/date.sml 27.14-27.20 *)
con Date.Apr: Date.month (* @ $(SML_LIB)/basis/system/date.sml 29.40-29.42 *)
con Date.Aug: Date.month (* @ $(SML_LIB)/basis/system/date.sml 30.28-30.30 *)
exn Date.Date: exn (* @ $(SML_LIB)/basis/system/date.sml 60.15-60.18 *)
con Date.Dec: Date.month (* @ $(SML_LIB)/basis/system/date.sml 30.52-30.54 *)
con Date.Feb: Date.month (* @ $(SML_LIB)/basis/system/date.sml 29.28-29.30 *)
con Date.Fri: Date.weekday (* @ $(SML_LIB)/basis/system/date.sml 27.48-27.50 *)
con Date.Jan: Date.month (* @ $(SML_LIB)/basis/system/date.sml 29.22-29.24 *)
con Date.Jul: Date.month (* @ $(SML_LIB)/basis/system/date.sml 30.22-30.24 *)
con Date.Jun: Date.month (* @ $(SML_LIB)/basis/system/date.sml 29.52-29.54 *)
con Date.Mar: Date.month (* @ $(SML_LIB)/basis/system/date.sml 29.34-29.36 *)
con Date.May: Date.month (* @ $(SML_LIB)/basis/system/date.sml 29.46-29.48 *)
con Date.Mon: Date.weekday (* @ $(SML_LIB)/basis/system/date.sml 27.24-27.26 *)
con Date.Nov: Date.month (* @ $(SML_LIB)/basis/system/date.sml 30.46-30.48 *)
con Date.Oct: Date.month (* @ $(SML_LIB)/basis/system/date.sml 30.40-30.42 *)
con Date.Sat: Date.weekday (* @ $(SML_LIB)/basis/system/date.sml 27.54-27.56 *)
con Date.Sep: Date.month (* @ $(SML_LIB)/basis/system/date.sml 30.34-30.36 *)
con Date.Sun: Date.weekday (* @ $(SML_LIB)/basis/system/date.sml 27.60-27.62 *)
con Date.Thu: Date.weekday (* @ $(SML_LIB)/basis/system/date.sml 27.42-27.44 *)
con Date.Tue: Date.weekday (* @ $(SML_LIB)/basis/system/date.sml 27.30-27.32 *)
con Date.Wed: Date.weekday (* @ $(SML_LIB)/basis/system/date.sml 27.36-27.38 *)
val Date.compare: Date.date * Date.date -> order (* @ $(SML_LIB)/basis/system/date.sml 504.9-504.15 *)
val Date.date: {day: int, hour: int, minute: int, month: Date.month, offset: Time.time option, second: int, year: int} -> Date.date (* @ $(SML_LIB)/basis/system/date.sml 522.9-522.12 *)
val Date.day: Date.date -> int (* @ $(SML_LIB)/basis/system/date.sml 49.12-49.14 *)
val Date.fmt: string -> Date.date -> string (* @ $(SML_LIB)/basis/system/date.sml 316.12-316.14 *)
val Date.fromString: string -> Date.date option (* @ $(SML_LIB)/basis/system/date.sml 501.9-501.18 *)
val Date.fromTimeLocal: Time.time -> Date.date (* @ $(SML_LIB)/basis/system/date.sml 281.9-281.21 *)
val Date.fromTimeUniv: Time.time -> Date.date (* @ $(SML_LIB)/basis/system/date.sml 284.9-284.20 *)
val Date.hour: Date.date -> int (* @ $(SML_LIB)/basis/system/date.sml 50.12-50.15 *)
val Date.isDst: Date.date -> bool option (* @ $(SML_LIB)/basis/system/date.sml 51.12-51.16 *)
val Date.localOffset: unit -> Time.time (* @ $(SML_LIB)/basis/system/date.sml 303.9-303.19 *)
val Date.minute: Date.date -> int (* @ $(SML_LIB)/basis/system/date.sml 52.12-52.17 *)
val Date.month: Date.date -> Date.month (* @ $(SML_LIB)/basis/system/date.sml 53.12-53.16 *)
val Date.offset: Date.date -> Time.time option (* @ $(SML_LIB)/basis/system/date.sml 542.9-542.14 *)
val Date.scan: ('a -> (char * 'a) option) -> 'a -> (Date.date * 'a) option (* @ $(SML_LIB)/basis/system/date.sml 372.9-372.12 *)
val Date.second: Date.date -> int (* @ $(SML_LIB)/basis/system/date.sml 54.12-54.17 *)
val Date.toString: Date.date -> string (* @ $(SML_LIB)/basis/system/date.sml 368.9-368.16 *)
val Date.toTime: Date.date -> Time.time (* @ $(SML_LIB)/basis/system/date.sml 291.9-291.14 *)
val Date.weekDay: Date.date -> Date.weekday (* @ $(SML_LIB)/basis/system/date.sml 55.12-55.18 *)
val Date.year: Date.date -> int (* @ $(SML_LIB)/basis/system/date.sml 56.12-56.15 *)
val Date.yearDay: Date.date -> int (* @ $(SML_LIB)/basis/system/date.sml 57.12-57.18 *)
structure FixedInt: INTEGER where type int = Int64.int (* @ $(SML_LIB)/basis/libs/basis-extra/top-level/basis.sml 63.17-63.24 *)
type FixedInt.int = Int64.int (* @ $(SML_LIB)/basis/primitive/prim-basis.sml 233.12-233.14 *)
val FixedInt.* : Int64.int * Int64.int -> Int64.int (* @ $(SML_LIB)/basis/primitive/prim-int.sml 438.11-438.11 *)
val FixedInt.+ : Int64.int * Int64.int -> Int64.int (* @ $(SML_LIB)/basis/primitive/prim-int.sml 432.11-432.11 *)
val FixedInt.- : Int64.int * Int64.int -> Int64.int (* @ $(SML_LIB)/basis/primitive/prim-int.sml 451.11-451.11 *)
val FixedInt.< : Int64.int * Int64.int -> bool (* @ $(SML_LIB)/basis/util/integral-comparisons.sml 11.11-11.11 *)
val FixedInt.<= : Int64.int * Int64.int -> bool (* @ $(SML_LIB)/basis/util/integral-comparisons.sml 12.11-12.12 *)
val FixedInt.> : Int64.int * Int64.int -> bool (* @ $(SML_LIB)/basis/util/integral-comparisons.sml 13.11-13.11 *)
val FixedInt.>= : Int64.int * Int64.int -> bool (* @ $(SML_LIB)/basis/util/integral-comparisons.sml 14.11-14.12 *)
val FixedInt.abs: Int64.int -> Int64.int (* @ $(SML_LIB)/basis/integer/num0.sml 161.17-161.19 *)
val FixedInt.compare: Int64.int * Int64.int -> order (* @ $(SML_LIB)/basis/util/integral-comparisons.sml 16.11-16.17 *)
val FixedInt.div: Int64.int * Int64.int -> Int64.int (* @ $(SML_LIB)/basis/integer/num0.sml 183.19-183.21 *)
val FixedInt.fmt: StringCvt.radix -> Int64.int -> string (* @ $(SML_LIB)/basis/integer/int.sml 74.8-74.10 *)
val FixedInt.fromInt: int -> Int64.int (* @ $(SML_LIB)/basis/integer/int.sml 46.5-46.11 *)
val FixedInt.fromLarge: LargeInt.int -> Int64.int (* @ $(SML_LIB)/basis/integer/int.sml 51.5-51.13 *)
val FixedInt.fromString: string -> Int64.int option (* @ $(SML_LIB)/basis/integer/int.sml 165.5-165.14 *)
val FixedInt.max: Int64.int * Int64.int -> Int64.int (* @ $(SML_LIB)/basis/util/integral-comparisons.sml 21.11-21.13 *)
val FixedInt.maxInt: Int64.int option (* @ $(SML_LIB)/basis/integer/int.sml 19.5-19.10 *)
val FixedInt.min: Int64.int * Int64.int -> Int64.int (* @ $(SML_LIB)/basis/util/integral-comparisons.sml 20.11-20.13 *)
val FixedInt.minInt: Int64.int option (* @ $(SML_LIB)/basis/integer/int.sml 20.5-20.10 *)
val FixedInt.mod: Int64.int * Int64.int -> Int64.int (* @ $(SML_LIB)/basis/integer/num0.sml 204.19-204.21 *)
val FixedInt.precision: int option (* @ $(SML_LIB)/basis/integer/int.sml 16.5-16.13 *)
val FixedInt.quot: Int64.int * Int64.int -> Int64.int (* @ $(SML_LIB)/basis/integer/num0.sml 163.17-163.20 *)
val FixedInt.rem: Int64.int * Int64.int -> Int64.int (* @ $(SML_LIB)/basis/integer/num0.sml 175.17-175.19 *)
val FixedInt.sameSign: Int64.int * Int64.int -> bool (* @ $(SML_LIB)/basis/integer/int.sml 29.5-29.12 *)
val FixedInt.scan: StringCvt.radix -> ('a -> (char * 'a) option) -> 'a -> (Int64.int * 'a) option (* @ $(SML_LIB)/basis/integer/int.sml 112.5-112.8 *)
val FixedInt.sign: Int64.int -> int (* @ $(SML_LIB)/basis/integer/int.sml 22.5-22.8 *)
val FixedInt.toInt: Int64.int -> int (* @ $(SML_LIB)/basis/integer/int.sml 47.5-47.9 *)
val FixedInt.toLarge: Int64.int -> LargeInt.int (* @ $(SML_LIB)/basis/integer/int.sml 52.5-52.11 *)
val FixedInt.toString: Int64.int -> string (* @ $(SML_LIB)/basis/integer/int.sml 110.5-110.12 *)
val FixedInt.~ : Int64.int -> Int64.int (* @ $(SML_LIB)/basis/primitive/prim-int.sml 444.11-444.11 *)
structure General: GENERAL where type exn = exn where type order = order where type unit = unit (* @ $(SML_LIB)/basis/libs/basis-extra/top-level/basis.sml 24.17-24.23 *)
type General.exn = exn (* @ $(SML_LIB)/basis/general/general.sml 13.12-13.14 *)
datatype General.order = EQUAL | GREATER | LESS (* = datatype order *) (* @ $(SML_LIB)/basis/general/general.sml 25.16-25.20 *)
type General.unit = unit (* @ $(SML_LIB)/basis/general/general.sml 11.12-11.15 *)
val General.! : 'a ref -> 'a (* @ $(SML_LIB)/basis/general/general.sml 27.11-27.11 *)
val General.:= : 'a ref * 'a -> unit (* @ $(SML_LIB)/basis/general/general.sml 28.14-28.15 *)
exn General.Bind: exn (* @ $(SML_LIB)/basis/general/general.sml 14.17-14.20 *)
exn General.Chr: exn (* @ $(SML_LIB)/basis/general/general.sml 16.17-16.19 *)
exn General.Div: exn (* @ $(SML_LIB)/basis/general/general.sml 17.17-17.19 *)
exn General.Domain: exn (* @ $(SML_LIB)/basis/general/general.sml 18.17-18.22 *)
con General.EQUAL: order (* @ $(SML_LIB)/basis/primitive/prim1.sml 61.27-61.31 *)
exn General.Fail: string -> exn (* @ $(SML_LIB)/basis/general/general.sml 19.17-19.20 *)
con General.GREATER: order (* @ $(SML_LIB)/basis/primitive/prim1.sml 61.35-61.41 *)
con General.LESS: order (* @ $(SML_LIB)/basis/primitive/prim1.sml 61.20-61.23 *)
exn General.Match: exn (* @ $(SML_LIB)/basis/general/general.sml 15.17-15.21 *)
exn General.Overflow: exn (* @ $(SML_LIB)/basis/general/general.sml 20.17-20.24 *)
exn General.Size: exn (* @ $(SML_LIB)/basis/general/general.sml 21.17-21.20 *)
exn General.Span: exn (* @ $(SML_LIB)/basis/general/general.sml 22.17-22.20 *)
exn General.Subscript: exn (* @ $(SML_LIB)/basis/general/general.sml 23.17-23.25 *)
val General.before: 'a * unit -> 'a (* @ $(SML_LIB)/basis/general/general.sml 30.13-30.18 *)
val General.exnMessage: exn -> string (* @ $(SML_LIB)/basis/general/general.sml 40.18-40.27 *)
val General.exnName: exn -> string (* @ $(SML_LIB)/basis/general/general.sml 32.11-32.17 *)
val General.ignore: 'a -> unit (* @ $(SML_LIB)/basis/general/general.sml 31.11-31.16 *)
val General.o: ('a -> 'b) * ('c -> 'a) -> 'c -> 'b (* @ $(SML_LIB)/basis/general/general.sml 29.14-29.14 *)
structure GenericSock: GENERIC_SOCK (* @ $(SML_LIB)/basis/libs/basis-extra/top-level/basis.sml 64.17-64.27 *)
val GenericSock.socket: NetHostDB.addr_family * Socket.SOCK.sock_type -> ('a, 'b) Socket.sock (* @ $(SML_LIB)/basis/net/generic-sock.sml 33.11-33.16 *)
val GenericSock.socket': NetHostDB.addr_family * Socket.SOCK.sock_type * int -> ('a, 'b) Socket.sock (* @ $(SML_LIB)/basis/net/generic-sock.sml 14.11-14.17 *)
val GenericSock.socketPair: NetHostDB.addr_family * Socket.SOCK.sock_type -> ('a, 'b) Socket.sock * ('a, 'b) Socket.sock (* @ $(SML_LIB)/basis/net/generic-sock.sml 35.11-35.20 *)
val GenericSock.socketPair': NetHostDB.addr_family * Socket.SOCK.sock_type * int -> ('a, 'b) Socket.sock * ('a, 'b) Socket.sock (* @ $(SML_LIB)/basis/net/generic-sock.sml 20.11-20.21 *)
structure IEEEReal: IEEE_REAL where type float_class = IEEEReal.float_class where type real_order = IEEEReal.real_order where type rounding_mode = IEEEReal.rounding_mode (* @ $(SML_LIB)/basis/libs/basis-extra/top-level/basis.sml 25.17-25.24 *)
type IEEEReal.decimal_approx = {class: IEEEReal.float_class, digits: int list, exp: int, sign: bool} (* @ $(SML_LIB)/basis/real/IEEE-real.sml 105.12-105.25 *)
datatype IEEEReal.float_class = INF | NAN | NORMAL | SUBNORMAL | ZERO (* = datatype IEEEReal.float_class *) (* @ $(SML_LIB)/basis/real/IEEE-real.sml 21.16-21.26 *)
datatype IEEEReal.real_order = EQUAL | GREATER | LESS | UNORDERED (* = datatype IEEEReal.real_order *) (* @ $(SML_LIB)/basis/real/IEEE-real.sml 17.16-17.25 *)
datatype IEEEReal.rounding_mode = TO_NEAREST | TO_NEGINF | TO_POSINF | TO_ZERO (* = datatype IEEEReal.rounding_mode *) (* @ $(SML_LIB)/basis/real/IEEE-real.sml 67.16-67.28 *)
con IEEEReal.EQUAL: IEEEReal.real_order (* @ $(SML_LIB)/basis/real/IEEE-real.sml 17.36-17.40 *)
con IEEEReal.GREATER: IEEEReal.real_order (* @ $(SML_LIB)/basis/real/IEEE-real.sml 17.44-17.50 *)
con IEEEReal.INF: IEEEReal.float_class (* @ $(SML_LIB)/basis/real/IEEE-real.sml 22.10-22.12 *)
con IEEEReal.LESS: IEEEReal.real_order (* @ $(SML_LIB)/basis/real/IEEE-real.sml 17.29-17.32 *)
con IEEEReal.NAN: IEEEReal.float_class (* @ $(SML_LIB)/basis/real/IEEE-real.sml 23.10-23.12 *)
con IEEEReal.NORMAL: IEEEReal.float_class (* @ $(SML_LIB)/basis/real/IEEE-real.sml 24.10-24.15 *)
con IEEEReal.SUBNORMAL: IEEEReal.float_class (* @ $(SML_LIB)/basis/real/IEEE-real.sml 25.10-25.18 *)
con IEEEReal.TO_NEAREST: IEEEReal.rounding_mode (* @ $(SML_LIB)/basis/real/IEEE-real.sml 31.16-31.25 *)
con IEEEReal.TO_NEGINF: IEEEReal.rounding_mode (* @ $(SML_LIB)/basis/real/IEEE-real.sml 32.16-32.24 *)
con IEEEReal.TO_POSINF: IEEEReal.rounding_mode (* @ $(SML_LIB)/basis/real/IEEE-real.sml 33.16-33.24 *)
con IEEEReal.TO_ZERO: IEEEReal.rounding_mode (* @ $(SML_LIB)/basis/real/IEEE-real.sml 34.16-34.22 *)
con IEEEReal.UNORDERED: IEEEReal.real_order (* @ $(SML_LIB)/basis/real/IEEE-real.sml 17.54-17.62 *)
exn IEEEReal.Unordered: exn (* @ $(SML_LIB)/basis/real/IEEE-real.sml 16.17-16.25 *)
con IEEEReal.ZERO: IEEEReal.float_class (* @ $(SML_LIB)/basis/real/IEEE-real.sml 26.10-26.13 *)
val IEEEReal.fromString: string -> {class: IEEEReal.float_class, digits: int list, exp: int, sign: bool} option (* @ $(SML_LIB)/basis/real/IEEE-real.sml 354.11-354.20 *)
val IEEEReal.getRoundingMode: unit -> IEEEReal.rounding_mode (* @ $(SML_LIB)/basis/real/IEEE-real.sml 75.11-75.25 *)
val IEEEReal.scan: ('a -> (char * 'a) option) -> 'a -> ({class: IEEEReal.float_class, digits: int list, exp: int, sign: bool} * 'a) option (* @ $(SML_LIB)/basis/real/IEEE-real.sml 107.14-107.17 *)
val IEEEReal.setRoundingMode: IEEEReal.rounding_mode -> unit (* @ $(SML_LIB)/basis/real/IEEE-real.sml 69.11-69.25 *)
val IEEEReal.toString: {class: IEEEReal.float_class, digits: int list, exp: int, sign: bool} -> string (* @ $(SML_LIB)/basis/real/IEEE-real.sml 356.11-356.18 *)
structure INetSock: INET_SOCK where type inet = INetSock.inet (* @ $(SML_LIB)/basis/libs/basis-extra/top-level/basis.sml 65.17-65.24 *)
type INetSock.dgram_sock = (INetSock.inet, Socket.dgram) Socket.sock (* @ $(SML_LIB)/basis/net/inet-sock.sml 15.12-15.21 *)
type INetSock.inet = INetSock.inet (* @ $(SML_LIB)/basis/net/inet-sock.sml 12.16-12.19 *)
type 'a INetSock.sock = (INetSock.inet, 'a) Socket.sock (* @ $(SML_LIB)/basis/net/inet-sock.sml 13.23-13.26 *)
type INetSock.sock_addr = INetSock.inet Socket.sock_addr (* @ $(SML_LIB)/basis/net/inet-sock.sml 16.12-16.20 *)
type 'a INetSock.stream_sock = (INetSock.inet, 'a Socket.stream) Socket.sock (* @ $(SML_LIB)/basis/net/inet-sock.sml 14.18-14.28 *)
val INetSock.any: int -> INetSock.inet Socket.sock_addr (* @ $(SML_LIB)/basis/net/inet-sock.sml 33.11-33.13 *)
val INetSock.fromAddr: INetSock.inet Socket.sock_addr -> Word8.word vector * int (* @ $(SML_LIB)/basis/net/inet-sock.sml 35.11-35.18 *)
val INetSock.inetAF: NetHostDB.addr_family (* @ $(SML_LIB)/basis/net/inet-sock.sml 18.11-18.16 *)
val INetSock.toAddr: Word8.word vector * int -> INetSock.inet Socket.sock_addr (* @ $(SML_LIB)/basis/net/inet-sock.sml 20.11-20.16 *)
structure INetSock.TCP:
   sig
      val getNODELAY: (INetSock.inet, 'a Socket.stream) Socket.sock -> bool
      val setNODELAY: (INetSock.inet, 'a Socket.stream) Socket.sock * bool -> unit
      val socket: unit -> (INetSock.inet, 'a Socket.stream) Socket.sock
      val socket': int -> (INetSock.inet, 'a Socket.stream) Socket.sock
   end
   (* @ $(SML_LIB)/basis/net/inet-sock.sml 53.17-53.19 *)
val INetSock.TCP.getNODELAY: (INetSock.inet, 'a Socket.stream) Socket.sock -> bool (* @ $(SML_LIB)/basis/net/inet-sock.sml 60.17-60.26 *)
val INetSock.TCP.setNODELAY: (INetSock.inet, 'a Socket.stream) Socket.sock * bool -> unit (* @ $(SML_LIB)/basis/net/inet-sock.sml 64.17-64.26 *)
val INetSock.TCP.socket: unit -> (INetSock.inet, 'a Socket.stream) Socket.sock (* @ $(SML_LIB)/basis/net/inet-sock.sml 58.17-58.22 *)
val INetSock.TCP.socket': int -> (INetSock.inet, 'a Socket.stream) Socket.sock (* @ $(SML_LIB)/basis/net/inet-sock.sml 57.17-57.23 *)
structure INetSock.UDP:
   sig
      val socket: unit -> (INetSock.inet, Socket.dgram) Socket.sock
      val socket': int -> (INetSock.inet, Socket.dgram) Socket.sock
   end
   (* @ $(SML_LIB)/basis/net/inet-sock.sml 47.17-47.19 *)
val INetSock.UDP.socket: unit -> (INetSock.inet, Socket.dgram) Socket.sock (* @ $(SML_LIB)/basis/net/inet-sock.sml 50.17-50.22 *)
val INetSock.UDP.socket': int -> (INetSock.inet, Socket.dgram) Socket.sock (* @ $(SML_LIB)/basis/net/inet-sock.sml 49.17-49.23 *)
structure IO: IO where type buffer_mode = IO.buffer_mode (* @ $(SML_LIB)/basis/libs/basis-extra/top-level/basis.sml 26.17-26.18 *)
datatype IO.buffer_mode = BLOCK_BUF | LINE_BUF | NO_BUF (* = datatype IO.buffer_mode *) (* @ $(SML_LIB)/basis/io/io.sml 32.16-32.26 *)
con IO.BLOCK_BUF: IO.buffer_mode (* @ $(SML_LIB)/basis/io/io.sml 32.50-32.58 *)
exn IO.BlockingNotSupported: exn (* @ $(SML_LIB)/basis/io/io.sml 11.17-11.36 *)
exn IO.ClosedStream: exn (* @ $(SML_LIB)/basis/io/io.sml 13.17-13.28 *)
exn IO.Io: {cause: exn, function: string, name: string} -> exn (* @ $(SML_LIB)/basis/io/io.sml 15.17-15.18 *)
con IO.LINE_BUF: IO.buffer_mode (* @ $(SML_LIB)/basis/io/io.sml 32.39-32.46 *)
con IO.NO_BUF: IO.buffer_mode (* @ $(SML_LIB)/basis/io/io.sml 32.30-32.35 *)
exn IO.NonblockingNotSupported: exn (* @ $(SML_LIB)/basis/io/io.sml 28.17-28.39 *)
exn IO.RandomAccessNotSupported: exn (* @ $(SML_LIB)/basis/io/io.sml 30.17-30.40 *)
structure Int: INTEGER where type int = int (* @ $(SML_LIB)/basis/libs/basis-2002/top-level/top-level.sml 82.11-82.13 *)
type Int.int = int (* @ $(SML_LIB)/basis/primitive/prim-basis.sml 228.12-228.14 *)
val Int.* : int * int -> int (* @ $(SML_LIB)/basis/primitive/prim-int.sml 391.11-391.11 *)
val Int.+ : int * int -> int (* @ $(SML_LIB)/basis/primitive/prim-int.sml 385.11-385.11 *)
val Int.- : int * int -> int (* @ $(SML_LIB)/basis/primitive/prim-int.sml 404.11-404.11 *)
val Int.< : int * int -> bool (* @ $(SML_LIB)/basis/util/integral-comparisons.sml 11.11-11.11 *)
val Int.<= : int * int -> bool (* @ $(SML_LIB)/basis/util/integral-comparisons.sml 12.11-12.12 *)
val Int.> : int * int -> bool (* @ $(SML_LIB)/basis/util/integral-comparisons.sml 13.11-13.11 *)
val Int.>= : int * int -> bool (* @ $(SML_LIB)/basis/util/integral-comparisons.sml 14.11-14.12 *)
val Int.abs: int -> int (* @ $(SML_LIB)/basis/integer/num0.sml 161.17-161.19 *)
val Int.compare: int * int -> order (* @ $(SML_LIB)/basis/util/integral-comparisons.sml 16.11-16.17 *)
val Int.div: int * int -> int (* @ $(SML_LIB)/basis/integer/num0.sml 183.19-183.21 *)
val Int.fmt: StringCvt.radix -> int -> string (* @ $(SML_LIB)/basis/integer/int.sml 74.8-74.10 *)
val Int.fromInt: int -> int (* @ $(SML_LIB)/basis/integer/int.sml 46.5-46.11 *)
val Int.fromLarge: LargeInt.int -> int (* @ $(SML_LIB)/basis/integer/int.sml 51.5-51.13 *)
val Int.fromString: string -> int option (* @ $(SML_LIB)/basis/integer/int.sml 165.5-165.14 *)
val Int.max: int * int -> int (* @ $(SML_LIB)/basis/util/integral-comparisons.sml 21.11-21.13 *)
val Int.maxInt: int option (* @ $(SML_LIB)/basis/integer/int.sml 19.5-19.10 *)
val Int.min: int * int -> int (* @ $(SML_LIB)/basis/util/integral-comparisons.sml 20.11-20.13 *)
val Int.minInt: int option (* @ $(SML_LIB)/basis/integer/int.sml 20.5-20.10 *)
val Int.mod: int * int -> int (* @ $(SML_LIB)/basis/integer/num0.sml 204.19-204.21 *)
val Int.precision: int option (* @ $(SML_LIB)/basis/integer/int.sml 16.5-16.13 *)
val Int.quot: int * int -> int (* @ $(SML_LIB)/basis/integer/num0.sml 163.17-163.20 *)
val Int.rem: int * int -> int (* @ $(SML_LIB)/basis/integer/num0.sml 175.17-175.19 *)
val Int.sameSign: int * int -> bool (* @ $(SML_LIB)/basis/integer/int.sml 29.5-29.12 *)
val Int.scan: StringCvt.radix -> ('a -> (char * 'a) option) -> 'a -> (int * 'a) option (* @ $(SML_LIB)/basis/integer/int.sml 112.5-112.8 *)
val Int.sign: int -> int (* @ $(SML_LIB)/basis/integer/int.sml 22.5-22.8 *)
val Int.toInt: int -> int (* @ $(SML_LIB)/basis/integer/int.sml 47.5-47.9 *)
val Int.toLarge: int -> LargeInt.int (* @ $(SML_LIB)/basis/integer/int.sml 52.5-52.11 *)
val Int.toString: int -> string (* @ $(SML_LIB)/basis/integer/int.sml 110.5-110.12 *)
val Int.~ : int -> int (* @ $(SML_LIB)/basis/primitive/prim-int.sml 397.11-397.11 *)
structure Int1: INTEGER where type int = Int1.int (* @ $(SML_LIB)/basis/libs/basis-extra/top-level/basis.sml 66.17-66.20 *)
type Int1.int = Int1.int (* @ $(SML_LIB)/basis/primitive/prim-basis.sml 73.12-73.14 *)
val Int1.* : Int1.int * Int1.int -> Int1.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 64.17-64.17 *)
val Int1.+ : Int1.int * Int1.int -> Int1.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 65.17-65.17 *)
val Int1.- : Int1.int * Int1.int -> Int1.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 66.17-66.17 *)
val Int1.< : Int1.int * Int1.int -> bool (* @ $(SML_LIB)/basis/integer/embed-int.sml 77.17-77.17 *)
val Int1.<= : Int1.int * Int1.int -> bool (* @ $(SML_LIB)/basis/integer/embed-int.sml 78.17-78.18 *)
val Int1.> : Int1.int * Int1.int -> bool (* @ $(SML_LIB)/basis/integer/embed-int.sml 79.17-79.17 *)
val Int1.>= : Int1.int * Int1.int -> bool (* @ $(SML_LIB)/basis/integer/embed-int.sml 80.17-80.18 *)
val Int1.abs: Int1.int -> Int1.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 93.14-93.16 *)
val Int1.compare: Int1.int * Int1.int -> order (* @ $(SML_LIB)/basis/integer/embed-int.sml 81.14-81.20 *)
val Int1.div: Int1.int * Int1.int -> Int1.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 67.17-67.19 *)
val Int1.fmt: StringCvt.radix -> Int1.int -> string (* @ $(SML_LIB)/basis/integer/embed-int.sml 96.11-96.13 *)
val Int1.fromInt: int -> Int1.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 84.11-84.17 *)
val Int1.fromLarge: LargeInt.int -> Int1.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 98.11-98.19 *)
val Int1.fromString: string -> Int1.int option (* @ $(SML_LIB)/basis/integer/embed-int.sml 100.11-100.20 *)
val Int1.max: Int1.int * Int1.int -> Int1.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 102.11-102.13 *)
val Int1.maxInt: Int1.int option (* @ $(SML_LIB)/basis/integer/embed-int.sml 56.11-56.16 *)
val Int1.min: Int1.int * Int1.int -> Int1.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 104.11-104.13 *)
val Int1.minInt: Int1.int option (* @ $(SML_LIB)/basis/integer/embed-int.sml 58.11-58.16 *)
val Int1.mod: Int1.int * Int1.int -> Int1.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 68.17-68.19 *)
val Int1.precision: int option (* @ $(SML_LIB)/basis/integer/embed-int.sml 39.11-39.19 *)
val Int1.quot: Int1.int * Int1.int -> Int1.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 69.14-69.17 *)
val Int1.rem: Int1.int * Int1.int -> Int1.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 70.14-70.16 *)
val Int1.sameSign: Int1.int * Int1.int -> bool (* @ $(SML_LIB)/basis/integer/embed-int.sml 113.11-113.18 *)
val Int1.scan: StringCvt.radix -> ('a -> (char * 'a) option) -> 'a -> (Int1.int * 'a) option (* @ $(SML_LIB)/basis/integer/embed-int.sml 106.11-106.14 *)
val Int1.sign: Int1.int -> int (* @ $(SML_LIB)/basis/integer/embed-int.sml 111.11-111.14 *)
val Int1.toInt: Int1.int -> int (* @ $(SML_LIB)/basis/integer/embed-int.sml 86.11-86.15 *)
val Int1.toLarge: Int1.int -> LargeInt.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 115.11-115.17 *)
val Int1.toString: Int1.int -> string (* @ $(SML_LIB)/basis/integer/embed-int.sml 117.11-117.18 *)
val Int1.~ : Int1.int -> Int1.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 92.14-92.14 *)
structure Int10: INTEGER where type int = Int10.int (* @ $(SML_LIB)/basis/libs/basis-extra/top-level/basis.sml 75.17-75.21 *)
type Int10.int = Int10.int (* @ $(SML_LIB)/basis/primitive/prim-basis.sml 118.12-118.14 *)
val Int10.* : Int10.int * Int10.int -> Int10.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 64.17-64.17 *)
val Int10.+ : Int10.int * Int10.int -> Int10.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 65.17-65.17 *)
val Int10.- : Int10.int * Int10.int -> Int10.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 66.17-66.17 *)
val Int10.< : Int10.int * Int10.int -> bool (* @ $(SML_LIB)/basis/integer/embed-int.sml 77.17-77.17 *)
val Int10.<= : Int10.int * Int10.int -> bool (* @ $(SML_LIB)/basis/integer/embed-int.sml 78.17-78.18 *)
val Int10.> : Int10.int * Int10.int -> bool (* @ $(SML_LIB)/basis/integer/embed-int.sml 79.17-79.17 *)
val Int10.>= : Int10.int * Int10.int -> bool (* @ $(SML_LIB)/basis/integer/embed-int.sml 80.17-80.18 *)
val Int10.abs: Int10.int -> Int10.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 93.14-93.16 *)
val Int10.compare: Int10.int * Int10.int -> order (* @ $(SML_LIB)/basis/integer/embed-int.sml 81.14-81.20 *)
val Int10.div: Int10.int * Int10.int -> Int10.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 67.17-67.19 *)
val Int10.fmt: StringCvt.radix -> Int10.int -> string (* @ $(SML_LIB)/basis/integer/embed-int.sml 96.11-96.13 *)
val Int10.fromInt: int -> Int10.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 84.11-84.17 *)
val Int10.fromLarge: LargeInt.int -> Int10.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 98.11-98.19 *)
val Int10.fromString: string -> Int10.int option (* @ $(SML_LIB)/basis/integer/embed-int.sml 100.11-100.20 *)
val Int10.max: Int10.int * Int10.int -> Int10.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 102.11-102.13 *)
val Int10.maxInt: Int10.int option (* @ $(SML_LIB)/basis/integer/embed-int.sml 56.11-56.16 *)
val Int10.min: Int10.int * Int10.int -> Int10.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 104.11-104.13 *)
val Int10.minInt: Int10.int option (* @ $(SML_LIB)/basis/integer/embed-int.sml 58.11-58.16 *)
val Int10.mod: Int10.int * Int10.int -> Int10.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 68.17-68.19 *)
val Int10.precision: int option (* @ $(SML_LIB)/basis/integer/embed-int.sml 39.11-39.19 *)
val Int10.quot: Int10.int * Int10.int -> Int10.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 69.14-69.17 *)
val Int10.rem: Int10.int * Int10.int -> Int10.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 70.14-70.16 *)
val Int10.sameSign: Int10.int * Int10.int -> bool (* @ $(SML_LIB)/basis/integer/embed-int.sml 113.11-113.18 *)
val Int10.scan: StringCvt.radix -> ('a -> (char * 'a) option) -> 'a -> (Int10.int * 'a) option (* @ $(SML_LIB)/basis/integer/embed-int.sml 106.11-106.14 *)
val Int10.sign: Int10.int -> int (* @ $(SML_LIB)/basis/integer/embed-int.sml 111.11-111.14 *)
val Int10.toInt: Int10.int -> int (* @ $(SML_LIB)/basis/integer/embed-int.sml 86.11-86.15 *)
val Int10.toLarge: Int10.int -> LargeInt.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 115.11-115.17 *)
val Int10.toString: Int10.int -> string (* @ $(SML_LIB)/basis/integer/embed-int.sml 117.11-117.18 *)
val Int10.~ : Int10.int -> Int10.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 92.14-92.14 *)
structure Int11: INTEGER where type int = Int11.int (* @ $(SML_LIB)/basis/libs/basis-extra/top-level/basis.sml 76.17-76.21 *)
type Int11.int = Int11.int (* @ $(SML_LIB)/basis/primitive/prim-basis.sml 123.12-123.14 *)
val Int11.* : Int11.int * Int11.int -> Int11.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 64.17-64.17 *)
val Int11.+ : Int11.int * Int11.int -> Int11.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 65.17-65.17 *)
val Int11.- : Int11.int * Int11.int -> Int11.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 66.17-66.17 *)
val Int11.< : Int11.int * Int11.int -> bool (* @ $(SML_LIB)/basis/integer/embed-int.sml 77.17-77.17 *)
val Int11.<= : Int11.int * Int11.int -> bool (* @ $(SML_LIB)/basis/integer/embed-int.sml 78.17-78.18 *)
val Int11.> : Int11.int * Int11.int -> bool (* @ $(SML_LIB)/basis/integer/embed-int.sml 79.17-79.17 *)
val Int11.>= : Int11.int * Int11.int -> bool (* @ $(SML_LIB)/basis/integer/embed-int.sml 80.17-80.18 *)
val Int11.abs: Int11.int -> Int11.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 93.14-93.16 *)
val Int11.compare: Int11.int * Int11.int -> order (* @ $(SML_LIB)/basis/integer/embed-int.sml 81.14-81.20 *)
val Int11.div: Int11.int * Int11.int -> Int11.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 67.17-67.19 *)
val Int11.fmt: StringCvt.radix -> Int11.int -> string (* @ $(SML_LIB)/basis/integer/embed-int.sml 96.11-96.13 *)
val Int11.fromInt: int -> Int11.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 84.11-84.17 *)
val Int11.fromLarge: LargeInt.int -> Int11.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 98.11-98.19 *)
val Int11.fromString: string -> Int11.int option (* @ $(SML_LIB)/basis/integer/embed-int.sml 100.11-100.20 *)
val Int11.max: Int11.int * Int11.int -> Int11.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 102.11-102.13 *)
val Int11.maxInt: Int11.int option (* @ $(SML_LIB)/basis/integer/embed-int.sml 56.11-56.16 *)
val Int11.min: Int11.int * Int11.int -> Int11.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 104.11-104.13 *)
val Int11.minInt: Int11.int option (* @ $(SML_LIB)/basis/integer/embed-int.sml 58.11-58.16 *)
val Int11.mod: Int11.int * Int11.int -> Int11.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 68.17-68.19 *)
val Int11.precision: int option (* @ $(SML_LIB)/basis/integer/embed-int.sml 39.11-39.19 *)
val Int11.quot: Int11.int * Int11.int -> Int11.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 69.14-69.17 *)
val Int11.rem: Int11.int * Int11.int -> Int11.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 70.14-70.16 *)
val Int11.sameSign: Int11.int * Int11.int -> bool (* @ $(SML_LIB)/basis/integer/embed-int.sml 113.11-113.18 *)
val Int11.scan: StringCvt.radix -> ('a -> (char * 'a) option) -> 'a -> (Int11.int * 'a) option (* @ $(SML_LIB)/basis/integer/embed-int.sml 106.11-106.14 *)
val Int11.sign: Int11.int -> int (* @ $(SML_LIB)/basis/integer/embed-int.sml 111.11-111.14 *)
val Int11.toInt: Int11.int -> int (* @ $(SML_LIB)/basis/integer/embed-int.sml 86.11-86.15 *)
val Int11.toLarge: Int11.int -> LargeInt.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 115.11-115.17 *)
val Int11.toString: Int11.int -> string (* @ $(SML_LIB)/basis/integer/embed-int.sml 117.11-117.18 *)
val Int11.~ : Int11.int -> Int11.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 92.14-92.14 *)
structure Int12: INTEGER where type int = Int12.int (* @ $(SML_LIB)/basis/libs/basis-extra/top-level/basis.sml 77.17-77.21 *)
type Int12.int = Int12.int (* @ $(SML_LIB)/basis/primitive/prim-basis.sml 128.12-128.14 *)
val Int12.* : Int12.int * Int12.int -> Int12.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 64.17-64.17 *)
val Int12.+ : Int12.int * Int12.int -> Int12.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 65.17-65.17 *)
val Int12.- : Int12.int * Int12.int -> Int12.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 66.17-66.17 *)
val Int12.< : Int12.int * Int12.int -> bool (* @ $(SML_LIB)/basis/integer/embed-int.sml 77.17-77.17 *)
val Int12.<= : Int12.int * Int12.int -> bool (* @ $(SML_LIB)/basis/integer/embed-int.sml 78.17-78.18 *)
val Int12.> : Int12.int * Int12.int -> bool (* @ $(SML_LIB)/basis/integer/embed-int.sml 79.17-79.17 *)
val Int12.>= : Int12.int * Int12.int -> bool (* @ $(SML_LIB)/basis/integer/embed-int.sml 80.17-80.18 *)
val Int12.abs: Int12.int -> Int12.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 93.14-93.16 *)
val Int12.compare: Int12.int * Int12.int -> order (* @ $(SML_LIB)/basis/integer/embed-int.sml 81.14-81.20 *)
val Int12.div: Int12.int * Int12.int -> Int12.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 67.17-67.19 *)
val Int12.fmt: StringCvt.radix -> Int12.int -> string (* @ $(SML_LIB)/basis/integer/embed-int.sml 96.11-96.13 *)
val Int12.fromInt: int -> Int12.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 84.11-84.17 *)
val Int12.fromLarge: LargeInt.int -> Int12.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 98.11-98.19 *)
val Int12.fromString: string -> Int12.int option (* @ $(SML_LIB)/basis/integer/embed-int.sml 100.11-100.20 *)
val Int12.max: Int12.int * Int12.int -> Int12.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 102.11-102.13 *)
val Int12.maxInt: Int12.int option (* @ $(SML_LIB)/basis/integer/embed-int.sml 56.11-56.16 *)
val Int12.min: Int12.int * Int12.int -> Int12.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 104.11-104.13 *)
val Int12.minInt: Int12.int option (* @ $(SML_LIB)/basis/integer/embed-int.sml 58.11-58.16 *)
val Int12.mod: Int12.int * Int12.int -> Int12.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 68.17-68.19 *)
val Int12.precision: int option (* @ $(SML_LIB)/basis/integer/embed-int.sml 39.11-39.19 *)
val Int12.quot: Int12.int * Int12.int -> Int12.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 69.14-69.17 *)
val Int12.rem: Int12.int * Int12.int -> Int12.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 70.14-70.16 *)
val Int12.sameSign: Int12.int * Int12.int -> bool (* @ $(SML_LIB)/basis/integer/embed-int.sml 113.11-113.18 *)
val Int12.scan: StringCvt.radix -> ('a -> (char * 'a) option) -> 'a -> (Int12.int * 'a) option (* @ $(SML_LIB)/basis/integer/embed-int.sml 106.11-106.14 *)
val Int12.sign: Int12.int -> int (* @ $(SML_LIB)/basis/integer/embed-int.sml 111.11-111.14 *)
val Int12.toInt: Int12.int -> int (* @ $(SML_LIB)/basis/integer/embed-int.sml 86.11-86.15 *)
val Int12.toLarge: Int12.int -> LargeInt.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 115.11-115.17 *)
val Int12.toString: Int12.int -> string (* @ $(SML_LIB)/basis/integer/embed-int.sml 117.11-117.18 *)
val Int12.~ : Int12.int -> Int12.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 92.14-92.14 *)
structure Int13: INTEGER where type int = Int13.int (* @ $(SML_LIB)/basis/libs/basis-extra/top-level/basis.sml 78.17-78.21 *)
type Int13.int = Int13.int (* @ $(SML_LIB)/basis/primitive/prim-basis.sml 133.12-133.14 *)
val Int13.* : Int13.int * Int13.int -> Int13.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 64.17-64.17 *)
val Int13.+ : Int13.int * Int13.int -> Int13.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 65.17-65.17 *)
val Int13.- : Int13.int * Int13.int -> Int13.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 66.17-66.17 *)
val Int13.< : Int13.int * Int13.int -> bool (* @ $(SML_LIB)/basis/integer/embed-int.sml 77.17-77.17 *)
val Int13.<= : Int13.int * Int13.int -> bool (* @ $(SML_LIB)/basis/integer/embed-int.sml 78.17-78.18 *)
val Int13.> : Int13.int * Int13.int -> bool (* @ $(SML_LIB)/basis/integer/embed-int.sml 79.17-79.17 *)
val Int13.>= : Int13.int * Int13.int -> bool (* @ $(SML_LIB)/basis/integer/embed-int.sml 80.17-80.18 *)
val Int13.abs: Int13.int -> Int13.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 93.14-93.16 *)
val Int13.compare: Int13.int * Int13.int -> order (* @ $(SML_LIB)/basis/integer/embed-int.sml 81.14-81.20 *)
val Int13.div: Int13.int * Int13.int -> Int13.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 67.17-67.19 *)
val Int13.fmt: StringCvt.radix -> Int13.int -> string (* @ $(SML_LIB)/basis/integer/embed-int.sml 96.11-96.13 *)
val Int13.fromInt: int -> Int13.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 84.11-84.17 *)
val Int13.fromLarge: LargeInt.int -> Int13.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 98.11-98.19 *)
val Int13.fromString: string -> Int13.int option (* @ $(SML_LIB)/basis/integer/embed-int.sml 100.11-100.20 *)
val Int13.max: Int13.int * Int13.int -> Int13.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 102.11-102.13 *)
val Int13.maxInt: Int13.int option (* @ $(SML_LIB)/basis/integer/embed-int.sml 56.11-56.16 *)
val Int13.min: Int13.int * Int13.int -> Int13.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 104.11-104.13 *)
val Int13.minInt: Int13.int option (* @ $(SML_LIB)/basis/integer/embed-int.sml 58.11-58.16 *)
val Int13.mod: Int13.int * Int13.int -> Int13.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 68.17-68.19 *)
val Int13.precision: int option (* @ $(SML_LIB)/basis/integer/embed-int.sml 39.11-39.19 *)
val Int13.quot: Int13.int * Int13.int -> Int13.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 69.14-69.17 *)
val Int13.rem: Int13.int * Int13.int -> Int13.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 70.14-70.16 *)
val Int13.sameSign: Int13.int * Int13.int -> bool (* @ $(SML_LIB)/basis/integer/embed-int.sml 113.11-113.18 *)
val Int13.scan: StringCvt.radix -> ('a -> (char * 'a) option) -> 'a -> (Int13.int * 'a) option (* @ $(SML_LIB)/basis/integer/embed-int.sml 106.11-106.14 *)
val Int13.sign: Int13.int -> int (* @ $(SML_LIB)/basis/integer/embed-int.sml 111.11-111.14 *)
val Int13.toInt: Int13.int -> int (* @ $(SML_LIB)/basis/integer/embed-int.sml 86.11-86.15 *)
val Int13.toLarge: Int13.int -> LargeInt.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 115.11-115.17 *)
val Int13.toString: Int13.int -> string (* @ $(SML_LIB)/basis/integer/embed-int.sml 117.11-117.18 *)
val Int13.~ : Int13.int -> Int13.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 92.14-92.14 *)
structure Int14: INTEGER where type int = Int14.int (* @ $(SML_LIB)/basis/libs/basis-extra/top-level/basis.sml 79.17-79.21 *)
type Int14.int = Int14.int (* @ $(SML_LIB)/basis/primitive/prim-basis.sml 138.12-138.14 *)
val Int14.* : Int14.int * Int14.int -> Int14.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 64.17-64.17 *)
val Int14.+ : Int14.int * Int14.int -> Int14.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 65.17-65.17 *)
val Int14.- : Int14.int * Int14.int -> Int14.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 66.17-66.17 *)
val Int14.< : Int14.int * Int14.int -> bool (* @ $(SML_LIB)/basis/integer/embed-int.sml 77.17-77.17 *)
val Int14.<= : Int14.int * Int14.int -> bool (* @ $(SML_LIB)/basis/integer/embed-int.sml 78.17-78.18 *)
val Int14.> : Int14.int * Int14.int -> bool (* @ $(SML_LIB)/basis/integer/embed-int.sml 79.17-79.17 *)
val Int14.>= : Int14.int * Int14.int -> bool (* @ $(SML_LIB)/basis/integer/embed-int.sml 80.17-80.18 *)
val Int14.abs: Int14.int -> Int14.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 93.14-93.16 *)
val Int14.compare: Int14.int * Int14.int -> order (* @ $(SML_LIB)/basis/integer/embed-int.sml 81.14-81.20 *)
val Int14.div: Int14.int * Int14.int -> Int14.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 67.17-67.19 *)
val Int14.fmt: StringCvt.radix -> Int14.int -> string (* @ $(SML_LIB)/basis/integer/embed-int.sml 96.11-96.13 *)
val Int14.fromInt: int -> Int14.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 84.11-84.17 *)
val Int14.fromLarge: LargeInt.int -> Int14.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 98.11-98.19 *)
val Int14.fromString: string -> Int14.int option (* @ $(SML_LIB)/basis/integer/embed-int.sml 100.11-100.20 *)
val Int14.max: Int14.int * Int14.int -> Int14.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 102.11-102.13 *)
val Int14.maxInt: Int14.int option (* @ $(SML_LIB)/basis/integer/embed-int.sml 56.11-56.16 *)
val Int14.min: Int14.int * Int14.int -> Int14.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 104.11-104.13 *)
val Int14.minInt: Int14.int option (* @ $(SML_LIB)/basis/integer/embed-int.sml 58.11-58.16 *)
val Int14.mod: Int14.int * Int14.int -> Int14.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 68.17-68.19 *)
val Int14.precision: int option (* @ $(SML_LIB)/basis/integer/embed-int.sml 39.11-39.19 *)
val Int14.quot: Int14.int * Int14.int -> Int14.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 69.14-69.17 *)
val Int14.rem: Int14.int * Int14.int -> Int14.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 70.14-70.16 *)
val Int14.sameSign: Int14.int * Int14.int -> bool (* @ $(SML_LIB)/basis/integer/embed-int.sml 113.11-113.18 *)
val Int14.scan: StringCvt.radix -> ('a -> (char * 'a) option) -> 'a -> (Int14.int * 'a) option (* @ $(SML_LIB)/basis/integer/embed-int.sml 106.11-106.14 *)
val Int14.sign: Int14.int -> int (* @ $(SML_LIB)/basis/integer/embed-int.sml 111.11-111.14 *)
val Int14.toInt: Int14.int -> int (* @ $(SML_LIB)/basis/integer/embed-int.sml 86.11-86.15 *)
val Int14.toLarge: Int14.int -> LargeInt.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 115.11-115.17 *)
val Int14.toString: Int14.int -> string (* @ $(SML_LIB)/basis/integer/embed-int.sml 117.11-117.18 *)
val Int14.~ : Int14.int -> Int14.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 92.14-92.14 *)
structure Int15: INTEGER where type int = Int15.int (* @ $(SML_LIB)/basis/libs/basis-extra/top-level/basis.sml 80.17-80.21 *)
type Int15.int = Int15.int (* @ $(SML_LIB)/basis/primitive/prim-basis.sml 143.12-143.14 *)
val Int15.* : Int15.int * Int15.int -> Int15.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 64.17-64.17 *)
val Int15.+ : Int15.int * Int15.int -> Int15.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 65.17-65.17 *)
val Int15.- : Int15.int * Int15.int -> Int15.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 66.17-66.17 *)
val Int15.< : Int15.int * Int15.int -> bool (* @ $(SML_LIB)/basis/integer/embed-int.sml 77.17-77.17 *)
val Int15.<= : Int15.int * Int15.int -> bool (* @ $(SML_LIB)/basis/integer/embed-int.sml 78.17-78.18 *)
val Int15.> : Int15.int * Int15.int -> bool (* @ $(SML_LIB)/basis/integer/embed-int.sml 79.17-79.17 *)
val Int15.>= : Int15.int * Int15.int -> bool (* @ $(SML_LIB)/basis/integer/embed-int.sml 80.17-80.18 *)
val Int15.abs: Int15.int -> Int15.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 93.14-93.16 *)
val Int15.compare: Int15.int * Int15.int -> order (* @ $(SML_LIB)/basis/integer/embed-int.sml 81.14-81.20 *)
val Int15.div: Int15.int * Int15.int -> Int15.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 67.17-67.19 *)
val Int15.fmt: StringCvt.radix -> Int15.int -> string (* @ $(SML_LIB)/basis/integer/embed-int.sml 96.11-96.13 *)
val Int15.fromInt: int -> Int15.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 84.11-84.17 *)
val Int15.fromLarge: LargeInt.int -> Int15.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 98.11-98.19 *)
val Int15.fromString: string -> Int15.int option (* @ $(SML_LIB)/basis/integer/embed-int.sml 100.11-100.20 *)
val Int15.max: Int15.int * Int15.int -> Int15.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 102.11-102.13 *)
val Int15.maxInt: Int15.int option (* @ $(SML_LIB)/basis/integer/embed-int.sml 56.11-56.16 *)
val Int15.min: Int15.int * Int15.int -> Int15.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 104.11-104.13 *)
val Int15.minInt: Int15.int option (* @ $(SML_LIB)/basis/integer/embed-int.sml 58.11-58.16 *)
val Int15.mod: Int15.int * Int15.int -> Int15.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 68.17-68.19 *)
val Int15.precision: int option (* @ $(SML_LIB)/basis/integer/embed-int.sml 39.11-39.19 *)
val Int15.quot: Int15.int * Int15.int -> Int15.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 69.14-69.17 *)
val Int15.rem: Int15.int * Int15.int -> Int15.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 70.14-70.16 *)
val Int15.sameSign: Int15.int * Int15.int -> bool (* @ $(SML_LIB)/basis/integer/embed-int.sml 113.11-113.18 *)
val Int15.scan: StringCvt.radix -> ('a -> (char * 'a) option) -> 'a -> (Int15.int * 'a) option (* @ $(SML_LIB)/basis/integer/embed-int.sml 106.11-106.14 *)
val Int15.sign: Int15.int -> int (* @ $(SML_LIB)/basis/integer/embed-int.sml 111.11-111.14 *)
val Int15.toInt: Int15.int -> int (* @ $(SML_LIB)/basis/integer/embed-int.sml 86.11-86.15 *)
val Int15.toLarge: Int15.int -> LargeInt.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 115.11-115.17 *)
val Int15.toString: Int15.int -> string (* @ $(SML_LIB)/basis/integer/embed-int.sml 117.11-117.18 *)
val Int15.~ : Int15.int -> Int15.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 92.14-92.14 *)
structure Int16: INTEGER where type int = Int16.int (* @ $(SML_LIB)/basis/libs/basis-2002/top-level/top-level.sml 77.11-77.15 *)
type Int16.int = Int16.int (* @ $(SML_LIB)/basis/primitive/prim-basis.sml 148.12-148.14 *)
val Int16.* : Int16.int * Int16.int -> Int16.int (* @ $(SML_LIB)/basis/primitive/prim-int.sml 224.11-224.11 *)
val Int16.+ : Int16.int * Int16.int -> Int16.int (* @ $(SML_LIB)/basis/primitive/prim-int.sml 218.11-218.11 *)
val Int16.- : Int16.int * Int16.int -> Int16.int (* @ $(SML_LIB)/basis/primitive/prim-int.sml 237.11-237.11 *)
val Int16.< : Int16.int * Int16.int -> bool (* @ $(SML_LIB)/basis/util/integral-comparisons.sml 11.11-11.11 *)
val Int16.<= : Int16.int * Int16.int -> bool (* @ $(SML_LIB)/basis/util/integral-comparisons.sml 12.11-12.12 *)
val Int16.> : Int16.int * Int16.int -> bool (* @ $(SML_LIB)/basis/util/integral-comparisons.sml 13.11-13.11 *)
val Int16.>= : Int16.int * Int16.int -> bool (* @ $(SML_LIB)/basis/util/integral-comparisons.sml 14.11-14.12 *)
val Int16.abs: Int16.int -> Int16.int (* @ $(SML_LIB)/basis/integer/num0.sml 161.17-161.19 *)
val Int16.compare: Int16.int * Int16.int -> order (* @ $(SML_LIB)/basis/util/integral-comparisons.sml 16.11-16.17 *)
val Int16.div: Int16.int * Int16.int -> Int16.int (* @ $(SML_LIB)/basis/integer/num0.sml 183.19-183.21 *)
val Int16.fmt: StringCvt.radix -> Int16.int -> string (* @ $(SML_LIB)/basis/integer/int.sml 74.8-74.10 *)
val Int16.fromInt: int -> Int16.int (* @ $(SML_LIB)/basis/integer/int.sml 46.5-46.11 *)
val Int16.fromLarge: LargeInt.int -> Int16.int (* @ $(SML_LIB)/basis/integer/int.sml 51.5-51.13 *)
val Int16.fromString: string -> Int16.int option (* @ $(SML_LIB)/basis/integer/int.sml 165.5-165.14 *)
val Int16.max: Int16.int * Int16.int -> Int16.int (* @ $(SML_LIB)/basis/util/integral-comparisons.sml 21.11-21.13 *)
val Int16.maxInt: Int16.int option (* @ $(SML_LIB)/basis/integer/int.sml 19.5-19.10 *)
val Int16.min: Int16.int * Int16.int -> Int16.int (* @ $(SML_LIB)/basis/util/integral-comparisons.sml 20.11-20.13 *)
val Int16.minInt: Int16.int option (* @ $(SML_LIB)/basis/integer/int.sml 20.5-20.10 *)
val Int16.mod: Int16.int * Int16.int -> Int16.int (* @ $(SML_LIB)/basis/integer/num0.sml 204.19-204.21 *)
val Int16.precision: int option (* @ $(SML_LIB)/basis/integer/int.sml 16.5-16.13 *)
val Int16.quot: Int16.int * Int16.int -> Int16.int (* @ $(SML_LIB)/basis/integer/num0.sml 163.17-163.20 *)
val Int16.rem: Int16.int * Int16.int -> Int16.int (* @ $(SML_LIB)/basis/integer/num0.sml 175.17-175.19 *)
val Int16.sameSign: Int16.int * Int16.int -> bool (* @ $(SML_LIB)/basis/integer/int.sml 29.5-29.12 *)
val Int16.scan: StringCvt.radix -> ('a -> (char * 'a) option) -> 'a -> (Int16.int * 'a) option (* @ $(SML_LIB)/basis/integer/int.sml 112.5-112.8 *)
val Int16.sign: Int16.int -> int (* @ $(SML_LIB)/basis/integer/int.sml 22.5-22.8 *)
val Int16.toInt: Int16.int -> int (* @ $(SML_LIB)/basis/integer/int.sml 47.5-47.9 *)
val Int16.toLarge: Int16.int -> LargeInt.int (* @ $(SML_LIB)/basis/integer/int.sml 52.5-52.11 *)
val Int16.toString: Int16.int -> string (* @ $(SML_LIB)/basis/integer/int.sml 110.5-110.12 *)
val Int16.~ : Int16.int -> Int16.int (* @ $(SML_LIB)/basis/primitive/prim-int.sml 230.11-230.11 *)
structure Int16Array: MONO_ARRAY where type array = Int16Array.array where type elem = Int16.int where type vector = Int16Vector.vector (* @ $(SML_LIB)/basis/libs/basis-2002/top-level/top-level.sml 28.11-28.20 *)
type Int16Array.array = Int16Array.array (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array.fun 23.12-23.16 *)
type Int16Array.elem = Int16.int (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array.fun 22.12-22.15 *)
type Int16Array.vector = Int16Vector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array.fun 24.12-24.17 *)
val Int16Array.all: (Int16.int -> bool) -> Int16Array.array -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 476.13-476.15 *)
val Int16Array.app: (Int16.int -> unit) -> Int16Array.array -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 464.13-464.15 *)
val Int16Array.appi: (int * Int16.int -> unit) -> Int16Array.array -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 463.13-463.16 *)
val Int16Array.array: int * Int16.int -> Int16Array.array (* @ $(SML_LIB)/basis/arrays-and-vectors/array.sml 34.11-34.15 *)
val Int16Array.collate: (Int16.int * Int16.int -> order) -> Int16Array.array * Int16Array.array -> order (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 477.13-477.19 *)
val Int16Array.copy: {di: int, dst: Int16Array.array, src: Int16Array.array} -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 457.13-457.16 *)
val Int16Array.copyVec: {di: int, dst: Int16Array.array, src: Int16Vector.vector} -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array.sml 37.11-37.17 *)
val Int16Array.exists: (Int16.int -> bool) -> Int16Array.array -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 474.13-474.18 *)
val Int16Array.find: (Int16.int -> bool) -> Int16Array.array -> Int16.int option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 472.13-472.16 *)
val Int16Array.findi: (int * Int16.int -> bool) -> Int16Array.array -> (int * Int16.int) option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 471.13-471.17 *)
val Int16Array.foldl: (Int16.int * 'a -> 'a) -> 'a -> Int16Array.array -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 468.13-468.17 *)
val Int16Array.foldli: (int * Int16.int * 'a -> 'a) -> 'a -> Int16Array.array -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 467.13-467.18 *)
val Int16Array.foldr: (Int16.int * 'a -> 'a) -> 'a -> Int16Array.array -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 470.13-470.17 *)
val Int16Array.foldri: (int * Int16.int * 'a -> 'a) -> 'a -> Int16Array.array -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 469.13-469.18 *)
val Int16Array.fromList: Int16.int list -> Int16Array.array (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 122.11-122.18 *)
val Int16Array.length: Int16Array.array -> int (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 90.11-90.16 *)
val Int16Array.maxLen: int (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 88.11-88.16 *)
val Int16Array.modify: (Int16.int -> Int16.int) -> Int16Array.array -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array.sml 40.11-40.16 *)
val Int16Array.modifyi: (int * Int16.int -> Int16.int) -> Int16Array.array -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array.sml 39.11-39.17 *)
val Int16Array.sub: Int16Array.array * int -> Int16.int (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 450.13-450.15 *)
val Int16Array.tabulate: int * (int -> Int16.int) -> Int16Array.array (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 114.11-114.18 *)
val Int16Array.update: Int16Array.array * int * Int16.int -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 452.13-452.18 *)
val Int16Array.vector: Int16Array.array -> Int16Vector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/array.sml 36.11-36.16 *)
structure Int16Array2: MONO_ARRAY2 where type array = Int16Array2.array where type elem = Int16.int where type vector = Int16Vector.vector (* @ $(SML_LIB)/basis/libs/basis-2002/top-level/top-level.sml 29.11-29.21 *)
type Int16Array2.array = Int16Array2.array (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array2.fun 18.12-18.16 *)
type Int16Array2.elem = Int16.int (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array2.fun 15.12-15.15 *)
type Int16Array2.region = {base: Int16Array2.array, col: int, ncols: int option, nrows: int option, row: int} (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array2.fun 19.12-19.17 *)
datatype Int16Array2.traversal = ColMajor | RowMajor (* = datatype Array2.traversal *) (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 106.16-106.24 *)
type Int16Array2.vector = Int16Vector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array2.fun 16.12-16.17 *)
con Int16Array2.ColMajor: Array2.traversal (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 106.39-106.46 *)
con Int16Array2.RowMajor: Array2.traversal (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 106.28-106.35 *)
val Int16Array2.app: Array2.traversal -> (Int16.int -> unit) -> Int16Array2.array -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 294.11-294.13 *)
val Int16Array2.appi: Array2.traversal -> (int * int * Int16.int -> unit) -> {base: Int16Array2.array, col: int, ncols: int option, nrows: int option, row: int} -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 291.11-291.14 *)
val Int16Array2.array: int * int * Int16.int -> Int16Array2.array (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 140.14-140.18 *)
val Int16Array2.column: Int16Array2.array * int -> Int16Vector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 237.11-237.16 *)
val Int16Array2.copy: {dst: Int16Array2.array, dst_col: int, dst_row: int, src: {base: Int16Array2.array, col: int, ncols: int option, nrows: int option, row: int}} -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 309.11-309.14 *)
val Int16Array2.dimensions: Int16Array2.array -> int * int (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 33.11-33.20 *)
val Int16Array2.fold: Array2.traversal -> (Int16.int * 'a -> 'a) -> 'a -> Int16Array2.array -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 288.11-288.14 *)
val Int16Array2.foldi: Array2.traversal -> (int * int * Int16.int * 'a -> 'a) -> 'a -> {base: Int16Array2.array, col: int, ncols: int option, nrows: int option, row: int} -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 283.11-283.15 *)
val Int16Array2.fromList: Int16.int list list -> Int16Array2.array (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 188.14-188.21 *)
val Int16Array2.modify: Array2.traversal -> (Int16.int -> Int16.int) -> Int16Array2.array -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 299.11-299.16 *)
val Int16Array2.modifyi: Array2.traversal -> (int * int * Int16.int -> Int16.int) -> {base: Int16Array2.array, col: int, ncols: int option, nrows: int option, row: int} -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 296.11-296.17 *)
val Int16Array2.nCols: Int16Array2.array -> int (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 38.11-38.15 *)
val Int16Array2.nRows: Int16Array2.array -> int (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 36.11-36.15 *)
val Int16Array2.row: Int16Array2.array * int -> Int16Vector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 222.11-222.13 *)
val Int16Array2.sub: Int16Array2.array * int * int -> Int16.int (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 182.14-182.16 *)
val Int16Array2.tabulate: Array2.traversal -> int * int * (int * int -> Int16.int) -> Int16Array2.array (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 301.11-301.18 *)
val Int16Array2.update: Int16Array2.array * int * int * Int16.int -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 184.14-184.19 *)
structure Int16ArraySlice: MONO_ARRAY_SLICE where type array = Int16Array.array where type elem = Int16.int where type slice = Int16ArraySlice.slice where type vector = Int16Vector.vector where type vector_slice = Int16VectorSlice.slice (* @ $(SML_LIB)/basis/libs/basis-extra/top-level/basis.sml 112.17-112.31 *)
type Int16ArraySlice.array = Int16Array.array (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array.fun 35.18-35.22 *)
type Int16ArraySlice.elem = Int16.int (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array.fun 34.18-34.21 *)
type Int16ArraySlice.slice = Int16ArraySlice.slice (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array.fun 36.18-36.22 *)
type Int16ArraySlice.vector = Int16Vector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array.fun 37.18-37.23 *)
type Int16ArraySlice.vector_slice = Int16VectorSlice.slice (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array.fun 38.18-38.29 *)
val Int16ArraySlice.all: (Int16.int -> bool) -> Int16ArraySlice.slice -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 235.17-235.19 *)
val Int16ArraySlice.app: (Int16.int -> unit) -> Int16ArraySlice.slice -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 226.17-226.19 *)
val Int16ArraySlice.appi: (int * Int16.int -> unit) -> Int16ArraySlice.slice -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 225.17-225.20 *)
val Int16ArraySlice.base: Int16ArraySlice.slice -> Int16Array.array * int * int (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 208.17-208.20 *)
val Int16ArraySlice.collate: (Int16.int * Int16.int -> order) -> Int16ArraySlice.slice * Int16ArraySlice.slice -> order (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 236.17-236.23 *)
val Int16ArraySlice.copy: {di: int, dst: Int16Array.array, src: Int16ArraySlice.slice} -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 185.17-185.20 *)
val Int16ArraySlice.copyVec: {di: int, dst: Int16Array.array, src: Int16VectorSlice.slice} -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array.sml 28.17-28.23 *)
val Int16ArraySlice.exists: (Int16.int -> bool) -> Int16ArraySlice.slice -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 233.17-233.22 *)
val Int16ArraySlice.find: (Int16.int -> bool) -> Int16ArraySlice.slice -> Int16.int option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 231.17-231.20 *)
val Int16ArraySlice.findi: (int * Int16.int -> bool) -> Int16ArraySlice.slice -> (int * Int16.int) option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 229.17-229.21 *)
val Int16ArraySlice.foldl: (Int16.int * 'a -> 'a) -> 'a -> Int16ArraySlice.slice -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 223.17-223.21 *)
val Int16ArraySlice.foldli: (int * Int16.int * 'a -> 'a) -> 'a -> Int16ArraySlice.slice -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 221.17-221.22 *)
val Int16ArraySlice.foldr: (Int16.int * 'a -> 'a) -> 'a -> Int16ArraySlice.slice -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 224.17-224.21 *)
val Int16ArraySlice.foldri: (int * Int16.int * 'a -> 'a) -> 'a -> Int16ArraySlice.slice -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 222.17-222.22 *)
val Int16ArraySlice.full: Int16Array.array -> Int16ArraySlice.slice (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 192.17-192.20 *)
val Int16ArraySlice.getItem: Int16ArraySlice.slice -> (Int16.int * Int16ArraySlice.slice) option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 220.17-220.23 *)
val Int16ArraySlice.isEmpty: Int16ArraySlice.slice -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 219.17-219.23 *)
val Int16ArraySlice.length: Int16ArraySlice.slice -> int (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 134.17-134.22 *)
val Int16ArraySlice.modify: (Int16.int -> Int16.int) -> Int16ArraySlice.slice -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array.sml 31.17-31.22 *)
val Int16ArraySlice.modifyi: (int * Int16.int -> Int16.int) -> Int16ArraySlice.slice -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array.sml 30.17-30.23 *)
val Int16ArraySlice.slice: Int16Array.array * int * int option -> Int16ArraySlice.slice (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 206.17-206.21 *)
val Int16ArraySlice.sub: Int16ArraySlice.slice * int -> Int16.int (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 142.17-142.19 *)
val Int16ArraySlice.subslice: Int16ArraySlice.slice * int * int option -> Int16ArraySlice.slice (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 199.17-199.24 *)
val Int16ArraySlice.update: Int16ArraySlice.slice * int * Int16.int -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 155.17-155.22 *)
val Int16ArraySlice.vector: Int16ArraySlice.slice -> Int16Vector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/array.sml 27.17-27.22 *)
structure Int16Vector: MONO_VECTOR where type elem = Int16.int where type vector = Int16Vector.vector (* @ $(SML_LIB)/basis/libs/basis-2002/top-level/top-level.sml 30.11-30.21 *)
type Int16Vector.elem = Int16.int (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-vector.fun 35.12-35.15 *)
type Int16Vector.vector = Int16Vector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-vector.fun 36.12-36.17 *)
val Int16Vector.all: (Int16.int -> bool) -> Int16Vector.vector -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 476.13-476.15 *)
val Int16Vector.app: (Int16.int -> unit) -> Int16Vector.vector -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 464.13-464.15 *)
val Int16Vector.appi: (int * Int16.int -> unit) -> Int16Vector.vector -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 463.13-463.16 *)
val Int16Vector.collate: (Int16.int * Int16.int -> order) -> Int16Vector.vector * Int16Vector.vector -> order (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 477.13-477.19 *)
val Int16Vector.concat: Int16Vector.vector list -> Int16Vector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 462.13-462.18 *)
val Int16Vector.exists: (Int16.int -> bool) -> Int16Vector.vector -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 474.13-474.18 *)
val Int16Vector.find: (Int16.int -> bool) -> Int16Vector.vector -> Int16.int option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 472.13-472.16 *)
val Int16Vector.findi: (int * Int16.int -> bool) -> Int16Vector.vector -> (int * Int16.int) option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 471.13-471.17 *)
val Int16Vector.foldl: (Int16.int * 'a -> 'a) -> 'a -> Int16Vector.vector -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 468.13-468.17 *)
val Int16Vector.foldli: (int * Int16.int * 'a -> 'a) -> 'a -> Int16Vector.vector -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 467.13-467.18 *)
val Int16Vector.foldr: (Int16.int * 'a -> 'a) -> 'a -> Int16Vector.vector -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 470.13-470.17 *)
val Int16Vector.foldri: (int * Int16.int * 'a -> 'a) -> 'a -> Int16Vector.vector -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 469.13-469.18 *)
val Int16Vector.fromList: Int16.int list -> Int16Vector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 122.11-122.18 *)
val Int16Vector.length: Int16Vector.vector -> int (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 90.11-90.16 *)
val Int16Vector.map: (Int16.int -> Int16.int) -> Int16Vector.vector -> Int16Vector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 466.13-466.15 *)
val Int16Vector.mapi: (int * Int16.int -> Int16.int) -> Int16Vector.vector -> Int16Vector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 465.13-465.16 *)
val Int16Vector.maxLen: int (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 88.11-88.16 *)
val Int16Vector.sub: Int16Vector.vector * int -> Int16.int (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 450.13-450.15 *)
val Int16Vector.tabulate: int * (int -> Int16.int) -> Int16Vector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 114.11-114.18 *)
val Int16Vector.update: Int16Vector.vector * int * Int16.int -> Int16Vector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/vector.sml 30.11-30.16 *)
structure Int16VectorSlice: MONO_VECTOR_SLICE where type elem = Int16.int where type slice = Int16VectorSlice.slice where type vector = Int16Vector.vector (* @ $(SML_LIB)/basis/libs/basis-extra/top-level/basis.sml 114.17-114.32 *)
type Int16VectorSlice.elem = Int16.int (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-vector.fun 43.18-43.21 *)
type Int16VectorSlice.slice = Int16VectorSlice.slice (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-vector.fun 45.18-45.22 *)
type Int16VectorSlice.vector = Int16Vector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-vector.fun 44.18-44.23 *)
val Int16VectorSlice.all: (Int16.int -> bool) -> Int16VectorSlice.slice -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 235.17-235.19 *)
val Int16VectorSlice.app: (Int16.int -> unit) -> Int16VectorSlice.slice -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 226.17-226.19 *)
val Int16VectorSlice.appi: (int * Int16.int -> unit) -> Int16VectorSlice.slice -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 225.17-225.20 *)
val Int16VectorSlice.base: Int16VectorSlice.slice -> Int16Vector.vector * int * int (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 208.17-208.20 *)
val Int16VectorSlice.collate: (Int16.int * Int16.int -> order) -> Int16VectorSlice.slice * Int16VectorSlice.slice -> order (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 236.17-236.23 *)
val Int16VectorSlice.concat: Int16VectorSlice.slice list -> Int16Vector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 240.17-240.22 *)
val Int16VectorSlice.exists: (Int16.int -> bool) -> Int16VectorSlice.slice -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 233.17-233.22 *)
val Int16VectorSlice.find: (Int16.int -> bool) -> Int16VectorSlice.slice -> Int16.int option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 231.17-231.20 *)
val Int16VectorSlice.findi: (int * Int16.int -> bool) -> Int16VectorSlice.slice -> (int * Int16.int) option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 229.17-229.21 *)
val Int16VectorSlice.foldl: (Int16.int * 'a -> 'a) -> 'a -> Int16VectorSlice.slice -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 223.17-223.21 *)
val Int16VectorSlice.foldli: (int * Int16.int * 'a -> 'a) -> 'a -> Int16VectorSlice.slice -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 221.17-221.22 *)
val Int16VectorSlice.foldr: (Int16.int * 'a -> 'a) -> 'a -> Int16VectorSlice.slice -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 224.17-224.21 *)
val Int16VectorSlice.foldri: (int * Int16.int * 'a -> 'a) -> 'a -> Int16VectorSlice.slice -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 222.17-222.22 *)
val Int16VectorSlice.full: Int16Vector.vector -> Int16VectorSlice.slice (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 192.17-192.20 *)
val Int16VectorSlice.getItem: Int16VectorSlice.slice -> (Int16.int * Int16VectorSlice.slice) option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 220.17-220.23 *)
val Int16VectorSlice.isEmpty: Int16VectorSlice.slice -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 219.17-219.23 *)
val Int16VectorSlice.length: Int16VectorSlice.slice -> int (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 134.17-134.22 *)
val Int16VectorSlice.map: (Int16.int -> Int16.int) -> Int16VectorSlice.slice -> Int16Vector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 228.17-228.19 *)
val Int16VectorSlice.mapi: (int * Int16.int -> Int16.int) -> Int16VectorSlice.slice -> Int16Vector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 227.17-227.20 *)
val Int16VectorSlice.slice: Int16Vector.vector * int * int option -> Int16VectorSlice.slice (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 206.17-206.21 *)
val Int16VectorSlice.sub: Int16VectorSlice.slice * int -> Int16.int (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 142.17-142.19 *)
val Int16VectorSlice.subslice: Int16VectorSlice.slice * int * int option -> Int16VectorSlice.slice (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 199.17-199.24 *)
val Int16VectorSlice.vector: Int16VectorSlice.slice -> Int16Vector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/vector.sml 21.17-21.22 *)
structure Int17: INTEGER where type int = Int17.int (* @ $(SML_LIB)/basis/libs/basis-extra/top-level/basis.sml 83.17-83.21 *)
type Int17.int = Int17.int (* @ $(SML_LIB)/basis/primitive/prim-basis.sml 153.12-153.14 *)
val Int17.* : Int17.int * Int17.int -> Int17.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 64.17-64.17 *)
val Int17.+ : Int17.int * Int17.int -> Int17.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 65.17-65.17 *)
val Int17.- : Int17.int * Int17.int -> Int17.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 66.17-66.17 *)
val Int17.< : Int17.int * Int17.int -> bool (* @ $(SML_LIB)/basis/integer/embed-int.sml 77.17-77.17 *)
val Int17.<= : Int17.int * Int17.int -> bool (* @ $(SML_LIB)/basis/integer/embed-int.sml 78.17-78.18 *)
val Int17.> : Int17.int * Int17.int -> bool (* @ $(SML_LIB)/basis/integer/embed-int.sml 79.17-79.17 *)
val Int17.>= : Int17.int * Int17.int -> bool (* @ $(SML_LIB)/basis/integer/embed-int.sml 80.17-80.18 *)
val Int17.abs: Int17.int -> Int17.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 93.14-93.16 *)
val Int17.compare: Int17.int * Int17.int -> order (* @ $(SML_LIB)/basis/integer/embed-int.sml 81.14-81.20 *)
val Int17.div: Int17.int * Int17.int -> Int17.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 67.17-67.19 *)
val Int17.fmt: StringCvt.radix -> Int17.int -> string (* @ $(SML_LIB)/basis/integer/embed-int.sml 96.11-96.13 *)
val Int17.fromInt: int -> Int17.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 84.11-84.17 *)
val Int17.fromLarge: LargeInt.int -> Int17.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 98.11-98.19 *)
val Int17.fromString: string -> Int17.int option (* @ $(SML_LIB)/basis/integer/embed-int.sml 100.11-100.20 *)
val Int17.max: Int17.int * Int17.int -> Int17.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 102.11-102.13 *)
val Int17.maxInt: Int17.int option (* @ $(SML_LIB)/basis/integer/embed-int.sml 56.11-56.16 *)
val Int17.min: Int17.int * Int17.int -> Int17.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 104.11-104.13 *)
val Int17.minInt: Int17.int option (* @ $(SML_LIB)/basis/integer/embed-int.sml 58.11-58.16 *)
val Int17.mod: Int17.int * Int17.int -> Int17.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 68.17-68.19 *)
val Int17.precision: int option (* @ $(SML_LIB)/basis/integer/embed-int.sml 39.11-39.19 *)
val Int17.quot: Int17.int * Int17.int -> Int17.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 69.14-69.17 *)
val Int17.rem: Int17.int * Int17.int -> Int17.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 70.14-70.16 *)
val Int17.sameSign: Int17.int * Int17.int -> bool (* @ $(SML_LIB)/basis/integer/embed-int.sml 113.11-113.18 *)
val Int17.scan: StringCvt.radix -> ('a -> (char * 'a) option) -> 'a -> (Int17.int * 'a) option (* @ $(SML_LIB)/basis/integer/embed-int.sml 106.11-106.14 *)
val Int17.sign: Int17.int -> int (* @ $(SML_LIB)/basis/integer/embed-int.sml 111.11-111.14 *)
val Int17.toInt: Int17.int -> int (* @ $(SML_LIB)/basis/integer/embed-int.sml 86.11-86.15 *)
val Int17.toLarge: Int17.int -> LargeInt.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 115.11-115.17 *)
val Int17.toString: Int17.int -> string (* @ $(SML_LIB)/basis/integer/embed-int.sml 117.11-117.18 *)
val Int17.~ : Int17.int -> Int17.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 92.14-92.14 *)
structure Int18: INTEGER where type int = Int18.int (* @ $(SML_LIB)/basis/libs/basis-extra/top-level/basis.sml 84.17-84.21 *)
type Int18.int = Int18.int (* @ $(SML_LIB)/basis/primitive/prim-basis.sml 158.12-158.14 *)
val Int18.* : Int18.int * Int18.int -> Int18.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 64.17-64.17 *)
val Int18.+ : Int18.int * Int18.int -> Int18.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 65.17-65.17 *)
val Int18.- : Int18.int * Int18.int -> Int18.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 66.17-66.17 *)
val Int18.< : Int18.int * Int18.int -> bool (* @ $(SML_LIB)/basis/integer/embed-int.sml 77.17-77.17 *)
val Int18.<= : Int18.int * Int18.int -> bool (* @ $(SML_LIB)/basis/integer/embed-int.sml 78.17-78.18 *)
val Int18.> : Int18.int * Int18.int -> bool (* @ $(SML_LIB)/basis/integer/embed-int.sml 79.17-79.17 *)
val Int18.>= : Int18.int * Int18.int -> bool (* @ $(SML_LIB)/basis/integer/embed-int.sml 80.17-80.18 *)
val Int18.abs: Int18.int -> Int18.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 93.14-93.16 *)
val Int18.compare: Int18.int * Int18.int -> order (* @ $(SML_LIB)/basis/integer/embed-int.sml 81.14-81.20 *)
val Int18.div: Int18.int * Int18.int -> Int18.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 67.17-67.19 *)
val Int18.fmt: StringCvt.radix -> Int18.int -> string (* @ $(SML_LIB)/basis/integer/embed-int.sml 96.11-96.13 *)
val Int18.fromInt: int -> Int18.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 84.11-84.17 *)
val Int18.fromLarge: LargeInt.int -> Int18.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 98.11-98.19 *)
val Int18.fromString: string -> Int18.int option (* @ $(SML_LIB)/basis/integer/embed-int.sml 100.11-100.20 *)
val Int18.max: Int18.int * Int18.int -> Int18.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 102.11-102.13 *)
val Int18.maxInt: Int18.int option (* @ $(SML_LIB)/basis/integer/embed-int.sml 56.11-56.16 *)
val Int18.min: Int18.int * Int18.int -> Int18.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 104.11-104.13 *)
val Int18.minInt: Int18.int option (* @ $(SML_LIB)/basis/integer/embed-int.sml 58.11-58.16 *)
val Int18.mod: Int18.int * Int18.int -> Int18.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 68.17-68.19 *)
val Int18.precision: int option (* @ $(SML_LIB)/basis/integer/embed-int.sml 39.11-39.19 *)
val Int18.quot: Int18.int * Int18.int -> Int18.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 69.14-69.17 *)
val Int18.rem: Int18.int * Int18.int -> Int18.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 70.14-70.16 *)
val Int18.sameSign: Int18.int * Int18.int -> bool (* @ $(SML_LIB)/basis/integer/embed-int.sml 113.11-113.18 *)
val Int18.scan: StringCvt.radix -> ('a -> (char * 'a) option) -> 'a -> (Int18.int * 'a) option (* @ $(SML_LIB)/basis/integer/embed-int.sml 106.11-106.14 *)
val Int18.sign: Int18.int -> int (* @ $(SML_LIB)/basis/integer/embed-int.sml 111.11-111.14 *)
val Int18.toInt: Int18.int -> int (* @ $(SML_LIB)/basis/integer/embed-int.sml 86.11-86.15 *)
val Int18.toLarge: Int18.int -> LargeInt.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 115.11-115.17 *)
val Int18.toString: Int18.int -> string (* @ $(SML_LIB)/basis/integer/embed-int.sml 117.11-117.18 *)
val Int18.~ : Int18.int -> Int18.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 92.14-92.14 *)
structure Int19: INTEGER where type int = Int19.int (* @ $(SML_LIB)/basis/libs/basis-extra/top-level/basis.sml 85.17-85.21 *)
type Int19.int = Int19.int (* @ $(SML_LIB)/basis/primitive/prim-basis.sml 163.12-163.14 *)
val Int19.* : Int19.int * Int19.int -> Int19.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 64.17-64.17 *)
val Int19.+ : Int19.int * Int19.int -> Int19.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 65.17-65.17 *)
val Int19.- : Int19.int * Int19.int -> Int19.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 66.17-66.17 *)
val Int19.< : Int19.int * Int19.int -> bool (* @ $(SML_LIB)/basis/integer/embed-int.sml 77.17-77.17 *)
val Int19.<= : Int19.int * Int19.int -> bool (* @ $(SML_LIB)/basis/integer/embed-int.sml 78.17-78.18 *)
val Int19.> : Int19.int * Int19.int -> bool (* @ $(SML_LIB)/basis/integer/embed-int.sml 79.17-79.17 *)
val Int19.>= : Int19.int * Int19.int -> bool (* @ $(SML_LIB)/basis/integer/embed-int.sml 80.17-80.18 *)
val Int19.abs: Int19.int -> Int19.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 93.14-93.16 *)
val Int19.compare: Int19.int * Int19.int -> order (* @ $(SML_LIB)/basis/integer/embed-int.sml 81.14-81.20 *)
val Int19.div: Int19.int * Int19.int -> Int19.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 67.17-67.19 *)
val Int19.fmt: StringCvt.radix -> Int19.int -> string (* @ $(SML_LIB)/basis/integer/embed-int.sml 96.11-96.13 *)
val Int19.fromInt: int -> Int19.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 84.11-84.17 *)
val Int19.fromLarge: LargeInt.int -> Int19.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 98.11-98.19 *)
val Int19.fromString: string -> Int19.int option (* @ $(SML_LIB)/basis/integer/embed-int.sml 100.11-100.20 *)
val Int19.max: Int19.int * Int19.int -> Int19.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 102.11-102.13 *)
val Int19.maxInt: Int19.int option (* @ $(SML_LIB)/basis/integer/embed-int.sml 56.11-56.16 *)
val Int19.min: Int19.int * Int19.int -> Int19.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 104.11-104.13 *)
val Int19.minInt: Int19.int option (* @ $(SML_LIB)/basis/integer/embed-int.sml 58.11-58.16 *)
val Int19.mod: Int19.int * Int19.int -> Int19.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 68.17-68.19 *)
val Int19.precision: int option (* @ $(SML_LIB)/basis/integer/embed-int.sml 39.11-39.19 *)
val Int19.quot: Int19.int * Int19.int -> Int19.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 69.14-69.17 *)
val Int19.rem: Int19.int * Int19.int -> Int19.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 70.14-70.16 *)
val Int19.sameSign: Int19.int * Int19.int -> bool (* @ $(SML_LIB)/basis/integer/embed-int.sml 113.11-113.18 *)
val Int19.scan: StringCvt.radix -> ('a -> (char * 'a) option) -> 'a -> (Int19.int * 'a) option (* @ $(SML_LIB)/basis/integer/embed-int.sml 106.11-106.14 *)
val Int19.sign: Int19.int -> int (* @ $(SML_LIB)/basis/integer/embed-int.sml 111.11-111.14 *)
val Int19.toInt: Int19.int -> int (* @ $(SML_LIB)/basis/integer/embed-int.sml 86.11-86.15 *)
val Int19.toLarge: Int19.int -> LargeInt.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 115.11-115.17 *)
val Int19.toString: Int19.int -> string (* @ $(SML_LIB)/basis/integer/embed-int.sml 117.11-117.18 *)
val Int19.~ : Int19.int -> Int19.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 92.14-92.14 *)
structure Int2: INTEGER where type int = Int2.int (* @ $(SML_LIB)/basis/libs/basis-extra/top-level/basis.sml 67.17-67.20 *)
type Int2.int = Int2.int (* @ $(SML_LIB)/basis/primitive/prim-basis.sml 78.12-78.14 *)
val Int2.* : Int2.int * Int2.int -> Int2.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 64.17-64.17 *)
val Int2.+ : Int2.int * Int2.int -> Int2.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 65.17-65.17 *)
val Int2.- : Int2.int * Int2.int -> Int2.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 66.17-66.17 *)
val Int2.< : Int2.int * Int2.int -> bool (* @ $(SML_LIB)/basis/integer/embed-int.sml 77.17-77.17 *)
val Int2.<= : Int2.int * Int2.int -> bool (* @ $(SML_LIB)/basis/integer/embed-int.sml 78.17-78.18 *)
val Int2.> : Int2.int * Int2.int -> bool (* @ $(SML_LIB)/basis/integer/embed-int.sml 79.17-79.17 *)
val Int2.>= : Int2.int * Int2.int -> bool (* @ $(SML_LIB)/basis/integer/embed-int.sml 80.17-80.18 *)
val Int2.abs: Int2.int -> Int2.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 93.14-93.16 *)
val Int2.compare: Int2.int * Int2.int -> order (* @ $(SML_LIB)/basis/integer/embed-int.sml 81.14-81.20 *)
val Int2.div: Int2.int * Int2.int -> Int2.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 67.17-67.19 *)
val Int2.fmt: StringCvt.radix -> Int2.int -> string (* @ $(SML_LIB)/basis/integer/embed-int.sml 96.11-96.13 *)
val Int2.fromInt: int -> Int2.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 84.11-84.17 *)
val Int2.fromLarge: LargeInt.int -> Int2.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 98.11-98.19 *)
val Int2.fromString: string -> Int2.int option (* @ $(SML_LIB)/basis/integer/embed-int.sml 100.11-100.20 *)
val Int2.max: Int2.int * Int2.int -> Int2.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 102.11-102.13 *)
val Int2.maxInt: Int2.int option (* @ $(SML_LIB)/basis/integer/embed-int.sml 56.11-56.16 *)
val Int2.min: Int2.int * Int2.int -> Int2.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 104.11-104.13 *)
val Int2.minInt: Int2.int option (* @ $(SML_LIB)/basis/integer/embed-int.sml 58.11-58.16 *)
val Int2.mod: Int2.int * Int2.int -> Int2.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 68.17-68.19 *)
val Int2.precision: int option (* @ $(SML_LIB)/basis/integer/embed-int.sml 39.11-39.19 *)
val Int2.quot: Int2.int * Int2.int -> Int2.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 69.14-69.17 *)
val Int2.rem: Int2.int * Int2.int -> Int2.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 70.14-70.16 *)
val Int2.sameSign: Int2.int * Int2.int -> bool (* @ $(SML_LIB)/basis/integer/embed-int.sml 113.11-113.18 *)
val Int2.scan: StringCvt.radix -> ('a -> (char * 'a) option) -> 'a -> (Int2.int * 'a) option (* @ $(SML_LIB)/basis/integer/embed-int.sml 106.11-106.14 *)
val Int2.sign: Int2.int -> int (* @ $(SML_LIB)/basis/integer/embed-int.sml 111.11-111.14 *)
val Int2.toInt: Int2.int -> int (* @ $(SML_LIB)/basis/integer/embed-int.sml 86.11-86.15 *)
val Int2.toLarge: Int2.int -> LargeInt.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 115.11-115.17 *)
val Int2.toString: Int2.int -> string (* @ $(SML_LIB)/basis/integer/embed-int.sml 117.11-117.18 *)
val Int2.~ : Int2.int -> Int2.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 92.14-92.14 *)
structure Int20: INTEGER where type int = Int20.int (* @ $(SML_LIB)/basis/libs/basis-extra/top-level/basis.sml 86.17-86.21 *)
type Int20.int = Int20.int (* @ $(SML_LIB)/basis/primitive/prim-basis.sml 168.12-168.14 *)
val Int20.* : Int20.int * Int20.int -> Int20.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 64.17-64.17 *)
val Int20.+ : Int20.int * Int20.int -> Int20.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 65.17-65.17 *)
val Int20.- : Int20.int * Int20.int -> Int20.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 66.17-66.17 *)
val Int20.< : Int20.int * Int20.int -> bool (* @ $(SML_LIB)/basis/integer/embed-int.sml 77.17-77.17 *)
val Int20.<= : Int20.int * Int20.int -> bool (* @ $(SML_LIB)/basis/integer/embed-int.sml 78.17-78.18 *)
val Int20.> : Int20.int * Int20.int -> bool (* @ $(SML_LIB)/basis/integer/embed-int.sml 79.17-79.17 *)
val Int20.>= : Int20.int * Int20.int -> bool (* @ $(SML_LIB)/basis/integer/embed-int.sml 80.17-80.18 *)
val Int20.abs: Int20.int -> Int20.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 93.14-93.16 *)
val Int20.compare: Int20.int * Int20.int -> order (* @ $(SML_LIB)/basis/integer/embed-int.sml 81.14-81.20 *)
val Int20.div: Int20.int * Int20.int -> Int20.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 67.17-67.19 *)
val Int20.fmt: StringCvt.radix -> Int20.int -> string (* @ $(SML_LIB)/basis/integer/embed-int.sml 96.11-96.13 *)
val Int20.fromInt: int -> Int20.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 84.11-84.17 *)
val Int20.fromLarge: LargeInt.int -> Int20.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 98.11-98.19 *)
val Int20.fromString: string -> Int20.int option (* @ $(SML_LIB)/basis/integer/embed-int.sml 100.11-100.20 *)
val Int20.max: Int20.int * Int20.int -> Int20.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 102.11-102.13 *)
val Int20.maxInt: Int20.int option (* @ $(SML_LIB)/basis/integer/embed-int.sml 56.11-56.16 *)
val Int20.min: Int20.int * Int20.int -> Int20.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 104.11-104.13 *)
val Int20.minInt: Int20.int option (* @ $(SML_LIB)/basis/integer/embed-int.sml 58.11-58.16 *)
val Int20.mod: Int20.int * Int20.int -> Int20.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 68.17-68.19 *)
val Int20.precision: int option (* @ $(SML_LIB)/basis/integer/embed-int.sml 39.11-39.19 *)
val Int20.quot: Int20.int * Int20.int -> Int20.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 69.14-69.17 *)
val Int20.rem: Int20.int * Int20.int -> Int20.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 70.14-70.16 *)
val Int20.sameSign: Int20.int * Int20.int -> bool (* @ $(SML_LIB)/basis/integer/embed-int.sml 113.11-113.18 *)
val Int20.scan: StringCvt.radix -> ('a -> (char * 'a) option) -> 'a -> (Int20.int * 'a) option (* @ $(SML_LIB)/basis/integer/embed-int.sml 106.11-106.14 *)
val Int20.sign: Int20.int -> int (* @ $(SML_LIB)/basis/integer/embed-int.sml 111.11-111.14 *)
val Int20.toInt: Int20.int -> int (* @ $(SML_LIB)/basis/integer/embed-int.sml 86.11-86.15 *)
val Int20.toLarge: Int20.int -> LargeInt.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 115.11-115.17 *)
val Int20.toString: Int20.int -> string (* @ $(SML_LIB)/basis/integer/embed-int.sml 117.11-117.18 *)
val Int20.~ : Int20.int -> Int20.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 92.14-92.14 *)
structure Int21: INTEGER where type int = Int21.int (* @ $(SML_LIB)/basis/libs/basis-extra/top-level/basis.sml 87.17-87.21 *)
type Int21.int = Int21.int (* @ $(SML_LIB)/basis/primitive/prim-basis.sml 173.12-173.14 *)
val Int21.* : Int21.int * Int21.int -> Int21.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 64.17-64.17 *)
val Int21.+ : Int21.int * Int21.int -> Int21.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 65.17-65.17 *)
val Int21.- : Int21.int * Int21.int -> Int21.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 66.17-66.17 *)
val Int21.< : Int21.int * Int21.int -> bool (* @ $(SML_LIB)/basis/integer/embed-int.sml 77.17-77.17 *)
val Int21.<= : Int21.int * Int21.int -> bool (* @ $(SML_LIB)/basis/integer/embed-int.sml 78.17-78.18 *)
val Int21.> : Int21.int * Int21.int -> bool (* @ $(SML_LIB)/basis/integer/embed-int.sml 79.17-79.17 *)
val Int21.>= : Int21.int * Int21.int -> bool (* @ $(SML_LIB)/basis/integer/embed-int.sml 80.17-80.18 *)
val Int21.abs: Int21.int -> Int21.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 93.14-93.16 *)
val Int21.compare: Int21.int * Int21.int -> order (* @ $(SML_LIB)/basis/integer/embed-int.sml 81.14-81.20 *)
val Int21.div: Int21.int * Int21.int -> Int21.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 67.17-67.19 *)
val Int21.fmt: StringCvt.radix -> Int21.int -> string (* @ $(SML_LIB)/basis/integer/embed-int.sml 96.11-96.13 *)
val Int21.fromInt: int -> Int21.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 84.11-84.17 *)
val Int21.fromLarge: LargeInt.int -> Int21.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 98.11-98.19 *)
val Int21.fromString: string -> Int21.int option (* @ $(SML_LIB)/basis/integer/embed-int.sml 100.11-100.20 *)
val Int21.max: Int21.int * Int21.int -> Int21.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 102.11-102.13 *)
val Int21.maxInt: Int21.int option (* @ $(SML_LIB)/basis/integer/embed-int.sml 56.11-56.16 *)
val Int21.min: Int21.int * Int21.int -> Int21.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 104.11-104.13 *)
val Int21.minInt: Int21.int option (* @ $(SML_LIB)/basis/integer/embed-int.sml 58.11-58.16 *)
val Int21.mod: Int21.int * Int21.int -> Int21.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 68.17-68.19 *)
val Int21.precision: int option (* @ $(SML_LIB)/basis/integer/embed-int.sml 39.11-39.19 *)
val Int21.quot: Int21.int * Int21.int -> Int21.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 69.14-69.17 *)
val Int21.rem: Int21.int * Int21.int -> Int21.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 70.14-70.16 *)
val Int21.sameSign: Int21.int * Int21.int -> bool (* @ $(SML_LIB)/basis/integer/embed-int.sml 113.11-113.18 *)
val Int21.scan: StringCvt.radix -> ('a -> (char * 'a) option) -> 'a -> (Int21.int * 'a) option (* @ $(SML_LIB)/basis/integer/embed-int.sml 106.11-106.14 *)
val Int21.sign: Int21.int -> int (* @ $(SML_LIB)/basis/integer/embed-int.sml 111.11-111.14 *)
val Int21.toInt: Int21.int -> int (* @ $(SML_LIB)/basis/integer/embed-int.sml 86.11-86.15 *)
val Int21.toLarge: Int21.int -> LargeInt.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 115.11-115.17 *)
val Int21.toString: Int21.int -> string (* @ $(SML_LIB)/basis/integer/embed-int.sml 117.11-117.18 *)
val Int21.~ : Int21.int -> Int21.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 92.14-92.14 *)
structure Int22: INTEGER where type int = Int22.int (* @ $(SML_LIB)/basis/libs/basis-extra/top-level/basis.sml 88.17-88.21 *)
type Int22.int = Int22.int (* @ $(SML_LIB)/basis/primitive/prim-basis.sml 178.12-178.14 *)
val Int22.* : Int22.int * Int22.int -> Int22.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 64.17-64.17 *)
val Int22.+ : Int22.int * Int22.int -> Int22.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 65.17-65.17 *)
val Int22.- : Int22.int * Int22.int -> Int22.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 66.17-66.17 *)
val Int22.< : Int22.int * Int22.int -> bool (* @ $(SML_LIB)/basis/integer/embed-int.sml 77.17-77.17 *)
val Int22.<= : Int22.int * Int22.int -> bool (* @ $(SML_LIB)/basis/integer/embed-int.sml 78.17-78.18 *)
val Int22.> : Int22.int * Int22.int -> bool (* @ $(SML_LIB)/basis/integer/embed-int.sml 79.17-79.17 *)
val Int22.>= : Int22.int * Int22.int -> bool (* @ $(SML_LIB)/basis/integer/embed-int.sml 80.17-80.18 *)
val Int22.abs: Int22.int -> Int22.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 93.14-93.16 *)
val Int22.compare: Int22.int * Int22.int -> order (* @ $(SML_LIB)/basis/integer/embed-int.sml 81.14-81.20 *)
val Int22.div: Int22.int * Int22.int -> Int22.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 67.17-67.19 *)
val Int22.fmt: StringCvt.radix -> Int22.int -> string (* @ $(SML_LIB)/basis/integer/embed-int.sml 96.11-96.13 *)
val Int22.fromInt: int -> Int22.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 84.11-84.17 *)
val Int22.fromLarge: LargeInt.int -> Int22.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 98.11-98.19 *)
val Int22.fromString: string -> Int22.int option (* @ $(SML_LIB)/basis/integer/embed-int.sml 100.11-100.20 *)
val Int22.max: Int22.int * Int22.int -> Int22.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 102.11-102.13 *)
val Int22.maxInt: Int22.int option (* @ $(SML_LIB)/basis/integer/embed-int.sml 56.11-56.16 *)
val Int22.min: Int22.int * Int22.int -> Int22.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 104.11-104.13 *)
val Int22.minInt: Int22.int option (* @ $(SML_LIB)/basis/integer/embed-int.sml 58.11-58.16 *)
val Int22.mod: Int22.int * Int22.int -> Int22.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 68.17-68.19 *)
val Int22.precision: int option (* @ $(SML_LIB)/basis/integer/embed-int.sml 39.11-39.19 *)
val Int22.quot: Int22.int * Int22.int -> Int22.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 69.14-69.17 *)
val Int22.rem: Int22.int * Int22.int -> Int22.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 70.14-70.16 *)
val Int22.sameSign: Int22.int * Int22.int -> bool (* @ $(SML_LIB)/basis/integer/embed-int.sml 113.11-113.18 *)
val Int22.scan: StringCvt.radix -> ('a -> (char * 'a) option) -> 'a -> (Int22.int * 'a) option (* @ $(SML_LIB)/basis/integer/embed-int.sml 106.11-106.14 *)
val Int22.sign: Int22.int -> int (* @ $(SML_LIB)/basis/integer/embed-int.sml 111.11-111.14 *)
val Int22.toInt: Int22.int -> int (* @ $(SML_LIB)/basis/integer/embed-int.sml 86.11-86.15 *)
val Int22.toLarge: Int22.int -> LargeInt.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 115.11-115.17 *)
val Int22.toString: Int22.int -> string (* @ $(SML_LIB)/basis/integer/embed-int.sml 117.11-117.18 *)
val Int22.~ : Int22.int -> Int22.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 92.14-92.14 *)
structure Int23: INTEGER where type int = Int23.int (* @ $(SML_LIB)/basis/libs/basis-extra/top-level/basis.sml 89.17-89.21 *)
type Int23.int = Int23.int (* @ $(SML_LIB)/basis/primitive/prim-basis.sml 183.12-183.14 *)
val Int23.* : Int23.int * Int23.int -> Int23.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 64.17-64.17 *)
val Int23.+ : Int23.int * Int23.int -> Int23.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 65.17-65.17 *)
val Int23.- : Int23.int * Int23.int -> Int23.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 66.17-66.17 *)
val Int23.< : Int23.int * Int23.int -> bool (* @ $(SML_LIB)/basis/integer/embed-int.sml 77.17-77.17 *)
val Int23.<= : Int23.int * Int23.int -> bool (* @ $(SML_LIB)/basis/integer/embed-int.sml 78.17-78.18 *)
val Int23.> : Int23.int * Int23.int -> bool (* @ $(SML_LIB)/basis/integer/embed-int.sml 79.17-79.17 *)
val Int23.>= : Int23.int * Int23.int -> bool (* @ $(SML_LIB)/basis/integer/embed-int.sml 80.17-80.18 *)
val Int23.abs: Int23.int -> Int23.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 93.14-93.16 *)
val Int23.compare: Int23.int * Int23.int -> order (* @ $(SML_LIB)/basis/integer/embed-int.sml 81.14-81.20 *)
val Int23.div: Int23.int * Int23.int -> Int23.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 67.17-67.19 *)
val Int23.fmt: StringCvt.radix -> Int23.int -> string (* @ $(SML_LIB)/basis/integer/embed-int.sml 96.11-96.13 *)
val Int23.fromInt: int -> Int23.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 84.11-84.17 *)
val Int23.fromLarge: LargeInt.int -> Int23.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 98.11-98.19 *)
val Int23.fromString: string -> Int23.int option (* @ $(SML_LIB)/basis/integer/embed-int.sml 100.11-100.20 *)
val Int23.max: Int23.int * Int23.int -> Int23.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 102.11-102.13 *)
val Int23.maxInt: Int23.int option (* @ $(SML_LIB)/basis/integer/embed-int.sml 56.11-56.16 *)
val Int23.min: Int23.int * Int23.int -> Int23.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 104.11-104.13 *)
val Int23.minInt: Int23.int option (* @ $(SML_LIB)/basis/integer/embed-int.sml 58.11-58.16 *)
val Int23.mod: Int23.int * Int23.int -> Int23.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 68.17-68.19 *)
val Int23.precision: int option (* @ $(SML_LIB)/basis/integer/embed-int.sml 39.11-39.19 *)
val Int23.quot: Int23.int * Int23.int -> Int23.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 69.14-69.17 *)
val Int23.rem: Int23.int * Int23.int -> Int23.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 70.14-70.16 *)
val Int23.sameSign: Int23.int * Int23.int -> bool (* @ $(SML_LIB)/basis/integer/embed-int.sml 113.11-113.18 *)
val Int23.scan: StringCvt.radix -> ('a -> (char * 'a) option) -> 'a -> (Int23.int * 'a) option (* @ $(SML_LIB)/basis/integer/embed-int.sml 106.11-106.14 *)
val Int23.sign: Int23.int -> int (* @ $(SML_LIB)/basis/integer/embed-int.sml 111.11-111.14 *)
val Int23.toInt: Int23.int -> int (* @ $(SML_LIB)/basis/integer/embed-int.sml 86.11-86.15 *)
val Int23.toLarge: Int23.int -> LargeInt.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 115.11-115.17 *)
val Int23.toString: Int23.int -> string (* @ $(SML_LIB)/basis/integer/embed-int.sml 117.11-117.18 *)
val Int23.~ : Int23.int -> Int23.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 92.14-92.14 *)
structure Int24: INTEGER where type int = Int24.int (* @ $(SML_LIB)/basis/libs/basis-extra/top-level/basis.sml 90.17-90.21 *)
type Int24.int = Int24.int (* @ $(SML_LIB)/basis/primitive/prim-basis.sml 188.12-188.14 *)
val Int24.* : Int24.int * Int24.int -> Int24.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 64.17-64.17 *)
val Int24.+ : Int24.int * Int24.int -> Int24.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 65.17-65.17 *)
val Int24.- : Int24.int * Int24.int -> Int24.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 66.17-66.17 *)
val Int24.< : Int24.int * Int24.int -> bool (* @ $(SML_LIB)/basis/integer/embed-int.sml 77.17-77.17 *)
val Int24.<= : Int24.int * Int24.int -> bool (* @ $(SML_LIB)/basis/integer/embed-int.sml 78.17-78.18 *)
val Int24.> : Int24.int * Int24.int -> bool (* @ $(SML_LIB)/basis/integer/embed-int.sml 79.17-79.17 *)
val Int24.>= : Int24.int * Int24.int -> bool (* @ $(SML_LIB)/basis/integer/embed-int.sml 80.17-80.18 *)
val Int24.abs: Int24.int -> Int24.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 93.14-93.16 *)
val Int24.compare: Int24.int * Int24.int -> order (* @ $(SML_LIB)/basis/integer/embed-int.sml 81.14-81.20 *)
val Int24.div: Int24.int * Int24.int -> Int24.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 67.17-67.19 *)
val Int24.fmt: StringCvt.radix -> Int24.int -> string (* @ $(SML_LIB)/basis/integer/embed-int.sml 96.11-96.13 *)
val Int24.fromInt: int -> Int24.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 84.11-84.17 *)
val Int24.fromLarge: LargeInt.int -> Int24.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 98.11-98.19 *)
val Int24.fromString: string -> Int24.int option (* @ $(SML_LIB)/basis/integer/embed-int.sml 100.11-100.20 *)
val Int24.max: Int24.int * Int24.int -> Int24.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 102.11-102.13 *)
val Int24.maxInt: Int24.int option (* @ $(SML_LIB)/basis/integer/embed-int.sml 56.11-56.16 *)
val Int24.min: Int24.int * Int24.int -> Int24.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 104.11-104.13 *)
val Int24.minInt: Int24.int option (* @ $(SML_LIB)/basis/integer/embed-int.sml 58.11-58.16 *)
val Int24.mod: Int24.int * Int24.int -> Int24.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 68.17-68.19 *)
val Int24.precision: int option (* @ $(SML_LIB)/basis/integer/embed-int.sml 39.11-39.19 *)
val Int24.quot: Int24.int * Int24.int -> Int24.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 69.14-69.17 *)
val Int24.rem: Int24.int * Int24.int -> Int24.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 70.14-70.16 *)
val Int24.sameSign: Int24.int * Int24.int -> bool (* @ $(SML_LIB)/basis/integer/embed-int.sml 113.11-113.18 *)
val Int24.scan: StringCvt.radix -> ('a -> (char * 'a) option) -> 'a -> (Int24.int * 'a) option (* @ $(SML_LIB)/basis/integer/embed-int.sml 106.11-106.14 *)
val Int24.sign: Int24.int -> int (* @ $(SML_LIB)/basis/integer/embed-int.sml 111.11-111.14 *)
val Int24.toInt: Int24.int -> int (* @ $(SML_LIB)/basis/integer/embed-int.sml 86.11-86.15 *)
val Int24.toLarge: Int24.int -> LargeInt.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 115.11-115.17 *)
val Int24.toString: Int24.int -> string (* @ $(SML_LIB)/basis/integer/embed-int.sml 117.11-117.18 *)
val Int24.~ : Int24.int -> Int24.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 92.14-92.14 *)
structure Int25: INTEGER where type int = Int25.int (* @ $(SML_LIB)/basis/libs/basis-extra/top-level/basis.sml 91.17-91.21 *)
type Int25.int = Int25.int (* @ $(SML_LIB)/basis/primitive/prim-basis.sml 193.12-193.14 *)
val Int25.* : Int25.int * Int25.int -> Int25.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 64.17-64.17 *)
val Int25.+ : Int25.int * Int25.int -> Int25.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 65.17-65.17 *)
val Int25.- : Int25.int * Int25.int -> Int25.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 66.17-66.17 *)
val Int25.< : Int25.int * Int25.int -> bool (* @ $(SML_LIB)/basis/integer/embed-int.sml 77.17-77.17 *)
val Int25.<= : Int25.int * Int25.int -> bool (* @ $(SML_LIB)/basis/integer/embed-int.sml 78.17-78.18 *)
val Int25.> : Int25.int * Int25.int -> bool (* @ $(SML_LIB)/basis/integer/embed-int.sml 79.17-79.17 *)
val Int25.>= : Int25.int * Int25.int -> bool (* @ $(SML_LIB)/basis/integer/embed-int.sml 80.17-80.18 *)
val Int25.abs: Int25.int -> Int25.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 93.14-93.16 *)
val Int25.compare: Int25.int * Int25.int -> order (* @ $(SML_LIB)/basis/integer/embed-int.sml 81.14-81.20 *)
val Int25.div: Int25.int * Int25.int -> Int25.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 67.17-67.19 *)
val Int25.fmt: StringCvt.radix -> Int25.int -> string (* @ $(SML_LIB)/basis/integer/embed-int.sml 96.11-96.13 *)
val Int25.fromInt: int -> Int25.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 84.11-84.17 *)
val Int25.fromLarge: LargeInt.int -> Int25.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 98.11-98.19 *)
val Int25.fromString: string -> Int25.int option (* @ $(SML_LIB)/basis/integer/embed-int.sml 100.11-100.20 *)
val Int25.max: Int25.int * Int25.int -> Int25.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 102.11-102.13 *)
val Int25.maxInt: Int25.int option (* @ $(SML_LIB)/basis/integer/embed-int.sml 56.11-56.16 *)
val Int25.min: Int25.int * Int25.int -> Int25.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 104.11-104.13 *)
val Int25.minInt: Int25.int option (* @ $(SML_LIB)/basis/integer/embed-int.sml 58.11-58.16 *)
val Int25.mod: Int25.int * Int25.int -> Int25.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 68.17-68.19 *)
val Int25.precision: int option (* @ $(SML_LIB)/basis/integer/embed-int.sml 39.11-39.19 *)
val Int25.quot: Int25.int * Int25.int -> Int25.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 69.14-69.17 *)
val Int25.rem: Int25.int * Int25.int -> Int25.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 70.14-70.16 *)
val Int25.sameSign: Int25.int * Int25.int -> bool (* @ $(SML_LIB)/basis/integer/embed-int.sml 113.11-113.18 *)
val Int25.scan: StringCvt.radix -> ('a -> (char * 'a) option) -> 'a -> (Int25.int * 'a) option (* @ $(SML_LIB)/basis/integer/embed-int.sml 106.11-106.14 *)
val Int25.sign: Int25.int -> int (* @ $(SML_LIB)/basis/integer/embed-int.sml 111.11-111.14 *)
val Int25.toInt: Int25.int -> int (* @ $(SML_LIB)/basis/integer/embed-int.sml 86.11-86.15 *)
val Int25.toLarge: Int25.int -> LargeInt.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 115.11-115.17 *)
val Int25.toString: Int25.int -> string (* @ $(SML_LIB)/basis/integer/embed-int.sml 117.11-117.18 *)
val Int25.~ : Int25.int -> Int25.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 92.14-92.14 *)
structure Int26: INTEGER where type int = Int26.int (* @ $(SML_LIB)/basis/libs/basis-extra/top-level/basis.sml 92.17-92.21 *)
type Int26.int = Int26.int (* @ $(SML_LIB)/basis/primitive/prim-basis.sml 198.12-198.14 *)
val Int26.* : Int26.int * Int26.int -> Int26.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 64.17-64.17 *)
val Int26.+ : Int26.int * Int26.int -> Int26.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 65.17-65.17 *)
val Int26.- : Int26.int * Int26.int -> Int26.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 66.17-66.17 *)
val Int26.< : Int26.int * Int26.int -> bool (* @ $(SML_LIB)/basis/integer/embed-int.sml 77.17-77.17 *)
val Int26.<= : Int26.int * Int26.int -> bool (* @ $(SML_LIB)/basis/integer/embed-int.sml 78.17-78.18 *)
val Int26.> : Int26.int * Int26.int -> bool (* @ $(SML_LIB)/basis/integer/embed-int.sml 79.17-79.17 *)
val Int26.>= : Int26.int * Int26.int -> bool (* @ $(SML_LIB)/basis/integer/embed-int.sml 80.17-80.18 *)
val Int26.abs: Int26.int -> Int26.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 93.14-93.16 *)
val Int26.compare: Int26.int * Int26.int -> order (* @ $(SML_LIB)/basis/integer/embed-int.sml 81.14-81.20 *)
val Int26.div: Int26.int * Int26.int -> Int26.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 67.17-67.19 *)
val Int26.fmt: StringCvt.radix -> Int26.int -> string (* @ $(SML_LIB)/basis/integer/embed-int.sml 96.11-96.13 *)
val Int26.fromInt: int -> Int26.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 84.11-84.17 *)
val Int26.fromLarge: LargeInt.int -> Int26.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 98.11-98.19 *)
val Int26.fromString: string -> Int26.int option (* @ $(SML_LIB)/basis/integer/embed-int.sml 100.11-100.20 *)
val Int26.max: Int26.int * Int26.int -> Int26.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 102.11-102.13 *)
val Int26.maxInt: Int26.int option (* @ $(SML_LIB)/basis/integer/embed-int.sml 56.11-56.16 *)
val Int26.min: Int26.int * Int26.int -> Int26.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 104.11-104.13 *)
val Int26.minInt: Int26.int option (* @ $(SML_LIB)/basis/integer/embed-int.sml 58.11-58.16 *)
val Int26.mod: Int26.int * Int26.int -> Int26.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 68.17-68.19 *)
val Int26.precision: int option (* @ $(SML_LIB)/basis/integer/embed-int.sml 39.11-39.19 *)
val Int26.quot: Int26.int * Int26.int -> Int26.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 69.14-69.17 *)
val Int26.rem: Int26.int * Int26.int -> Int26.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 70.14-70.16 *)
val Int26.sameSign: Int26.int * Int26.int -> bool (* @ $(SML_LIB)/basis/integer/embed-int.sml 113.11-113.18 *)
val Int26.scan: StringCvt.radix -> ('a -> (char * 'a) option) -> 'a -> (Int26.int * 'a) option (* @ $(SML_LIB)/basis/integer/embed-int.sml 106.11-106.14 *)
val Int26.sign: Int26.int -> int (* @ $(SML_LIB)/basis/integer/embed-int.sml 111.11-111.14 *)
val Int26.toInt: Int26.int -> int (* @ $(SML_LIB)/basis/integer/embed-int.sml 86.11-86.15 *)
val Int26.toLarge: Int26.int -> LargeInt.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 115.11-115.17 *)
val Int26.toString: Int26.int -> string (* @ $(SML_LIB)/basis/integer/embed-int.sml 117.11-117.18 *)
val Int26.~ : Int26.int -> Int26.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 92.14-92.14 *)
structure Int27: INTEGER where type int = Int27.int (* @ $(SML_LIB)/basis/libs/basis-extra/top-level/basis.sml 93.17-93.21 *)
type Int27.int = Int27.int (* @ $(SML_LIB)/basis/primitive/prim-basis.sml 203.12-203.14 *)
val Int27.* : Int27.int * Int27.int -> Int27.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 64.17-64.17 *)
val Int27.+ : Int27.int * Int27.int -> Int27.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 65.17-65.17 *)
val Int27.- : Int27.int * Int27.int -> Int27.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 66.17-66.17 *)
val Int27.< : Int27.int * Int27.int -> bool (* @ $(SML_LIB)/basis/integer/embed-int.sml 77.17-77.17 *)
val Int27.<= : Int27.int * Int27.int -> bool (* @ $(SML_LIB)/basis/integer/embed-int.sml 78.17-78.18 *)
val Int27.> : Int27.int * Int27.int -> bool (* @ $(SML_LIB)/basis/integer/embed-int.sml 79.17-79.17 *)
val Int27.>= : Int27.int * Int27.int -> bool (* @ $(SML_LIB)/basis/integer/embed-int.sml 80.17-80.18 *)
val Int27.abs: Int27.int -> Int27.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 93.14-93.16 *)
val Int27.compare: Int27.int * Int27.int -> order (* @ $(SML_LIB)/basis/integer/embed-int.sml 81.14-81.20 *)
val Int27.div: Int27.int * Int27.int -> Int27.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 67.17-67.19 *)
val Int27.fmt: StringCvt.radix -> Int27.int -> string (* @ $(SML_LIB)/basis/integer/embed-int.sml 96.11-96.13 *)
val Int27.fromInt: int -> Int27.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 84.11-84.17 *)
val Int27.fromLarge: LargeInt.int -> Int27.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 98.11-98.19 *)
val Int27.fromString: string -> Int27.int option (* @ $(SML_LIB)/basis/integer/embed-int.sml 100.11-100.20 *)
val Int27.max: Int27.int * Int27.int -> Int27.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 102.11-102.13 *)
val Int27.maxInt: Int27.int option (* @ $(SML_LIB)/basis/integer/embed-int.sml 56.11-56.16 *)
val Int27.min: Int27.int * Int27.int -> Int27.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 104.11-104.13 *)
val Int27.minInt: Int27.int option (* @ $(SML_LIB)/basis/integer/embed-int.sml 58.11-58.16 *)
val Int27.mod: Int27.int * Int27.int -> Int27.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 68.17-68.19 *)
val Int27.precision: int option (* @ $(SML_LIB)/basis/integer/embed-int.sml 39.11-39.19 *)
val Int27.quot: Int27.int * Int27.int -> Int27.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 69.14-69.17 *)
val Int27.rem: Int27.int * Int27.int -> Int27.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 70.14-70.16 *)
val Int27.sameSign: Int27.int * Int27.int -> bool (* @ $(SML_LIB)/basis/integer/embed-int.sml 113.11-113.18 *)
val Int27.scan: StringCvt.radix -> ('a -> (char * 'a) option) -> 'a -> (Int27.int * 'a) option (* @ $(SML_LIB)/basis/integer/embed-int.sml 106.11-106.14 *)
val Int27.sign: Int27.int -> int (* @ $(SML_LIB)/basis/integer/embed-int.sml 111.11-111.14 *)
val Int27.toInt: Int27.int -> int (* @ $(SML_LIB)/basis/integer/embed-int.sml 86.11-86.15 *)
val Int27.toLarge: Int27.int -> LargeInt.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 115.11-115.17 *)
val Int27.toString: Int27.int -> string (* @ $(SML_LIB)/basis/integer/embed-int.sml 117.11-117.18 *)
val Int27.~ : Int27.int -> Int27.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 92.14-92.14 *)
structure Int28: INTEGER where type int = Int28.int (* @ $(SML_LIB)/basis/libs/basis-extra/top-level/basis.sml 94.17-94.21 *)
type Int28.int = Int28.int (* @ $(SML_LIB)/basis/primitive/prim-basis.sml 208.12-208.14 *)
val Int28.* : Int28.int * Int28.int -> Int28.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 64.17-64.17 *)
val Int28.+ : Int28.int * Int28.int -> Int28.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 65.17-65.17 *)
val Int28.- : Int28.int * Int28.int -> Int28.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 66.17-66.17 *)
val Int28.< : Int28.int * Int28.int -> bool (* @ $(SML_LIB)/basis/integer/embed-int.sml 77.17-77.17 *)
val Int28.<= : Int28.int * Int28.int -> bool (* @ $(SML_LIB)/basis/integer/embed-int.sml 78.17-78.18 *)
val Int28.> : Int28.int * Int28.int -> bool (* @ $(SML_LIB)/basis/integer/embed-int.sml 79.17-79.17 *)
val Int28.>= : Int28.int * Int28.int -> bool (* @ $(SML_LIB)/basis/integer/embed-int.sml 80.17-80.18 *)
val Int28.abs: Int28.int -> Int28.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 93.14-93.16 *)
val Int28.compare: Int28.int * Int28.int -> order (* @ $(SML_LIB)/basis/integer/embed-int.sml 81.14-81.20 *)
val Int28.div: Int28.int * Int28.int -> Int28.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 67.17-67.19 *)
val Int28.fmt: StringCvt.radix -> Int28.int -> string (* @ $(SML_LIB)/basis/integer/embed-int.sml 96.11-96.13 *)
val Int28.fromInt: int -> Int28.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 84.11-84.17 *)
val Int28.fromLarge: LargeInt.int -> Int28.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 98.11-98.19 *)
val Int28.fromString: string -> Int28.int option (* @ $(SML_LIB)/basis/integer/embed-int.sml 100.11-100.20 *)
val Int28.max: Int28.int * Int28.int -> Int28.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 102.11-102.13 *)
val Int28.maxInt: Int28.int option (* @ $(SML_LIB)/basis/integer/embed-int.sml 56.11-56.16 *)
val Int28.min: Int28.int * Int28.int -> Int28.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 104.11-104.13 *)
val Int28.minInt: Int28.int option (* @ $(SML_LIB)/basis/integer/embed-int.sml 58.11-58.16 *)
val Int28.mod: Int28.int * Int28.int -> Int28.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 68.17-68.19 *)
val Int28.precision: int option (* @ $(SML_LIB)/basis/integer/embed-int.sml 39.11-39.19 *)
val Int28.quot: Int28.int * Int28.int -> Int28.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 69.14-69.17 *)
val Int28.rem: Int28.int * Int28.int -> Int28.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 70.14-70.16 *)
val Int28.sameSign: Int28.int * Int28.int -> bool (* @ $(SML_LIB)/basis/integer/embed-int.sml 113.11-113.18 *)
val Int28.scan: StringCvt.radix -> ('a -> (char * 'a) option) -> 'a -> (Int28.int * 'a) option (* @ $(SML_LIB)/basis/integer/embed-int.sml 106.11-106.14 *)
val Int28.sign: Int28.int -> int (* @ $(SML_LIB)/basis/integer/embed-int.sml 111.11-111.14 *)
val Int28.toInt: Int28.int -> int (* @ $(SML_LIB)/basis/integer/embed-int.sml 86.11-86.15 *)
val Int28.toLarge: Int28.int -> LargeInt.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 115.11-115.17 *)
val Int28.toString: Int28.int -> string (* @ $(SML_LIB)/basis/integer/embed-int.sml 117.11-117.18 *)
val Int28.~ : Int28.int -> Int28.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 92.14-92.14 *)
structure Int29: INTEGER where type int = Int29.int (* @ $(SML_LIB)/basis/libs/basis-extra/top-level/basis.sml 95.17-95.21 *)
type Int29.int = Int29.int (* @ $(SML_LIB)/basis/primitive/prim-basis.sml 213.12-213.14 *)
val Int29.* : Int29.int * Int29.int -> Int29.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 64.17-64.17 *)
val Int29.+ : Int29.int * Int29.int -> Int29.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 65.17-65.17 *)
val Int29.- : Int29.int * Int29.int -> Int29.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 66.17-66.17 *)
val Int29.< : Int29.int * Int29.int -> bool (* @ $(SML_LIB)/basis/integer/embed-int.sml 77.17-77.17 *)
val Int29.<= : Int29.int * Int29.int -> bool (* @ $(SML_LIB)/basis/integer/embed-int.sml 78.17-78.18 *)
val Int29.> : Int29.int * Int29.int -> bool (* @ $(SML_LIB)/basis/integer/embed-int.sml 79.17-79.17 *)
val Int29.>= : Int29.int * Int29.int -> bool (* @ $(SML_LIB)/basis/integer/embed-int.sml 80.17-80.18 *)
val Int29.abs: Int29.int -> Int29.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 93.14-93.16 *)
val Int29.compare: Int29.int * Int29.int -> order (* @ $(SML_LIB)/basis/integer/embed-int.sml 81.14-81.20 *)
val Int29.div: Int29.int * Int29.int -> Int29.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 67.17-67.19 *)
val Int29.fmt: StringCvt.radix -> Int29.int -> string (* @ $(SML_LIB)/basis/integer/embed-int.sml 96.11-96.13 *)
val Int29.fromInt: int -> Int29.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 84.11-84.17 *)
val Int29.fromLarge: LargeInt.int -> Int29.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 98.11-98.19 *)
val Int29.fromString: string -> Int29.int option (* @ $(SML_LIB)/basis/integer/embed-int.sml 100.11-100.20 *)
val Int29.max: Int29.int * Int29.int -> Int29.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 102.11-102.13 *)
val Int29.maxInt: Int29.int option (* @ $(SML_LIB)/basis/integer/embed-int.sml 56.11-56.16 *)
val Int29.min: Int29.int * Int29.int -> Int29.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 104.11-104.13 *)
val Int29.minInt: Int29.int option (* @ $(SML_LIB)/basis/integer/embed-int.sml 58.11-58.16 *)
val Int29.mod: Int29.int * Int29.int -> Int29.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 68.17-68.19 *)
val Int29.precision: int option (* @ $(SML_LIB)/basis/integer/embed-int.sml 39.11-39.19 *)
val Int29.quot: Int29.int * Int29.int -> Int29.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 69.14-69.17 *)
val Int29.rem: Int29.int * Int29.int -> Int29.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 70.14-70.16 *)
val Int29.sameSign: Int29.int * Int29.int -> bool (* @ $(SML_LIB)/basis/integer/embed-int.sml 113.11-113.18 *)
val Int29.scan: StringCvt.radix -> ('a -> (char * 'a) option) -> 'a -> (Int29.int * 'a) option (* @ $(SML_LIB)/basis/integer/embed-int.sml 106.11-106.14 *)
val Int29.sign: Int29.int -> int (* @ $(SML_LIB)/basis/integer/embed-int.sml 111.11-111.14 *)
val Int29.toInt: Int29.int -> int (* @ $(SML_LIB)/basis/integer/embed-int.sml 86.11-86.15 *)
val Int29.toLarge: Int29.int -> LargeInt.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 115.11-115.17 *)
val Int29.toString: Int29.int -> string (* @ $(SML_LIB)/basis/integer/embed-int.sml 117.11-117.18 *)
val Int29.~ : Int29.int -> Int29.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 92.14-92.14 *)
structure Int3: INTEGER where type int = Int3.int (* @ $(SML_LIB)/basis/libs/basis-extra/top-level/basis.sml 68.17-68.20 *)
type Int3.int = Int3.int (* @ $(SML_LIB)/basis/primitive/prim-basis.sml 83.12-83.14 *)
val Int3.* : Int3.int * Int3.int -> Int3.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 64.17-64.17 *)
val Int3.+ : Int3.int * Int3.int -> Int3.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 65.17-65.17 *)
val Int3.- : Int3.int * Int3.int -> Int3.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 66.17-66.17 *)
val Int3.< : Int3.int * Int3.int -> bool (* @ $(SML_LIB)/basis/integer/embed-int.sml 77.17-77.17 *)
val Int3.<= : Int3.int * Int3.int -> bool (* @ $(SML_LIB)/basis/integer/embed-int.sml 78.17-78.18 *)
val Int3.> : Int3.int * Int3.int -> bool (* @ $(SML_LIB)/basis/integer/embed-int.sml 79.17-79.17 *)
val Int3.>= : Int3.int * Int3.int -> bool (* @ $(SML_LIB)/basis/integer/embed-int.sml 80.17-80.18 *)
val Int3.abs: Int3.int -> Int3.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 93.14-93.16 *)
val Int3.compare: Int3.int * Int3.int -> order (* @ $(SML_LIB)/basis/integer/embed-int.sml 81.14-81.20 *)
val Int3.div: Int3.int * Int3.int -> Int3.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 67.17-67.19 *)
val Int3.fmt: StringCvt.radix -> Int3.int -> string (* @ $(SML_LIB)/basis/integer/embed-int.sml 96.11-96.13 *)
val Int3.fromInt: int -> Int3.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 84.11-84.17 *)
val Int3.fromLarge: LargeInt.int -> Int3.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 98.11-98.19 *)
val Int3.fromString: string -> Int3.int option (* @ $(SML_LIB)/basis/integer/embed-int.sml 100.11-100.20 *)
val Int3.max: Int3.int * Int3.int -> Int3.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 102.11-102.13 *)
val Int3.maxInt: Int3.int option (* @ $(SML_LIB)/basis/integer/embed-int.sml 56.11-56.16 *)
val Int3.min: Int3.int * Int3.int -> Int3.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 104.11-104.13 *)
val Int3.minInt: Int3.int option (* @ $(SML_LIB)/basis/integer/embed-int.sml 58.11-58.16 *)
val Int3.mod: Int3.int * Int3.int -> Int3.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 68.17-68.19 *)
val Int3.precision: int option (* @ $(SML_LIB)/basis/integer/embed-int.sml 39.11-39.19 *)
val Int3.quot: Int3.int * Int3.int -> Int3.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 69.14-69.17 *)
val Int3.rem: Int3.int * Int3.int -> Int3.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 70.14-70.16 *)
val Int3.sameSign: Int3.int * Int3.int -> bool (* @ $(SML_LIB)/basis/integer/embed-int.sml 113.11-113.18 *)
val Int3.scan: StringCvt.radix -> ('a -> (char * 'a) option) -> 'a -> (Int3.int * 'a) option (* @ $(SML_LIB)/basis/integer/embed-int.sml 106.11-106.14 *)
val Int3.sign: Int3.int -> int (* @ $(SML_LIB)/basis/integer/embed-int.sml 111.11-111.14 *)
val Int3.toInt: Int3.int -> int (* @ $(SML_LIB)/basis/integer/embed-int.sml 86.11-86.15 *)
val Int3.toLarge: Int3.int -> LargeInt.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 115.11-115.17 *)
val Int3.toString: Int3.int -> string (* @ $(SML_LIB)/basis/integer/embed-int.sml 117.11-117.18 *)
val Int3.~ : Int3.int -> Int3.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 92.14-92.14 *)
structure Int30: INTEGER where type int = Int30.int (* @ $(SML_LIB)/basis/libs/basis-extra/top-level/basis.sml 96.17-96.21 *)
type Int30.int = Int30.int (* @ $(SML_LIB)/basis/primitive/prim-basis.sml 218.12-218.14 *)
val Int30.* : Int30.int * Int30.int -> Int30.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 64.17-64.17 *)
val Int30.+ : Int30.int * Int30.int -> Int30.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 65.17-65.17 *)
val Int30.- : Int30.int * Int30.int -> Int30.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 66.17-66.17 *)
val Int30.< : Int30.int * Int30.int -> bool (* @ $(SML_LIB)/basis/integer/embed-int.sml 77.17-77.17 *)
val Int30.<= : Int30.int * Int30.int -> bool (* @ $(SML_LIB)/basis/integer/embed-int.sml 78.17-78.18 *)
val Int30.> : Int30.int * Int30.int -> bool (* @ $(SML_LIB)/basis/integer/embed-int.sml 79.17-79.17 *)
val Int30.>= : Int30.int * Int30.int -> bool (* @ $(SML_LIB)/basis/integer/embed-int.sml 80.17-80.18 *)
val Int30.abs: Int30.int -> Int30.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 93.14-93.16 *)
val Int30.compare: Int30.int * Int30.int -> order (* @ $(SML_LIB)/basis/integer/embed-int.sml 81.14-81.20 *)
val Int30.div: Int30.int * Int30.int -> Int30.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 67.17-67.19 *)
val Int30.fmt: StringCvt.radix -> Int30.int -> string (* @ $(SML_LIB)/basis/integer/embed-int.sml 96.11-96.13 *)
val Int30.fromInt: int -> Int30.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 84.11-84.17 *)
val Int30.fromLarge: LargeInt.int -> Int30.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 98.11-98.19 *)
val Int30.fromString: string -> Int30.int option (* @ $(SML_LIB)/basis/integer/embed-int.sml 100.11-100.20 *)
val Int30.max: Int30.int * Int30.int -> Int30.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 102.11-102.13 *)
val Int30.maxInt: Int30.int option (* @ $(SML_LIB)/basis/integer/embed-int.sml 56.11-56.16 *)
val Int30.min: Int30.int * Int30.int -> Int30.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 104.11-104.13 *)
val Int30.minInt: Int30.int option (* @ $(SML_LIB)/basis/integer/embed-int.sml 58.11-58.16 *)
val Int30.mod: Int30.int * Int30.int -> Int30.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 68.17-68.19 *)
val Int30.precision: int option (* @ $(SML_LIB)/basis/integer/embed-int.sml 39.11-39.19 *)
val Int30.quot: Int30.int * Int30.int -> Int30.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 69.14-69.17 *)
val Int30.rem: Int30.int * Int30.int -> Int30.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 70.14-70.16 *)
val Int30.sameSign: Int30.int * Int30.int -> bool (* @ $(SML_LIB)/basis/integer/embed-int.sml 113.11-113.18 *)
val Int30.scan: StringCvt.radix -> ('a -> (char * 'a) option) -> 'a -> (Int30.int * 'a) option (* @ $(SML_LIB)/basis/integer/embed-int.sml 106.11-106.14 *)
val Int30.sign: Int30.int -> int (* @ $(SML_LIB)/basis/integer/embed-int.sml 111.11-111.14 *)
val Int30.toInt: Int30.int -> int (* @ $(SML_LIB)/basis/integer/embed-int.sml 86.11-86.15 *)
val Int30.toLarge: Int30.int -> LargeInt.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 115.11-115.17 *)
val Int30.toString: Int30.int -> string (* @ $(SML_LIB)/basis/integer/embed-int.sml 117.11-117.18 *)
val Int30.~ : Int30.int -> Int30.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 92.14-92.14 *)
structure Int31: INTEGER where type int = Int31.int (* @ $(SML_LIB)/basis/libs/basis-extra/top-level/basis.sml 97.17-97.21 *)
type Int31.int = Int31.int (* @ $(SML_LIB)/basis/primitive/prim-basis.sml 223.12-223.14 *)
val Int31.* : Int31.int * Int31.int -> Int31.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 64.17-64.17 *)
val Int31.+ : Int31.int * Int31.int -> Int31.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 65.17-65.17 *)
val Int31.- : Int31.int * Int31.int -> Int31.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 66.17-66.17 *)
val Int31.< : Int31.int * Int31.int -> bool (* @ $(SML_LIB)/basis/integer/embed-int.sml 77.17-77.17 *)
val Int31.<= : Int31.int * Int31.int -> bool (* @ $(SML_LIB)/basis/integer/embed-int.sml 78.17-78.18 *)
val Int31.> : Int31.int * Int31.int -> bool (* @ $(SML_LIB)/basis/integer/embed-int.sml 79.17-79.17 *)
val Int31.>= : Int31.int * Int31.int -> bool (* @ $(SML_LIB)/basis/integer/embed-int.sml 80.17-80.18 *)
val Int31.abs: Int31.int -> Int31.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 93.14-93.16 *)
val Int31.compare: Int31.int * Int31.int -> order (* @ $(SML_LIB)/basis/integer/embed-int.sml 81.14-81.20 *)
val Int31.div: Int31.int * Int31.int -> Int31.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 67.17-67.19 *)
val Int31.fmt: StringCvt.radix -> Int31.int -> string (* @ $(SML_LIB)/basis/integer/embed-int.sml 96.11-96.13 *)
val Int31.fromInt: int -> Int31.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 84.11-84.17 *)
val Int31.fromLarge: LargeInt.int -> Int31.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 98.11-98.19 *)
val Int31.fromString: string -> Int31.int option (* @ $(SML_LIB)/basis/integer/embed-int.sml 100.11-100.20 *)
val Int31.max: Int31.int * Int31.int -> Int31.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 102.11-102.13 *)
val Int31.maxInt: Int31.int option (* @ $(SML_LIB)/basis/integer/embed-int.sml 56.11-56.16 *)
val Int31.min: Int31.int * Int31.int -> Int31.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 104.11-104.13 *)
val Int31.minInt: Int31.int option (* @ $(SML_LIB)/basis/integer/embed-int.sml 58.11-58.16 *)
val Int31.mod: Int31.int * Int31.int -> Int31.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 68.17-68.19 *)
val Int31.precision: int option (* @ $(SML_LIB)/basis/integer/embed-int.sml 39.11-39.19 *)
val Int31.quot: Int31.int * Int31.int -> Int31.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 69.14-69.17 *)
val Int31.rem: Int31.int * Int31.int -> Int31.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 70.14-70.16 *)
val Int31.sameSign: Int31.int * Int31.int -> bool (* @ $(SML_LIB)/basis/integer/embed-int.sml 113.11-113.18 *)
val Int31.scan: StringCvt.radix -> ('a -> (char * 'a) option) -> 'a -> (Int31.int * 'a) option (* @ $(SML_LIB)/basis/integer/embed-int.sml 106.11-106.14 *)
val Int31.sign: Int31.int -> int (* @ $(SML_LIB)/basis/integer/embed-int.sml 111.11-111.14 *)
val Int31.toInt: Int31.int -> int (* @ $(SML_LIB)/basis/integer/embed-int.sml 86.11-86.15 *)
val Int31.toLarge: Int31.int -> LargeInt.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 115.11-115.17 *)
val Int31.toString: Int31.int -> string (* @ $(SML_LIB)/basis/integer/embed-int.sml 117.11-117.18 *)
val Int31.~ : Int31.int -> Int31.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 92.14-92.14 *)
structure Int32: INTEGER where type int = int (* @ $(SML_LIB)/basis/libs/basis-2002/top-level/top-level.sml 78.11-78.15 *)
type Int32.int = int (* @ $(SML_LIB)/basis/primitive/prim-basis.sml 228.12-228.14 *)
val Int32.* : int * int -> int (* @ $(SML_LIB)/basis/primitive/prim-int.sml 391.11-391.11 *)
val Int32.+ : int * int -> int (* @ $(SML_LIB)/basis/primitive/prim-int.sml 385.11-385.11 *)
val Int32.- : int * int -> int (* @ $(SML_LIB)/basis/primitive/prim-int.sml 404.11-404.11 *)
val Int32.< : int * int -> bool (* @ $(SML_LIB)/basis/util/integral-comparisons.sml 11.11-11.11 *)
val Int32.<= : int * int -> bool (* @ $(SML_LIB)/basis/util/integral-comparisons.sml 12.11-12.12 *)
val Int32.> : int * int -> bool (* @ $(SML_LIB)/basis/util/integral-comparisons.sml 13.11-13.11 *)
val Int32.>= : int * int -> bool (* @ $(SML_LIB)/basis/util/integral-comparisons.sml 14.11-14.12 *)
val Int32.abs: int -> int (* @ $(SML_LIB)/basis/integer/num0.sml 161.17-161.19 *)
val Int32.compare: int * int -> order (* @ $(SML_LIB)/basis/util/integral-comparisons.sml 16.11-16.17 *)
val Int32.div: int * int -> int (* @ $(SML_LIB)/basis/integer/num0.sml 183.19-183.21 *)
val Int32.fmt: StringCvt.radix -> int -> string (* @ $(SML_LIB)/basis/integer/int.sml 74.8-74.10 *)
val Int32.fromInt: int -> int (* @ $(SML_LIB)/basis/integer/int.sml 46.5-46.11 *)
val Int32.fromLarge: LargeInt.int -> int (* @ $(SML_LIB)/basis/integer/int.sml 51.5-51.13 *)
val Int32.fromString: string -> int option (* @ $(SML_LIB)/basis/integer/int.sml 165.5-165.14 *)
val Int32.max: int * int -> int (* @ $(SML_LIB)/basis/util/integral-comparisons.sml 21.11-21.13 *)
val Int32.maxInt: int option (* @ $(SML_LIB)/basis/integer/int.sml 19.5-19.10 *)
val Int32.min: int * int -> int (* @ $(SML_LIB)/basis/util/integral-comparisons.sml 20.11-20.13 *)
val Int32.minInt: int option (* @ $(SML_LIB)/basis/integer/int.sml 20.5-20.10 *)
val Int32.mod: int * int -> int (* @ $(SML_LIB)/basis/integer/num0.sml 204.19-204.21 *)
val Int32.precision: int option (* @ $(SML_LIB)/basis/integer/int.sml 16.5-16.13 *)
val Int32.quot: int * int -> int (* @ $(SML_LIB)/basis/integer/num0.sml 163.17-163.20 *)
val Int32.rem: int * int -> int (* @ $(SML_LIB)/basis/integer/num0.sml 175.17-175.19 *)
val Int32.sameSign: int * int -> bool (* @ $(SML_LIB)/basis/integer/int.sml 29.5-29.12 *)
val Int32.scan: StringCvt.radix -> ('a -> (char * 'a) option) -> 'a -> (int * 'a) option (* @ $(SML_LIB)/basis/integer/int.sml 112.5-112.8 *)
val Int32.sign: int -> int (* @ $(SML_LIB)/basis/integer/int.sml 22.5-22.8 *)
val Int32.toInt: int -> int (* @ $(SML_LIB)/basis/integer/int.sml 47.5-47.9 *)
val Int32.toLarge: int -> LargeInt.int (* @ $(SML_LIB)/basis/integer/int.sml 52.5-52.11 *)
val Int32.toString: int -> string (* @ $(SML_LIB)/basis/integer/int.sml 110.5-110.12 *)
val Int32.~ : int -> int (* @ $(SML_LIB)/basis/primitive/prim-int.sml 397.11-397.11 *)
structure Int32Array: MONO_ARRAY where type array = Int32Array.array where type elem = int where type vector = Int32Vector.vector (* @ $(SML_LIB)/basis/libs/basis-2002/top-level/top-level.sml 31.11-31.20 *)
type Int32Array.array = Int32Array.array (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array.fun 23.12-23.16 *)
type Int32Array.elem = int (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array.fun 22.12-22.15 *)
type Int32Array.vector = Int32Vector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array.fun 24.12-24.17 *)
val Int32Array.all: (int -> bool) -> Int32Array.array -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 476.13-476.15 *)
val Int32Array.app: (int -> unit) -> Int32Array.array -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 464.13-464.15 *)
val Int32Array.appi: (int * int -> unit) -> Int32Array.array -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 463.13-463.16 *)
val Int32Array.array: int * int -> Int32Array.array (* @ $(SML_LIB)/basis/arrays-and-vectors/array.sml 34.11-34.15 *)
val Int32Array.collate: (int * int -> order) -> Int32Array.array * Int32Array.array -> order (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 477.13-477.19 *)
val Int32Array.copy: {di: int, dst: Int32Array.array, src: Int32Array.array} -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 457.13-457.16 *)
val Int32Array.copyVec: {di: int, dst: Int32Array.array, src: Int32Vector.vector} -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array.sml 37.11-37.17 *)
val Int32Array.exists: (int -> bool) -> Int32Array.array -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 474.13-474.18 *)
val Int32Array.find: (int -> bool) -> Int32Array.array -> int option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 472.13-472.16 *)
val Int32Array.findi: (int * int -> bool) -> Int32Array.array -> (int * int) option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 471.13-471.17 *)
val Int32Array.foldl: (int * 'a -> 'a) -> 'a -> Int32Array.array -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 468.13-468.17 *)
val Int32Array.foldli: (int * int * 'a -> 'a) -> 'a -> Int32Array.array -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 467.13-467.18 *)
val Int32Array.foldr: (int * 'a -> 'a) -> 'a -> Int32Array.array -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 470.13-470.17 *)
val Int32Array.foldri: (int * int * 'a -> 'a) -> 'a -> Int32Array.array -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 469.13-469.18 *)
val Int32Array.fromList: int list -> Int32Array.array (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 122.11-122.18 *)
val Int32Array.length: Int32Array.array -> int (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 90.11-90.16 *)
val Int32Array.maxLen: int (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 88.11-88.16 *)
val Int32Array.modify: (int -> int) -> Int32Array.array -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array.sml 40.11-40.16 *)
val Int32Array.modifyi: (int * int -> int) -> Int32Array.array -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array.sml 39.11-39.17 *)
val Int32Array.sub: Int32Array.array * int -> int (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 450.13-450.15 *)
val Int32Array.tabulate: int * (int -> int) -> Int32Array.array (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 114.11-114.18 *)
val Int32Array.update: Int32Array.array * int * int -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 452.13-452.18 *)
val Int32Array.vector: Int32Array.array -> Int32Vector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/array.sml 36.11-36.16 *)
structure Int32Array2: MONO_ARRAY2 where type array = Int32Array2.array where type elem = int where type vector = Int32Vector.vector (* @ $(SML_LIB)/basis/libs/basis-2002/top-level/top-level.sml 32.11-32.21 *)
type Int32Array2.array = Int32Array2.array (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array2.fun 18.12-18.16 *)
type Int32Array2.elem = int (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array2.fun 15.12-15.15 *)
type Int32Array2.region = {base: Int32Array2.array, col: int, ncols: int option, nrows: int option, row: int} (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array2.fun 19.12-19.17 *)
datatype Int32Array2.traversal = ColMajor | RowMajor (* = datatype Array2.traversal *) (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 106.16-106.24 *)
type Int32Array2.vector = Int32Vector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array2.fun 16.12-16.17 *)
con Int32Array2.ColMajor: Array2.traversal (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 106.39-106.46 *)
con Int32Array2.RowMajor: Array2.traversal (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 106.28-106.35 *)
val Int32Array2.app: Array2.traversal -> (int -> unit) -> Int32Array2.array -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 294.11-294.13 *)
val Int32Array2.appi: Array2.traversal -> (int * int * int -> unit) -> {base: Int32Array2.array, col: int, ncols: int option, nrows: int option, row: int} -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 291.11-291.14 *)
val Int32Array2.array: int * int * int -> Int32Array2.array (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 140.14-140.18 *)
val Int32Array2.column: Int32Array2.array * int -> Int32Vector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 237.11-237.16 *)
val Int32Array2.copy: {dst: Int32Array2.array, dst_col: int, dst_row: int, src: {base: Int32Array2.array, col: int, ncols: int option, nrows: int option, row: int}} -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 309.11-309.14 *)
val Int32Array2.dimensions: Int32Array2.array -> int * int (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 33.11-33.20 *)
val Int32Array2.fold: Array2.traversal -> (int * 'a -> 'a) -> 'a -> Int32Array2.array -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 288.11-288.14 *)
val Int32Array2.foldi: Array2.traversal -> (int * int * int * 'a -> 'a) -> 'a -> {base: Int32Array2.array, col: int, ncols: int option, nrows: int option, row: int} -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 283.11-283.15 *)
val Int32Array2.fromList: int list list -> Int32Array2.array (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 188.14-188.21 *)
val Int32Array2.modify: Array2.traversal -> (int -> int) -> Int32Array2.array -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 299.11-299.16 *)
val Int32Array2.modifyi: Array2.traversal -> (int * int * int -> int) -> {base: Int32Array2.array, col: int, ncols: int option, nrows: int option, row: int} -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 296.11-296.17 *)
val Int32Array2.nCols: Int32Array2.array -> int (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 38.11-38.15 *)
val Int32Array2.nRows: Int32Array2.array -> int (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 36.11-36.15 *)
val Int32Array2.row: Int32Array2.array * int -> Int32Vector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 222.11-222.13 *)
val Int32Array2.sub: Int32Array2.array * int * int -> int (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 182.14-182.16 *)
val Int32Array2.tabulate: Array2.traversal -> int * int * (int * int -> int) -> Int32Array2.array (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 301.11-301.18 *)
val Int32Array2.update: Int32Array2.array * int * int * int -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 184.14-184.19 *)
structure Int32ArraySlice: MONO_ARRAY_SLICE where type array = Int32Array.array where type elem = int where type slice = Int32ArraySlice.slice where type vector = Int32Vector.vector where type vector_slice = Int32VectorSlice.slice (* @ $(SML_LIB)/basis/libs/basis-extra/top-level/basis.sml 117.17-117.31 *)
type Int32ArraySlice.array = Int32Array.array (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array.fun 35.18-35.22 *)
type Int32ArraySlice.elem = int (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array.fun 34.18-34.21 *)
type Int32ArraySlice.slice = Int32ArraySlice.slice (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array.fun 36.18-36.22 *)
type Int32ArraySlice.vector = Int32Vector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array.fun 37.18-37.23 *)
type Int32ArraySlice.vector_slice = Int32VectorSlice.slice (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array.fun 38.18-38.29 *)
val Int32ArraySlice.all: (int -> bool) -> Int32ArraySlice.slice -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 235.17-235.19 *)
val Int32ArraySlice.app: (int -> unit) -> Int32ArraySlice.slice -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 226.17-226.19 *)
val Int32ArraySlice.appi: (int * int -> unit) -> Int32ArraySlice.slice -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 225.17-225.20 *)
val Int32ArraySlice.base: Int32ArraySlice.slice -> Int32Array.array * int * int (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 208.17-208.20 *)
val Int32ArraySlice.collate: (int * int -> order) -> Int32ArraySlice.slice * Int32ArraySlice.slice -> order (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 236.17-236.23 *)
val Int32ArraySlice.copy: {di: int, dst: Int32Array.array, src: Int32ArraySlice.slice} -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 185.17-185.20 *)
val Int32ArraySlice.copyVec: {di: int, dst: Int32Array.array, src: Int32VectorSlice.slice} -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array.sml 28.17-28.23 *)
val Int32ArraySlice.exists: (int -> bool) -> Int32ArraySlice.slice -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 233.17-233.22 *)
val Int32ArraySlice.find: (int -> bool) -> Int32ArraySlice.slice -> int option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 231.17-231.20 *)
val Int32ArraySlice.findi: (int * int -> bool) -> Int32ArraySlice.slice -> (int * int) option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 229.17-229.21 *)
val Int32ArraySlice.foldl: (int * 'a -> 'a) -> 'a -> Int32ArraySlice.slice -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 223.17-223.21 *)
val Int32ArraySlice.foldli: (int * int * 'a -> 'a) -> 'a -> Int32ArraySlice.slice -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 221.17-221.22 *)
val Int32ArraySlice.foldr: (int * 'a -> 'a) -> 'a -> Int32ArraySlice.slice -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 224.17-224.21 *)
val Int32ArraySlice.foldri: (int * int * 'a -> 'a) -> 'a -> Int32ArraySlice.slice -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 222.17-222.22 *)
val Int32ArraySlice.full: Int32Array.array -> Int32ArraySlice.slice (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 192.17-192.20 *)
val Int32ArraySlice.getItem: Int32ArraySlice.slice -> (int * Int32ArraySlice.slice) option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 220.17-220.23 *)
val Int32ArraySlice.isEmpty: Int32ArraySlice.slice -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 219.17-219.23 *)
val Int32ArraySlice.length: Int32ArraySlice.slice -> int (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 134.17-134.22 *)
val Int32ArraySlice.modify: (int -> int) -> Int32ArraySlice.slice -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array.sml 31.17-31.22 *)
val Int32ArraySlice.modifyi: (int * int -> int) -> Int32ArraySlice.slice -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array.sml 30.17-30.23 *)
val Int32ArraySlice.slice: Int32Array.array * int * int option -> Int32ArraySlice.slice (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 206.17-206.21 *)
val Int32ArraySlice.sub: Int32ArraySlice.slice * int -> int (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 142.17-142.19 *)
val Int32ArraySlice.subslice: Int32ArraySlice.slice * int * int option -> Int32ArraySlice.slice (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 199.17-199.24 *)
val Int32ArraySlice.update: Int32ArraySlice.slice * int * int -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 155.17-155.22 *)
val Int32ArraySlice.vector: Int32ArraySlice.slice -> Int32Vector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/array.sml 27.17-27.22 *)
structure Int32Vector: MONO_VECTOR where type elem = int where type vector = Int32Vector.vector (* @ $(SML_LIB)/basis/libs/basis-2002/top-level/top-level.sml 33.11-33.21 *)
type Int32Vector.elem = int (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-vector.fun 35.12-35.15 *)
type Int32Vector.vector = Int32Vector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-vector.fun 36.12-36.17 *)
val Int32Vector.all: (int -> bool) -> Int32Vector.vector -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 476.13-476.15 *)
val Int32Vector.app: (int -> unit) -> Int32Vector.vector -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 464.13-464.15 *)
val Int32Vector.appi: (int * int -> unit) -> Int32Vector.vector -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 463.13-463.16 *)
val Int32Vector.collate: (int * int -> order) -> Int32Vector.vector * Int32Vector.vector -> order (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 477.13-477.19 *)
val Int32Vector.concat: Int32Vector.vector list -> Int32Vector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 462.13-462.18 *)
val Int32Vector.exists: (int -> bool) -> Int32Vector.vector -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 474.13-474.18 *)
val Int32Vector.find: (int -> bool) -> Int32Vector.vector -> int option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 472.13-472.16 *)
val Int32Vector.findi: (int * int -> bool) -> Int32Vector.vector -> (int * int) option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 471.13-471.17 *)
val Int32Vector.foldl: (int * 'a -> 'a) -> 'a -> Int32Vector.vector -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 468.13-468.17 *)
val Int32Vector.foldli: (int * int * 'a -> 'a) -> 'a -> Int32Vector.vector -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 467.13-467.18 *)
val Int32Vector.foldr: (int * 'a -> 'a) -> 'a -> Int32Vector.vector -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 470.13-470.17 *)
val Int32Vector.foldri: (int * int * 'a -> 'a) -> 'a -> Int32Vector.vector -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 469.13-469.18 *)
val Int32Vector.fromList: int list -> Int32Vector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 122.11-122.18 *)
val Int32Vector.length: Int32Vector.vector -> int (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 90.11-90.16 *)
val Int32Vector.map: (int -> int) -> Int32Vector.vector -> Int32Vector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 466.13-466.15 *)
val Int32Vector.mapi: (int * int -> int) -> Int32Vector.vector -> Int32Vector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 465.13-465.16 *)
val Int32Vector.maxLen: int (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 88.11-88.16 *)
val Int32Vector.sub: Int32Vector.vector * int -> int (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 450.13-450.15 *)
val Int32Vector.tabulate: int * (int -> int) -> Int32Vector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 114.11-114.18 *)
val Int32Vector.update: Int32Vector.vector * int * int -> Int32Vector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/vector.sml 30.11-30.16 *)
structure Int32VectorSlice: MONO_VECTOR_SLICE where type elem = int where type slice = Int32VectorSlice.slice where type vector = Int32Vector.vector (* @ $(SML_LIB)/basis/libs/basis-extra/top-level/basis.sml 119.17-119.32 *)
type Int32VectorSlice.elem = int (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-vector.fun 43.18-43.21 *)
type Int32VectorSlice.slice = Int32VectorSlice.slice (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-vector.fun 45.18-45.22 *)
type Int32VectorSlice.vector = Int32Vector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-vector.fun 44.18-44.23 *)
val Int32VectorSlice.all: (int -> bool) -> Int32VectorSlice.slice -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 235.17-235.19 *)
val Int32VectorSlice.app: (int -> unit) -> Int32VectorSlice.slice -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 226.17-226.19 *)
val Int32VectorSlice.appi: (int * int -> unit) -> Int32VectorSlice.slice -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 225.17-225.20 *)
val Int32VectorSlice.base: Int32VectorSlice.slice -> Int32Vector.vector * int * int (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 208.17-208.20 *)
val Int32VectorSlice.collate: (int * int -> order) -> Int32VectorSlice.slice * Int32VectorSlice.slice -> order (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 236.17-236.23 *)
val Int32VectorSlice.concat: Int32VectorSlice.slice list -> Int32Vector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 240.17-240.22 *)
val Int32VectorSlice.exists: (int -> bool) -> Int32VectorSlice.slice -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 233.17-233.22 *)
val Int32VectorSlice.find: (int -> bool) -> Int32VectorSlice.slice -> int option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 231.17-231.20 *)
val Int32VectorSlice.findi: (int * int -> bool) -> Int32VectorSlice.slice -> (int * int) option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 229.17-229.21 *)
val Int32VectorSlice.foldl: (int * 'a -> 'a) -> 'a -> Int32VectorSlice.slice -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 223.17-223.21 *)
val Int32VectorSlice.foldli: (int * int * 'a -> 'a) -> 'a -> Int32VectorSlice.slice -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 221.17-221.22 *)
val Int32VectorSlice.foldr: (int * 'a -> 'a) -> 'a -> Int32VectorSlice.slice -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 224.17-224.21 *)
val Int32VectorSlice.foldri: (int * int * 'a -> 'a) -> 'a -> Int32VectorSlice.slice -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 222.17-222.22 *)
val Int32VectorSlice.full: Int32Vector.vector -> Int32VectorSlice.slice (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 192.17-192.20 *)
val Int32VectorSlice.getItem: Int32VectorSlice.slice -> (int * Int32VectorSlice.slice) option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 220.17-220.23 *)
val Int32VectorSlice.isEmpty: Int32VectorSlice.slice -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 219.17-219.23 *)
val Int32VectorSlice.length: Int32VectorSlice.slice -> int (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 134.17-134.22 *)
val Int32VectorSlice.map: (int -> int) -> Int32VectorSlice.slice -> Int32Vector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 228.17-228.19 *)
val Int32VectorSlice.mapi: (int * int -> int) -> Int32VectorSlice.slice -> Int32Vector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 227.17-227.20 *)
val Int32VectorSlice.slice: Int32Vector.vector * int * int option -> Int32VectorSlice.slice (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 206.17-206.21 *)
val Int32VectorSlice.sub: Int32VectorSlice.slice * int -> int (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 142.17-142.19 *)
val Int32VectorSlice.subslice: Int32VectorSlice.slice * int * int option -> Int32VectorSlice.slice (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 199.17-199.24 *)
val Int32VectorSlice.vector: Int32VectorSlice.slice -> Int32Vector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/vector.sml 21.17-21.22 *)
structure Int4: INTEGER where type int = Int4.int (* @ $(SML_LIB)/basis/libs/basis-extra/top-level/basis.sml 69.17-69.20 *)
type Int4.int = Int4.int (* @ $(SML_LIB)/basis/primitive/prim-basis.sml 88.12-88.14 *)
val Int4.* : Int4.int * Int4.int -> Int4.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 64.17-64.17 *)
val Int4.+ : Int4.int * Int4.int -> Int4.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 65.17-65.17 *)
val Int4.- : Int4.int * Int4.int -> Int4.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 66.17-66.17 *)
val Int4.< : Int4.int * Int4.int -> bool (* @ $(SML_LIB)/basis/integer/embed-int.sml 77.17-77.17 *)
val Int4.<= : Int4.int * Int4.int -> bool (* @ $(SML_LIB)/basis/integer/embed-int.sml 78.17-78.18 *)
val Int4.> : Int4.int * Int4.int -> bool (* @ $(SML_LIB)/basis/integer/embed-int.sml 79.17-79.17 *)
val Int4.>= : Int4.int * Int4.int -> bool (* @ $(SML_LIB)/basis/integer/embed-int.sml 80.17-80.18 *)
val Int4.abs: Int4.int -> Int4.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 93.14-93.16 *)
val Int4.compare: Int4.int * Int4.int -> order (* @ $(SML_LIB)/basis/integer/embed-int.sml 81.14-81.20 *)
val Int4.div: Int4.int * Int4.int -> Int4.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 67.17-67.19 *)
val Int4.fmt: StringCvt.radix -> Int4.int -> string (* @ $(SML_LIB)/basis/integer/embed-int.sml 96.11-96.13 *)
val Int4.fromInt: int -> Int4.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 84.11-84.17 *)
val Int4.fromLarge: LargeInt.int -> Int4.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 98.11-98.19 *)
val Int4.fromString: string -> Int4.int option (* @ $(SML_LIB)/basis/integer/embed-int.sml 100.11-100.20 *)
val Int4.max: Int4.int * Int4.int -> Int4.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 102.11-102.13 *)
val Int4.maxInt: Int4.int option (* @ $(SML_LIB)/basis/integer/embed-int.sml 56.11-56.16 *)
val Int4.min: Int4.int * Int4.int -> Int4.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 104.11-104.13 *)
val Int4.minInt: Int4.int option (* @ $(SML_LIB)/basis/integer/embed-int.sml 58.11-58.16 *)
val Int4.mod: Int4.int * Int4.int -> Int4.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 68.17-68.19 *)
val Int4.precision: int option (* @ $(SML_LIB)/basis/integer/embed-int.sml 39.11-39.19 *)
val Int4.quot: Int4.int * Int4.int -> Int4.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 69.14-69.17 *)
val Int4.rem: Int4.int * Int4.int -> Int4.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 70.14-70.16 *)
val Int4.sameSign: Int4.int * Int4.int -> bool (* @ $(SML_LIB)/basis/integer/embed-int.sml 113.11-113.18 *)
val Int4.scan: StringCvt.radix -> ('a -> (char * 'a) option) -> 'a -> (Int4.int * 'a) option (* @ $(SML_LIB)/basis/integer/embed-int.sml 106.11-106.14 *)
val Int4.sign: Int4.int -> int (* @ $(SML_LIB)/basis/integer/embed-int.sml 111.11-111.14 *)
val Int4.toInt: Int4.int -> int (* @ $(SML_LIB)/basis/integer/embed-int.sml 86.11-86.15 *)
val Int4.toLarge: Int4.int -> LargeInt.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 115.11-115.17 *)
val Int4.toString: Int4.int -> string (* @ $(SML_LIB)/basis/integer/embed-int.sml 117.11-117.18 *)
val Int4.~ : Int4.int -> Int4.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 92.14-92.14 *)
structure Int5: INTEGER where type int = Int5.int (* @ $(SML_LIB)/basis/libs/basis-extra/top-level/basis.sml 70.17-70.20 *)
type Int5.int = Int5.int (* @ $(SML_LIB)/basis/primitive/prim-basis.sml 93.12-93.14 *)
val Int5.* : Int5.int * Int5.int -> Int5.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 64.17-64.17 *)
val Int5.+ : Int5.int * Int5.int -> Int5.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 65.17-65.17 *)
val Int5.- : Int5.int * Int5.int -> Int5.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 66.17-66.17 *)
val Int5.< : Int5.int * Int5.int -> bool (* @ $(SML_LIB)/basis/integer/embed-int.sml 77.17-77.17 *)
val Int5.<= : Int5.int * Int5.int -> bool (* @ $(SML_LIB)/basis/integer/embed-int.sml 78.17-78.18 *)
val Int5.> : Int5.int * Int5.int -> bool (* @ $(SML_LIB)/basis/integer/embed-int.sml 79.17-79.17 *)
val Int5.>= : Int5.int * Int5.int -> bool (* @ $(SML_LIB)/basis/integer/embed-int.sml 80.17-80.18 *)
val Int5.abs: Int5.int -> Int5.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 93.14-93.16 *)
val Int5.compare: Int5.int * Int5.int -> order (* @ $(SML_LIB)/basis/integer/embed-int.sml 81.14-81.20 *)
val Int5.div: Int5.int * Int5.int -> Int5.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 67.17-67.19 *)
val Int5.fmt: StringCvt.radix -> Int5.int -> string (* @ $(SML_LIB)/basis/integer/embed-int.sml 96.11-96.13 *)
val Int5.fromInt: int -> Int5.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 84.11-84.17 *)
val Int5.fromLarge: LargeInt.int -> Int5.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 98.11-98.19 *)
val Int5.fromString: string -> Int5.int option (* @ $(SML_LIB)/basis/integer/embed-int.sml 100.11-100.20 *)
val Int5.max: Int5.int * Int5.int -> Int5.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 102.11-102.13 *)
val Int5.maxInt: Int5.int option (* @ $(SML_LIB)/basis/integer/embed-int.sml 56.11-56.16 *)
val Int5.min: Int5.int * Int5.int -> Int5.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 104.11-104.13 *)
val Int5.minInt: Int5.int option (* @ $(SML_LIB)/basis/integer/embed-int.sml 58.11-58.16 *)
val Int5.mod: Int5.int * Int5.int -> Int5.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 68.17-68.19 *)
val Int5.precision: int option (* @ $(SML_LIB)/basis/integer/embed-int.sml 39.11-39.19 *)
val Int5.quot: Int5.int * Int5.int -> Int5.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 69.14-69.17 *)
val Int5.rem: Int5.int * Int5.int -> Int5.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 70.14-70.16 *)
val Int5.sameSign: Int5.int * Int5.int -> bool (* @ $(SML_LIB)/basis/integer/embed-int.sml 113.11-113.18 *)
val Int5.scan: StringCvt.radix -> ('a -> (char * 'a) option) -> 'a -> (Int5.int * 'a) option (* @ $(SML_LIB)/basis/integer/embed-int.sml 106.11-106.14 *)
val Int5.sign: Int5.int -> int (* @ $(SML_LIB)/basis/integer/embed-int.sml 111.11-111.14 *)
val Int5.toInt: Int5.int -> int (* @ $(SML_LIB)/basis/integer/embed-int.sml 86.11-86.15 *)
val Int5.toLarge: Int5.int -> LargeInt.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 115.11-115.17 *)
val Int5.toString: Int5.int -> string (* @ $(SML_LIB)/basis/integer/embed-int.sml 117.11-117.18 *)
val Int5.~ : Int5.int -> Int5.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 92.14-92.14 *)
structure Int6: INTEGER where type int = Int6.int (* @ $(SML_LIB)/basis/libs/basis-extra/top-level/basis.sml 71.17-71.20 *)
type Int6.int = Int6.int (* @ $(SML_LIB)/basis/primitive/prim-basis.sml 98.12-98.14 *)
val Int6.* : Int6.int * Int6.int -> Int6.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 64.17-64.17 *)
val Int6.+ : Int6.int * Int6.int -> Int6.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 65.17-65.17 *)
val Int6.- : Int6.int * Int6.int -> Int6.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 66.17-66.17 *)
val Int6.< : Int6.int * Int6.int -> bool (* @ $(SML_LIB)/basis/integer/embed-int.sml 77.17-77.17 *)
val Int6.<= : Int6.int * Int6.int -> bool (* @ $(SML_LIB)/basis/integer/embed-int.sml 78.17-78.18 *)
val Int6.> : Int6.int * Int6.int -> bool (* @ $(SML_LIB)/basis/integer/embed-int.sml 79.17-79.17 *)
val Int6.>= : Int6.int * Int6.int -> bool (* @ $(SML_LIB)/basis/integer/embed-int.sml 80.17-80.18 *)
val Int6.abs: Int6.int -> Int6.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 93.14-93.16 *)
val Int6.compare: Int6.int * Int6.int -> order (* @ $(SML_LIB)/basis/integer/embed-int.sml 81.14-81.20 *)
val Int6.div: Int6.int * Int6.int -> Int6.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 67.17-67.19 *)
val Int6.fmt: StringCvt.radix -> Int6.int -> string (* @ $(SML_LIB)/basis/integer/embed-int.sml 96.11-96.13 *)
val Int6.fromInt: int -> Int6.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 84.11-84.17 *)
val Int6.fromLarge: LargeInt.int -> Int6.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 98.11-98.19 *)
val Int6.fromString: string -> Int6.int option (* @ $(SML_LIB)/basis/integer/embed-int.sml 100.11-100.20 *)
val Int6.max: Int6.int * Int6.int -> Int6.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 102.11-102.13 *)
val Int6.maxInt: Int6.int option (* @ $(SML_LIB)/basis/integer/embed-int.sml 56.11-56.16 *)
val Int6.min: Int6.int * Int6.int -> Int6.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 104.11-104.13 *)
val Int6.minInt: Int6.int option (* @ $(SML_LIB)/basis/integer/embed-int.sml 58.11-58.16 *)
val Int6.mod: Int6.int * Int6.int -> Int6.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 68.17-68.19 *)
val Int6.precision: int option (* @ $(SML_LIB)/basis/integer/embed-int.sml 39.11-39.19 *)
val Int6.quot: Int6.int * Int6.int -> Int6.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 69.14-69.17 *)
val Int6.rem: Int6.int * Int6.int -> Int6.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 70.14-70.16 *)
val Int6.sameSign: Int6.int * Int6.int -> bool (* @ $(SML_LIB)/basis/integer/embed-int.sml 113.11-113.18 *)
val Int6.scan: StringCvt.radix -> ('a -> (char * 'a) option) -> 'a -> (Int6.int * 'a) option (* @ $(SML_LIB)/basis/integer/embed-int.sml 106.11-106.14 *)
val Int6.sign: Int6.int -> int (* @ $(SML_LIB)/basis/integer/embed-int.sml 111.11-111.14 *)
val Int6.toInt: Int6.int -> int (* @ $(SML_LIB)/basis/integer/embed-int.sml 86.11-86.15 *)
val Int6.toLarge: Int6.int -> LargeInt.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 115.11-115.17 *)
val Int6.toString: Int6.int -> string (* @ $(SML_LIB)/basis/integer/embed-int.sml 117.11-117.18 *)
val Int6.~ : Int6.int -> Int6.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 92.14-92.14 *)
structure Int64: INTEGER where type int = Int64.int (* @ $(SML_LIB)/basis/libs/basis-2002/top-level/top-level.sml 79.11-79.15 *)
type Int64.int = Int64.int (* @ $(SML_LIB)/basis/primitive/prim-basis.sml 233.12-233.14 *)
val Int64.* : Int64.int * Int64.int -> Int64.int (* @ $(SML_LIB)/basis/primitive/prim-int.sml 438.11-438.11 *)
val Int64.+ : Int64.int * Int64.int -> Int64.int (* @ $(SML_LIB)/basis/primitive/prim-int.sml 432.11-432.11 *)
val Int64.- : Int64.int * Int64.int -> Int64.int (* @ $(SML_LIB)/basis/primitive/prim-int.sml 451.11-451.11 *)
val Int64.< : Int64.int * Int64.int -> bool (* @ $(SML_LIB)/basis/util/integral-comparisons.sml 11.11-11.11 *)
val Int64.<= : Int64.int * Int64.int -> bool (* @ $(SML_LIB)/basis/util/integral-comparisons.sml 12.11-12.12 *)
val Int64.> : Int64.int * Int64.int -> bool (* @ $(SML_LIB)/basis/util/integral-comparisons.sml 13.11-13.11 *)
val Int64.>= : Int64.int * Int64.int -> bool (* @ $(SML_LIB)/basis/util/integral-comparisons.sml 14.11-14.12 *)
val Int64.abs: Int64.int -> Int64.int (* @ $(SML_LIB)/basis/integer/num0.sml 161.17-161.19 *)
val Int64.compare: Int64.int * Int64.int -> order (* @ $(SML_LIB)/basis/util/integral-comparisons.sml 16.11-16.17 *)
val Int64.div: Int64.int * Int64.int -> Int64.int (* @ $(SML_LIB)/basis/integer/num0.sml 183.19-183.21 *)
val Int64.fmt: StringCvt.radix -> Int64.int -> string (* @ $(SML_LIB)/basis/integer/int.sml 74.8-74.10 *)
val Int64.fromInt: int -> Int64.int (* @ $(SML_LIB)/basis/integer/int.sml 46.5-46.11 *)
val Int64.fromLarge: LargeInt.int -> Int64.int (* @ $(SML_LIB)/basis/integer/int.sml 51.5-51.13 *)
val Int64.fromString: string -> Int64.int option (* @ $(SML_LIB)/basis/integer/int.sml 165.5-165.14 *)
val Int64.max: Int64.int * Int64.int -> Int64.int (* @ $(SML_LIB)/basis/util/integral-comparisons.sml 21.11-21.13 *)
val Int64.maxInt: Int64.int option (* @ $(SML_LIB)/basis/integer/int.sml 19.5-19.10 *)
val Int64.min: Int64.int * Int64.int -> Int64.int (* @ $(SML_LIB)/basis/util/integral-comparisons.sml 20.11-20.13 *)
val Int64.minInt: Int64.int option (* @ $(SML_LIB)/basis/integer/int.sml 20.5-20.10 *)
val Int64.mod: Int64.int * Int64.int -> Int64.int (* @ $(SML_LIB)/basis/integer/num0.sml 204.19-204.21 *)
val Int64.precision: int option (* @ $(SML_LIB)/basis/integer/int.sml 16.5-16.13 *)
val Int64.quot: Int64.int * Int64.int -> Int64.int (* @ $(SML_LIB)/basis/integer/num0.sml 163.17-163.20 *)
val Int64.rem: Int64.int * Int64.int -> Int64.int (* @ $(SML_LIB)/basis/integer/num0.sml 175.17-175.19 *)
val Int64.sameSign: Int64.int * Int64.int -> bool (* @ $(SML_LIB)/basis/integer/int.sml 29.5-29.12 *)
val Int64.scan: StringCvt.radix -> ('a -> (char * 'a) option) -> 'a -> (Int64.int * 'a) option (* @ $(SML_LIB)/basis/integer/int.sml 112.5-112.8 *)
val Int64.sign: Int64.int -> int (* @ $(SML_LIB)/basis/integer/int.sml 22.5-22.8 *)
val Int64.toInt: Int64.int -> int (* @ $(SML_LIB)/basis/integer/int.sml 47.5-47.9 *)
val Int64.toLarge: Int64.int -> LargeInt.int (* @ $(SML_LIB)/basis/integer/int.sml 52.5-52.11 *)
val Int64.toString: Int64.int -> string (* @ $(SML_LIB)/basis/integer/int.sml 110.5-110.12 *)
val Int64.~ : Int64.int -> Int64.int (* @ $(SML_LIB)/basis/primitive/prim-int.sml 444.11-444.11 *)
structure Int64Array: MONO_ARRAY where type array = Int64Array.array where type elem = Int64.int where type vector = Int64Vector.vector (* @ $(SML_LIB)/basis/libs/basis-2002/top-level/top-level.sml 34.11-34.20 *)
type Int64Array.array = Int64Array.array (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array.fun 23.12-23.16 *)
type Int64Array.elem = Int64.int (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array.fun 22.12-22.15 *)
type Int64Array.vector = Int64Vector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array.fun 24.12-24.17 *)
val Int64Array.all: (Int64.int -> bool) -> Int64Array.array -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 476.13-476.15 *)
val Int64Array.app: (Int64.int -> unit) -> Int64Array.array -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 464.13-464.15 *)
val Int64Array.appi: (int * Int64.int -> unit) -> Int64Array.array -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 463.13-463.16 *)
val Int64Array.array: int * Int64.int -> Int64Array.array (* @ $(SML_LIB)/basis/arrays-and-vectors/array.sml 34.11-34.15 *)
val Int64Array.collate: (Int64.int * Int64.int -> order) -> Int64Array.array * Int64Array.array -> order (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 477.13-477.19 *)
val Int64Array.copy: {di: int, dst: Int64Array.array, src: Int64Array.array} -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 457.13-457.16 *)
val Int64Array.copyVec: {di: int, dst: Int64Array.array, src: Int64Vector.vector} -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array.sml 37.11-37.17 *)
val Int64Array.exists: (Int64.int -> bool) -> Int64Array.array -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 474.13-474.18 *)
val Int64Array.find: (Int64.int -> bool) -> Int64Array.array -> Int64.int option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 472.13-472.16 *)
val Int64Array.findi: (int * Int64.int -> bool) -> Int64Array.array -> (int * Int64.int) option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 471.13-471.17 *)
val Int64Array.foldl: (Int64.int * 'a -> 'a) -> 'a -> Int64Array.array -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 468.13-468.17 *)
val Int64Array.foldli: (int * Int64.int * 'a -> 'a) -> 'a -> Int64Array.array -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 467.13-467.18 *)
val Int64Array.foldr: (Int64.int * 'a -> 'a) -> 'a -> Int64Array.array -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 470.13-470.17 *)
val Int64Array.foldri: (int * Int64.int * 'a -> 'a) -> 'a -> Int64Array.array -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 469.13-469.18 *)
val Int64Array.fromList: Int64.int list -> Int64Array.array (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 122.11-122.18 *)
val Int64Array.length: Int64Array.array -> int (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 90.11-90.16 *)
val Int64Array.maxLen: int (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 88.11-88.16 *)
val Int64Array.modify: (Int64.int -> Int64.int) -> Int64Array.array -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array.sml 40.11-40.16 *)
val Int64Array.modifyi: (int * Int64.int -> Int64.int) -> Int64Array.array -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array.sml 39.11-39.17 *)
val Int64Array.sub: Int64Array.array * int -> Int64.int (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 450.13-450.15 *)
val Int64Array.tabulate: int * (int -> Int64.int) -> Int64Array.array (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 114.11-114.18 *)
val Int64Array.update: Int64Array.array * int * Int64.int -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 452.13-452.18 *)
val Int64Array.vector: Int64Array.array -> Int64Vector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/array.sml 36.11-36.16 *)
structure Int64Array2: MONO_ARRAY2 where type array = Int64Array2.array where type elem = Int64.int where type vector = Int64Vector.vector (* @ $(SML_LIB)/basis/libs/basis-2002/top-level/top-level.sml 35.11-35.21 *)
type Int64Array2.array = Int64Array2.array (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array2.fun 18.12-18.16 *)
type Int64Array2.elem = Int64.int (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array2.fun 15.12-15.15 *)
type Int64Array2.region = {base: Int64Array2.array, col: int, ncols: int option, nrows: int option, row: int} (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array2.fun 19.12-19.17 *)
datatype Int64Array2.traversal = ColMajor | RowMajor (* = datatype Array2.traversal *) (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 106.16-106.24 *)
type Int64Array2.vector = Int64Vector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array2.fun 16.12-16.17 *)
con Int64Array2.ColMajor: Array2.traversal (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 106.39-106.46 *)
con Int64Array2.RowMajor: Array2.traversal (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 106.28-106.35 *)
val Int64Array2.app: Array2.traversal -> (Int64.int -> unit) -> Int64Array2.array -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 294.11-294.13 *)
val Int64Array2.appi: Array2.traversal -> (int * int * Int64.int -> unit) -> {base: Int64Array2.array, col: int, ncols: int option, nrows: int option, row: int} -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 291.11-291.14 *)
val Int64Array2.array: int * int * Int64.int -> Int64Array2.array (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 140.14-140.18 *)
val Int64Array2.column: Int64Array2.array * int -> Int64Vector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 237.11-237.16 *)
val Int64Array2.copy: {dst: Int64Array2.array, dst_col: int, dst_row: int, src: {base: Int64Array2.array, col: int, ncols: int option, nrows: int option, row: int}} -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 309.11-309.14 *)
val Int64Array2.dimensions: Int64Array2.array -> int * int (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 33.11-33.20 *)
val Int64Array2.fold: Array2.traversal -> (Int64.int * 'a -> 'a) -> 'a -> Int64Array2.array -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 288.11-288.14 *)
val Int64Array2.foldi: Array2.traversal -> (int * int * Int64.int * 'a -> 'a) -> 'a -> {base: Int64Array2.array, col: int, ncols: int option, nrows: int option, row: int} -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 283.11-283.15 *)
val Int64Array2.fromList: Int64.int list list -> Int64Array2.array (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 188.14-188.21 *)
val Int64Array2.modify: Array2.traversal -> (Int64.int -> Int64.int) -> Int64Array2.array -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 299.11-299.16 *)
val Int64Array2.modifyi: Array2.traversal -> (int * int * Int64.int -> Int64.int) -> {base: Int64Array2.array, col: int, ncols: int option, nrows: int option, row: int} -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 296.11-296.17 *)
val Int64Array2.nCols: Int64Array2.array -> int (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 38.11-38.15 *)
val Int64Array2.nRows: Int64Array2.array -> int (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 36.11-36.15 *)
val Int64Array2.row: Int64Array2.array * int -> Int64Vector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 222.11-222.13 *)
val Int64Array2.sub: Int64Array2.array * int * int -> Int64.int (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 182.14-182.16 *)
val Int64Array2.tabulate: Array2.traversal -> int * int * (int * int -> Int64.int) -> Int64Array2.array (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 301.11-301.18 *)
val Int64Array2.update: Int64Array2.array * int * int * Int64.int -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 184.14-184.19 *)
structure Int64ArraySlice: MONO_ARRAY_SLICE where type array = Int64Array.array where type elem = Int64.int where type slice = Int64ArraySlice.slice where type vector = Int64Vector.vector where type vector_slice = Int64VectorSlice.slice (* @ $(SML_LIB)/basis/libs/basis-extra/top-level/basis.sml 122.17-122.31 *)
type Int64ArraySlice.array = Int64Array.array (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array.fun 35.18-35.22 *)
type Int64ArraySlice.elem = Int64.int (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array.fun 34.18-34.21 *)
type Int64ArraySlice.slice = Int64ArraySlice.slice (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array.fun 36.18-36.22 *)
type Int64ArraySlice.vector = Int64Vector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array.fun 37.18-37.23 *)
type Int64ArraySlice.vector_slice = Int64VectorSlice.slice (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array.fun 38.18-38.29 *)
val Int64ArraySlice.all: (Int64.int -> bool) -> Int64ArraySlice.slice -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 235.17-235.19 *)
val Int64ArraySlice.app: (Int64.int -> unit) -> Int64ArraySlice.slice -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 226.17-226.19 *)
val Int64ArraySlice.appi: (int * Int64.int -> unit) -> Int64ArraySlice.slice -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 225.17-225.20 *)
val Int64ArraySlice.base: Int64ArraySlice.slice -> Int64Array.array * int * int (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 208.17-208.20 *)
val Int64ArraySlice.collate: (Int64.int * Int64.int -> order) -> Int64ArraySlice.slice * Int64ArraySlice.slice -> order (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 236.17-236.23 *)
val Int64ArraySlice.copy: {di: int, dst: Int64Array.array, src: Int64ArraySlice.slice} -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 185.17-185.20 *)
val Int64ArraySlice.copyVec: {di: int, dst: Int64Array.array, src: Int64VectorSlice.slice} -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array.sml 28.17-28.23 *)
val Int64ArraySlice.exists: (Int64.int -> bool) -> Int64ArraySlice.slice -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 233.17-233.22 *)
val Int64ArraySlice.find: (Int64.int -> bool) -> Int64ArraySlice.slice -> Int64.int option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 231.17-231.20 *)
val Int64ArraySlice.findi: (int * Int64.int -> bool) -> Int64ArraySlice.slice -> (int * Int64.int) option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 229.17-229.21 *)
val Int64ArraySlice.foldl: (Int64.int * 'a -> 'a) -> 'a -> Int64ArraySlice.slice -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 223.17-223.21 *)
val Int64ArraySlice.foldli: (int * Int64.int * 'a -> 'a) -> 'a -> Int64ArraySlice.slice -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 221.17-221.22 *)
val Int64ArraySlice.foldr: (Int64.int * 'a -> 'a) -> 'a -> Int64ArraySlice.slice -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 224.17-224.21 *)
val Int64ArraySlice.foldri: (int * Int64.int * 'a -> 'a) -> 'a -> Int64ArraySlice.slice -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 222.17-222.22 *)
val Int64ArraySlice.full: Int64Array.array -> Int64ArraySlice.slice (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 192.17-192.20 *)
val Int64ArraySlice.getItem: Int64ArraySlice.slice -> (Int64.int * Int64ArraySlice.slice) option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 220.17-220.23 *)
val Int64ArraySlice.isEmpty: Int64ArraySlice.slice -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 219.17-219.23 *)
val Int64ArraySlice.length: Int64ArraySlice.slice -> int (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 134.17-134.22 *)
val Int64ArraySlice.modify: (Int64.int -> Int64.int) -> Int64ArraySlice.slice -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array.sml 31.17-31.22 *)
val Int64ArraySlice.modifyi: (int * Int64.int -> Int64.int) -> Int64ArraySlice.slice -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array.sml 30.17-30.23 *)
val Int64ArraySlice.slice: Int64Array.array * int * int option -> Int64ArraySlice.slice (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 206.17-206.21 *)
val Int64ArraySlice.sub: Int64ArraySlice.slice * int -> Int64.int (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 142.17-142.19 *)
val Int64ArraySlice.subslice: Int64ArraySlice.slice * int * int option -> Int64ArraySlice.slice (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 199.17-199.24 *)
val Int64ArraySlice.update: Int64ArraySlice.slice * int * Int64.int -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 155.17-155.22 *)
val Int64ArraySlice.vector: Int64ArraySlice.slice -> Int64Vector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/array.sml 27.17-27.22 *)
structure Int64Vector: MONO_VECTOR where type elem = Int64.int where type vector = Int64Vector.vector (* @ $(SML_LIB)/basis/libs/basis-2002/top-level/top-level.sml 36.11-36.21 *)
type Int64Vector.elem = Int64.int (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-vector.fun 35.12-35.15 *)
type Int64Vector.vector = Int64Vector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-vector.fun 36.12-36.17 *)
val Int64Vector.all: (Int64.int -> bool) -> Int64Vector.vector -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 476.13-476.15 *)
val Int64Vector.app: (Int64.int -> unit) -> Int64Vector.vector -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 464.13-464.15 *)
val Int64Vector.appi: (int * Int64.int -> unit) -> Int64Vector.vector -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 463.13-463.16 *)
val Int64Vector.collate: (Int64.int * Int64.int -> order) -> Int64Vector.vector * Int64Vector.vector -> order (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 477.13-477.19 *)
val Int64Vector.concat: Int64Vector.vector list -> Int64Vector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 462.13-462.18 *)
val Int64Vector.exists: (Int64.int -> bool) -> Int64Vector.vector -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 474.13-474.18 *)
val Int64Vector.find: (Int64.int -> bool) -> Int64Vector.vector -> Int64.int option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 472.13-472.16 *)
val Int64Vector.findi: (int * Int64.int -> bool) -> Int64Vector.vector -> (int * Int64.int) option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 471.13-471.17 *)
val Int64Vector.foldl: (Int64.int * 'a -> 'a) -> 'a -> Int64Vector.vector -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 468.13-468.17 *)
val Int64Vector.foldli: (int * Int64.int * 'a -> 'a) -> 'a -> Int64Vector.vector -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 467.13-467.18 *)
val Int64Vector.foldr: (Int64.int * 'a -> 'a) -> 'a -> Int64Vector.vector -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 470.13-470.17 *)
val Int64Vector.foldri: (int * Int64.int * 'a -> 'a) -> 'a -> Int64Vector.vector -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 469.13-469.18 *)
val Int64Vector.fromList: Int64.int list -> Int64Vector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 122.11-122.18 *)
val Int64Vector.length: Int64Vector.vector -> int (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 90.11-90.16 *)
val Int64Vector.map: (Int64.int -> Int64.int) -> Int64Vector.vector -> Int64Vector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 466.13-466.15 *)
val Int64Vector.mapi: (int * Int64.int -> Int64.int) -> Int64Vector.vector -> Int64Vector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 465.13-465.16 *)
val Int64Vector.maxLen: int (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 88.11-88.16 *)
val Int64Vector.sub: Int64Vector.vector * int -> Int64.int (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 450.13-450.15 *)
val Int64Vector.tabulate: int * (int -> Int64.int) -> Int64Vector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 114.11-114.18 *)
val Int64Vector.update: Int64Vector.vector * int * Int64.int -> Int64Vector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/vector.sml 30.11-30.16 *)
structure Int64VectorSlice: MONO_VECTOR_SLICE where type elem = Int64.int where type slice = Int64VectorSlice.slice where type vector = Int64Vector.vector (* @ $(SML_LIB)/basis/libs/basis-extra/top-level/basis.sml 124.17-124.32 *)
type Int64VectorSlice.elem = Int64.int (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-vector.fun 43.18-43.21 *)
type Int64VectorSlice.slice = Int64VectorSlice.slice (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-vector.fun 45.18-45.22 *)
type Int64VectorSlice.vector = Int64Vector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-vector.fun 44.18-44.23 *)
val Int64VectorSlice.all: (Int64.int -> bool) -> Int64VectorSlice.slice -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 235.17-235.19 *)
val Int64VectorSlice.app: (Int64.int -> unit) -> Int64VectorSlice.slice -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 226.17-226.19 *)
val Int64VectorSlice.appi: (int * Int64.int -> unit) -> Int64VectorSlice.slice -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 225.17-225.20 *)
val Int64VectorSlice.base: Int64VectorSlice.slice -> Int64Vector.vector * int * int (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 208.17-208.20 *)
val Int64VectorSlice.collate: (Int64.int * Int64.int -> order) -> Int64VectorSlice.slice * Int64VectorSlice.slice -> order (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 236.17-236.23 *)
val Int64VectorSlice.concat: Int64VectorSlice.slice list -> Int64Vector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 240.17-240.22 *)
val Int64VectorSlice.exists: (Int64.int -> bool) -> Int64VectorSlice.slice -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 233.17-233.22 *)
val Int64VectorSlice.find: (Int64.int -> bool) -> Int64VectorSlice.slice -> Int64.int option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 231.17-231.20 *)
val Int64VectorSlice.findi: (int * Int64.int -> bool) -> Int64VectorSlice.slice -> (int * Int64.int) option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 229.17-229.21 *)
val Int64VectorSlice.foldl: (Int64.int * 'a -> 'a) -> 'a -> Int64VectorSlice.slice -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 223.17-223.21 *)
val Int64VectorSlice.foldli: (int * Int64.int * 'a -> 'a) -> 'a -> Int64VectorSlice.slice -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 221.17-221.22 *)
val Int64VectorSlice.foldr: (Int64.int * 'a -> 'a) -> 'a -> Int64VectorSlice.slice -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 224.17-224.21 *)
val Int64VectorSlice.foldri: (int * Int64.int * 'a -> 'a) -> 'a -> Int64VectorSlice.slice -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 222.17-222.22 *)
val Int64VectorSlice.full: Int64Vector.vector -> Int64VectorSlice.slice (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 192.17-192.20 *)
val Int64VectorSlice.getItem: Int64VectorSlice.slice -> (Int64.int * Int64VectorSlice.slice) option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 220.17-220.23 *)
val Int64VectorSlice.isEmpty: Int64VectorSlice.slice -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 219.17-219.23 *)
val Int64VectorSlice.length: Int64VectorSlice.slice -> int (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 134.17-134.22 *)
val Int64VectorSlice.map: (Int64.int -> Int64.int) -> Int64VectorSlice.slice -> Int64Vector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 228.17-228.19 *)
val Int64VectorSlice.mapi: (int * Int64.int -> Int64.int) -> Int64VectorSlice.slice -> Int64Vector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 227.17-227.20 *)
val Int64VectorSlice.slice: Int64Vector.vector * int * int option -> Int64VectorSlice.slice (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 206.17-206.21 *)
val Int64VectorSlice.sub: Int64VectorSlice.slice * int -> Int64.int (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 142.17-142.19 *)
val Int64VectorSlice.subslice: Int64VectorSlice.slice * int * int option -> Int64VectorSlice.slice (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 199.17-199.24 *)
val Int64VectorSlice.vector: Int64VectorSlice.slice -> Int64Vector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/vector.sml 21.17-21.22 *)
structure Int7: INTEGER where type int = Int7.int (* @ $(SML_LIB)/basis/libs/basis-extra/top-level/basis.sml 72.17-72.20 *)
type Int7.int = Int7.int (* @ $(SML_LIB)/basis/primitive/prim-basis.sml 103.12-103.14 *)
val Int7.* : Int7.int * Int7.int -> Int7.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 64.17-64.17 *)
val Int7.+ : Int7.int * Int7.int -> Int7.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 65.17-65.17 *)
val Int7.- : Int7.int * Int7.int -> Int7.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 66.17-66.17 *)
val Int7.< : Int7.int * Int7.int -> bool (* @ $(SML_LIB)/basis/integer/embed-int.sml 77.17-77.17 *)
val Int7.<= : Int7.int * Int7.int -> bool (* @ $(SML_LIB)/basis/integer/embed-int.sml 78.17-78.18 *)
val Int7.> : Int7.int * Int7.int -> bool (* @ $(SML_LIB)/basis/integer/embed-int.sml 79.17-79.17 *)
val Int7.>= : Int7.int * Int7.int -> bool (* @ $(SML_LIB)/basis/integer/embed-int.sml 80.17-80.18 *)
val Int7.abs: Int7.int -> Int7.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 93.14-93.16 *)
val Int7.compare: Int7.int * Int7.int -> order (* @ $(SML_LIB)/basis/integer/embed-int.sml 81.14-81.20 *)
val Int7.div: Int7.int * Int7.int -> Int7.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 67.17-67.19 *)
val Int7.fmt: StringCvt.radix -> Int7.int -> string (* @ $(SML_LIB)/basis/integer/embed-int.sml 96.11-96.13 *)
val Int7.fromInt: int -> Int7.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 84.11-84.17 *)
val Int7.fromLarge: LargeInt.int -> Int7.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 98.11-98.19 *)
val Int7.fromString: string -> Int7.int option (* @ $(SML_LIB)/basis/integer/embed-int.sml 100.11-100.20 *)
val Int7.max: Int7.int * Int7.int -> Int7.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 102.11-102.13 *)
val Int7.maxInt: Int7.int option (* @ $(SML_LIB)/basis/integer/embed-int.sml 56.11-56.16 *)
val Int7.min: Int7.int * Int7.int -> Int7.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 104.11-104.13 *)
val Int7.minInt: Int7.int option (* @ $(SML_LIB)/basis/integer/embed-int.sml 58.11-58.16 *)
val Int7.mod: Int7.int * Int7.int -> Int7.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 68.17-68.19 *)
val Int7.precision: int option (* @ $(SML_LIB)/basis/integer/embed-int.sml 39.11-39.19 *)
val Int7.quot: Int7.int * Int7.int -> Int7.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 69.14-69.17 *)
val Int7.rem: Int7.int * Int7.int -> Int7.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 70.14-70.16 *)
val Int7.sameSign: Int7.int * Int7.int -> bool (* @ $(SML_LIB)/basis/integer/embed-int.sml 113.11-113.18 *)
val Int7.scan: StringCvt.radix -> ('a -> (char * 'a) option) -> 'a -> (Int7.int * 'a) option (* @ $(SML_LIB)/basis/integer/embed-int.sml 106.11-106.14 *)
val Int7.sign: Int7.int -> int (* @ $(SML_LIB)/basis/integer/embed-int.sml 111.11-111.14 *)
val Int7.toInt: Int7.int -> int (* @ $(SML_LIB)/basis/integer/embed-int.sml 86.11-86.15 *)
val Int7.toLarge: Int7.int -> LargeInt.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 115.11-115.17 *)
val Int7.toString: Int7.int -> string (* @ $(SML_LIB)/basis/integer/embed-int.sml 117.11-117.18 *)
val Int7.~ : Int7.int -> Int7.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 92.14-92.14 *)
structure Int8: INTEGER where type int = Int8.int (* @ $(SML_LIB)/basis/libs/basis-2002/top-level/top-level.sml 76.11-76.14 *)
type Int8.int = Int8.int (* @ $(SML_LIB)/basis/primitive/prim-basis.sml 108.12-108.14 *)
val Int8.* : Int8.int * Int8.int -> Int8.int (* @ $(SML_LIB)/basis/primitive/prim-int.sml 121.11-121.11 *)
val Int8.+ : Int8.int * Int8.int -> Int8.int (* @ $(SML_LIB)/basis/primitive/prim-int.sml 115.11-115.11 *)
val Int8.- : Int8.int * Int8.int -> Int8.int (* @ $(SML_LIB)/basis/primitive/prim-int.sml 134.11-134.11 *)
val Int8.< : Int8.int * Int8.int -> bool (* @ $(SML_LIB)/basis/util/integral-comparisons.sml 11.11-11.11 *)
val Int8.<= : Int8.int * Int8.int -> bool (* @ $(SML_LIB)/basis/util/integral-comparisons.sml 12.11-12.12 *)
val Int8.> : Int8.int * Int8.int -> bool (* @ $(SML_LIB)/basis/util/integral-comparisons.sml 13.11-13.11 *)
val Int8.>= : Int8.int * Int8.int -> bool (* @ $(SML_LIB)/basis/util/integral-comparisons.sml 14.11-14.12 *)
val Int8.abs: Int8.int -> Int8.int (* @ $(SML_LIB)/basis/integer/num0.sml 161.17-161.19 *)
val Int8.compare: Int8.int * Int8.int -> order (* @ $(SML_LIB)/basis/util/integral-comparisons.sml 16.11-16.17 *)
val Int8.div: Int8.int * Int8.int -> Int8.int (* @ $(SML_LIB)/basis/integer/num0.sml 183.19-183.21 *)
val Int8.fmt: StringCvt.radix -> Int8.int -> string (* @ $(SML_LIB)/basis/integer/int.sml 74.8-74.10 *)
val Int8.fromInt: int -> Int8.int (* @ $(SML_LIB)/basis/integer/int.sml 46.5-46.11 *)
val Int8.fromLarge: LargeInt.int -> Int8.int (* @ $(SML_LIB)/basis/integer/int.sml 51.5-51.13 *)
val Int8.fromString: string -> Int8.int option (* @ $(SML_LIB)/basis/integer/int.sml 165.5-165.14 *)
val Int8.max: Int8.int * Int8.int -> Int8.int (* @ $(SML_LIB)/basis/util/integral-comparisons.sml 21.11-21.13 *)
val Int8.maxInt: Int8.int option (* @ $(SML_LIB)/basis/integer/int.sml 19.5-19.10 *)
val Int8.min: Int8.int * Int8.int -> Int8.int (* @ $(SML_LIB)/basis/util/integral-comparisons.sml 20.11-20.13 *)
val Int8.minInt: Int8.int option (* @ $(SML_LIB)/basis/integer/int.sml 20.5-20.10 *)
val Int8.mod: Int8.int * Int8.int -> Int8.int (* @ $(SML_LIB)/basis/integer/num0.sml 204.19-204.21 *)
val Int8.precision: int option (* @ $(SML_LIB)/basis/integer/int.sml 16.5-16.13 *)
val Int8.quot: Int8.int * Int8.int -> Int8.int (* @ $(SML_LIB)/basis/integer/num0.sml 163.17-163.20 *)
val Int8.rem: Int8.int * Int8.int -> Int8.int (* @ $(SML_LIB)/basis/integer/num0.sml 175.17-175.19 *)
val Int8.sameSign: Int8.int * Int8.int -> bool (* @ $(SML_LIB)/basis/integer/int.sml 29.5-29.12 *)
val Int8.scan: StringCvt.radix -> ('a -> (char * 'a) option) -> 'a -> (Int8.int * 'a) option (* @ $(SML_LIB)/basis/integer/int.sml 112.5-112.8 *)
val Int8.sign: Int8.int -> int (* @ $(SML_LIB)/basis/integer/int.sml 22.5-22.8 *)
val Int8.toInt: Int8.int -> int (* @ $(SML_LIB)/basis/integer/int.sml 47.5-47.9 *)
val Int8.toLarge: Int8.int -> LargeInt.int (* @ $(SML_LIB)/basis/integer/int.sml 52.5-52.11 *)
val Int8.toString: Int8.int -> string (* @ $(SML_LIB)/basis/integer/int.sml 110.5-110.12 *)
val Int8.~ : Int8.int -> Int8.int (* @ $(SML_LIB)/basis/primitive/prim-int.sml 127.11-127.11 *)
structure Int8Array: MONO_ARRAY where type array = Int8Array.array where type elem = Int8.int where type vector = Int8Vector.vector (* @ $(SML_LIB)/basis/libs/basis-2002/top-level/top-level.sml 25.11-25.19 *)
type Int8Array.array = Int8Array.array (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array.fun 23.12-23.16 *)
type Int8Array.elem = Int8.int (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array.fun 22.12-22.15 *)
type Int8Array.vector = Int8Vector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array.fun 24.12-24.17 *)
val Int8Array.all: (Int8.int -> bool) -> Int8Array.array -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 476.13-476.15 *)
val Int8Array.app: (Int8.int -> unit) -> Int8Array.array -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 464.13-464.15 *)
val Int8Array.appi: (int * Int8.int -> unit) -> Int8Array.array -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 463.13-463.16 *)
val Int8Array.array: int * Int8.int -> Int8Array.array (* @ $(SML_LIB)/basis/arrays-and-vectors/array.sml 34.11-34.15 *)
val Int8Array.collate: (Int8.int * Int8.int -> order) -> Int8Array.array * Int8Array.array -> order (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 477.13-477.19 *)
val Int8Array.copy: {di: int, dst: Int8Array.array, src: Int8Array.array} -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 457.13-457.16 *)
val Int8Array.copyVec: {di: int, dst: Int8Array.array, src: Int8Vector.vector} -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array.sml 37.11-37.17 *)
val Int8Array.exists: (Int8.int -> bool) -> Int8Array.array -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 474.13-474.18 *)
val Int8Array.find: (Int8.int -> bool) -> Int8Array.array -> Int8.int option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 472.13-472.16 *)
val Int8Array.findi: (int * Int8.int -> bool) -> Int8Array.array -> (int * Int8.int) option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 471.13-471.17 *)
val Int8Array.foldl: (Int8.int * 'a -> 'a) -> 'a -> Int8Array.array -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 468.13-468.17 *)
val Int8Array.foldli: (int * Int8.int * 'a -> 'a) -> 'a -> Int8Array.array -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 467.13-467.18 *)
val Int8Array.foldr: (Int8.int * 'a -> 'a) -> 'a -> Int8Array.array -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 470.13-470.17 *)
val Int8Array.foldri: (int * Int8.int * 'a -> 'a) -> 'a -> Int8Array.array -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 469.13-469.18 *)
val Int8Array.fromList: Int8.int list -> Int8Array.array (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 122.11-122.18 *)
val Int8Array.length: Int8Array.array -> int (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 90.11-90.16 *)
val Int8Array.maxLen: int (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 88.11-88.16 *)
val Int8Array.modify: (Int8.int -> Int8.int) -> Int8Array.array -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array.sml 40.11-40.16 *)
val Int8Array.modifyi: (int * Int8.int -> Int8.int) -> Int8Array.array -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array.sml 39.11-39.17 *)
val Int8Array.sub: Int8Array.array * int -> Int8.int (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 450.13-450.15 *)
val Int8Array.tabulate: int * (int -> Int8.int) -> Int8Array.array (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 114.11-114.18 *)
val Int8Array.update: Int8Array.array * int * Int8.int -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 452.13-452.18 *)
val Int8Array.vector: Int8Array.array -> Int8Vector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/array.sml 36.11-36.16 *)
structure Int8Array2: MONO_ARRAY2 where type array = Int8Array2.array where type elem = Int8.int where type vector = Int8Vector.vector (* @ $(SML_LIB)/basis/libs/basis-2002/top-level/top-level.sml 26.11-26.20 *)
type Int8Array2.array = Int8Array2.array (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array2.fun 18.12-18.16 *)
type Int8Array2.elem = Int8.int (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array2.fun 15.12-15.15 *)
type Int8Array2.region = {base: Int8Array2.array, col: int, ncols: int option, nrows: int option, row: int} (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array2.fun 19.12-19.17 *)
datatype Int8Array2.traversal = ColMajor | RowMajor (* = datatype Array2.traversal *) (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 106.16-106.24 *)
type Int8Array2.vector = Int8Vector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array2.fun 16.12-16.17 *)
con Int8Array2.ColMajor: Array2.traversal (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 106.39-106.46 *)
con Int8Array2.RowMajor: Array2.traversal (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 106.28-106.35 *)
val Int8Array2.app: Array2.traversal -> (Int8.int -> unit) -> Int8Array2.array -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 294.11-294.13 *)
val Int8Array2.appi: Array2.traversal -> (int * int * Int8.int -> unit) -> {base: Int8Array2.array, col: int, ncols: int option, nrows: int option, row: int} -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 291.11-291.14 *)
val Int8Array2.array: int * int * Int8.int -> Int8Array2.array (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 140.14-140.18 *)
val Int8Array2.column: Int8Array2.array * int -> Int8Vector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 237.11-237.16 *)
val Int8Array2.copy: {dst: Int8Array2.array, dst_col: int, dst_row: int, src: {base: Int8Array2.array, col: int, ncols: int option, nrows: int option, row: int}} -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 309.11-309.14 *)
val Int8Array2.dimensions: Int8Array2.array -> int * int (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 33.11-33.20 *)
val Int8Array2.fold: Array2.traversal -> (Int8.int * 'a -> 'a) -> 'a -> Int8Array2.array -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 288.11-288.14 *)
val Int8Array2.foldi: Array2.traversal -> (int * int * Int8.int * 'a -> 'a) -> 'a -> {base: Int8Array2.array, col: int, ncols: int option, nrows: int option, row: int} -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 283.11-283.15 *)
val Int8Array2.fromList: Int8.int list list -> Int8Array2.array (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 188.14-188.21 *)
val Int8Array2.modify: Array2.traversal -> (Int8.int -> Int8.int) -> Int8Array2.array -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 299.11-299.16 *)
val Int8Array2.modifyi: Array2.traversal -> (int * int * Int8.int -> Int8.int) -> {base: Int8Array2.array, col: int, ncols: int option, nrows: int option, row: int} -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 296.11-296.17 *)
val Int8Array2.nCols: Int8Array2.array -> int (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 38.11-38.15 *)
val Int8Array2.nRows: Int8Array2.array -> int (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 36.11-36.15 *)
val Int8Array2.row: Int8Array2.array * int -> Int8Vector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 222.11-222.13 *)
val Int8Array2.sub: Int8Array2.array * int * int -> Int8.int (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 182.14-182.16 *)
val Int8Array2.tabulate: Array2.traversal -> int * int * (int * int -> Int8.int) -> Int8Array2.array (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 301.11-301.18 *)
val Int8Array2.update: Int8Array2.array * int * int * Int8.int -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 184.14-184.19 *)
structure Int8ArraySlice: MONO_ARRAY_SLICE where type array = Int8Array.array where type elem = Int8.int where type slice = Int8ArraySlice.slice where type vector = Int8Vector.vector where type vector_slice = Int8VectorSlice.slice (* @ $(SML_LIB)/basis/libs/basis-extra/top-level/basis.sml 107.17-107.30 *)
type Int8ArraySlice.array = Int8Array.array (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array.fun 35.18-35.22 *)
type Int8ArraySlice.elem = Int8.int (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array.fun 34.18-34.21 *)
type Int8ArraySlice.slice = Int8ArraySlice.slice (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array.fun 36.18-36.22 *)
type Int8ArraySlice.vector = Int8Vector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array.fun 37.18-37.23 *)
type Int8ArraySlice.vector_slice = Int8VectorSlice.slice (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array.fun 38.18-38.29 *)
val Int8ArraySlice.all: (Int8.int -> bool) -> Int8ArraySlice.slice -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 235.17-235.19 *)
val Int8ArraySlice.app: (Int8.int -> unit) -> Int8ArraySlice.slice -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 226.17-226.19 *)
val Int8ArraySlice.appi: (int * Int8.int -> unit) -> Int8ArraySlice.slice -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 225.17-225.20 *)
val Int8ArraySlice.base: Int8ArraySlice.slice -> Int8Array.array * int * int (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 208.17-208.20 *)
val Int8ArraySlice.collate: (Int8.int * Int8.int -> order) -> Int8ArraySlice.slice * Int8ArraySlice.slice -> order (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 236.17-236.23 *)
val Int8ArraySlice.copy: {di: int, dst: Int8Array.array, src: Int8ArraySlice.slice} -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 185.17-185.20 *)
val Int8ArraySlice.copyVec: {di: int, dst: Int8Array.array, src: Int8VectorSlice.slice} -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array.sml 28.17-28.23 *)
val Int8ArraySlice.exists: (Int8.int -> bool) -> Int8ArraySlice.slice -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 233.17-233.22 *)
val Int8ArraySlice.find: (Int8.int -> bool) -> Int8ArraySlice.slice -> Int8.int option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 231.17-231.20 *)
val Int8ArraySlice.findi: (int * Int8.int -> bool) -> Int8ArraySlice.slice -> (int * Int8.int) option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 229.17-229.21 *)
val Int8ArraySlice.foldl: (Int8.int * 'a -> 'a) -> 'a -> Int8ArraySlice.slice -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 223.17-223.21 *)
val Int8ArraySlice.foldli: (int * Int8.int * 'a -> 'a) -> 'a -> Int8ArraySlice.slice -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 221.17-221.22 *)
val Int8ArraySlice.foldr: (Int8.int * 'a -> 'a) -> 'a -> Int8ArraySlice.slice -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 224.17-224.21 *)
val Int8ArraySlice.foldri: (int * Int8.int * 'a -> 'a) -> 'a -> Int8ArraySlice.slice -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 222.17-222.22 *)
val Int8ArraySlice.full: Int8Array.array -> Int8ArraySlice.slice (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 192.17-192.20 *)
val Int8ArraySlice.getItem: Int8ArraySlice.slice -> (Int8.int * Int8ArraySlice.slice) option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 220.17-220.23 *)
val Int8ArraySlice.isEmpty: Int8ArraySlice.slice -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 219.17-219.23 *)
val Int8ArraySlice.length: Int8ArraySlice.slice -> int (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 134.17-134.22 *)
val Int8ArraySlice.modify: (Int8.int -> Int8.int) -> Int8ArraySlice.slice -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array.sml 31.17-31.22 *)
val Int8ArraySlice.modifyi: (int * Int8.int -> Int8.int) -> Int8ArraySlice.slice -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array.sml 30.17-30.23 *)
val Int8ArraySlice.slice: Int8Array.array * int * int option -> Int8ArraySlice.slice (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 206.17-206.21 *)
val Int8ArraySlice.sub: Int8ArraySlice.slice * int -> Int8.int (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 142.17-142.19 *)
val Int8ArraySlice.subslice: Int8ArraySlice.slice * int * int option -> Int8ArraySlice.slice (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 199.17-199.24 *)
val Int8ArraySlice.update: Int8ArraySlice.slice * int * Int8.int -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 155.17-155.22 *)
val Int8ArraySlice.vector: Int8ArraySlice.slice -> Int8Vector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/array.sml 27.17-27.22 *)
structure Int8Vector: MONO_VECTOR where type elem = Int8.int where type vector = Int8Vector.vector (* @ $(SML_LIB)/basis/libs/basis-2002/top-level/top-level.sml 27.11-27.20 *)
type Int8Vector.elem = Int8.int (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-vector.fun 35.12-35.15 *)
type Int8Vector.vector = Int8Vector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-vector.fun 36.12-36.17 *)
val Int8Vector.all: (Int8.int -> bool) -> Int8Vector.vector -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 476.13-476.15 *)
val Int8Vector.app: (Int8.int -> unit) -> Int8Vector.vector -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 464.13-464.15 *)
val Int8Vector.appi: (int * Int8.int -> unit) -> Int8Vector.vector -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 463.13-463.16 *)
val Int8Vector.collate: (Int8.int * Int8.int -> order) -> Int8Vector.vector * Int8Vector.vector -> order (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 477.13-477.19 *)
val Int8Vector.concat: Int8Vector.vector list -> Int8Vector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 462.13-462.18 *)
val Int8Vector.exists: (Int8.int -> bool) -> Int8Vector.vector -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 474.13-474.18 *)
val Int8Vector.find: (Int8.int -> bool) -> Int8Vector.vector -> Int8.int option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 472.13-472.16 *)
val Int8Vector.findi: (int * Int8.int -> bool) -> Int8Vector.vector -> (int * Int8.int) option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 471.13-471.17 *)
val Int8Vector.foldl: (Int8.int * 'a -> 'a) -> 'a -> Int8Vector.vector -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 468.13-468.17 *)
val Int8Vector.foldli: (int * Int8.int * 'a -> 'a) -> 'a -> Int8Vector.vector -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 467.13-467.18 *)
val Int8Vector.foldr: (Int8.int * 'a -> 'a) -> 'a -> Int8Vector.vector -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 470.13-470.17 *)
val Int8Vector.foldri: (int * Int8.int * 'a -> 'a) -> 'a -> Int8Vector.vector -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 469.13-469.18 *)
val Int8Vector.fromList: Int8.int list -> Int8Vector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 122.11-122.18 *)
val Int8Vector.length: Int8Vector.vector -> int (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 90.11-90.16 *)
val Int8Vector.map: (Int8.int -> Int8.int) -> Int8Vector.vector -> Int8Vector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 466.13-466.15 *)
val Int8Vector.mapi: (int * Int8.int -> Int8.int) -> Int8Vector.vector -> Int8Vector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 465.13-465.16 *)
val Int8Vector.maxLen: int (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 88.11-88.16 *)
val Int8Vector.sub: Int8Vector.vector * int -> Int8.int (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 450.13-450.15 *)
val Int8Vector.tabulate: int * (int -> Int8.int) -> Int8Vector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 114.11-114.18 *)
val Int8Vector.update: Int8Vector.vector * int * Int8.int -> Int8Vector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/vector.sml 30.11-30.16 *)
structure Int8VectorSlice: MONO_VECTOR_SLICE where type elem = Int8.int where type slice = Int8VectorSlice.slice where type vector = Int8Vector.vector (* @ $(SML_LIB)/basis/libs/basis-extra/top-level/basis.sml 109.17-109.31 *)
type Int8VectorSlice.elem = Int8.int (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-vector.fun 43.18-43.21 *)
type Int8VectorSlice.slice = Int8VectorSlice.slice (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-vector.fun 45.18-45.22 *)
type Int8VectorSlice.vector = Int8Vector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-vector.fun 44.18-44.23 *)
val Int8VectorSlice.all: (Int8.int -> bool) -> Int8VectorSlice.slice -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 235.17-235.19 *)
val Int8VectorSlice.app: (Int8.int -> unit) -> Int8VectorSlice.slice -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 226.17-226.19 *)
val Int8VectorSlice.appi: (int * Int8.int -> unit) -> Int8VectorSlice.slice -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 225.17-225.20 *)
val Int8VectorSlice.base: Int8VectorSlice.slice -> Int8Vector.vector * int * int (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 208.17-208.20 *)
val Int8VectorSlice.collate: (Int8.int * Int8.int -> order) -> Int8VectorSlice.slice * Int8VectorSlice.slice -> order (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 236.17-236.23 *)
val Int8VectorSlice.concat: Int8VectorSlice.slice list -> Int8Vector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 240.17-240.22 *)
val Int8VectorSlice.exists: (Int8.int -> bool) -> Int8VectorSlice.slice -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 233.17-233.22 *)
val Int8VectorSlice.find: (Int8.int -> bool) -> Int8VectorSlice.slice -> Int8.int option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 231.17-231.20 *)
val Int8VectorSlice.findi: (int * Int8.int -> bool) -> Int8VectorSlice.slice -> (int * Int8.int) option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 229.17-229.21 *)
val Int8VectorSlice.foldl: (Int8.int * 'a -> 'a) -> 'a -> Int8VectorSlice.slice -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 223.17-223.21 *)
val Int8VectorSlice.foldli: (int * Int8.int * 'a -> 'a) -> 'a -> Int8VectorSlice.slice -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 221.17-221.22 *)
val Int8VectorSlice.foldr: (Int8.int * 'a -> 'a) -> 'a -> Int8VectorSlice.slice -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 224.17-224.21 *)
val Int8VectorSlice.foldri: (int * Int8.int * 'a -> 'a) -> 'a -> Int8VectorSlice.slice -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 222.17-222.22 *)
val Int8VectorSlice.full: Int8Vector.vector -> Int8VectorSlice.slice (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 192.17-192.20 *)
val Int8VectorSlice.getItem: Int8VectorSlice.slice -> (Int8.int * Int8VectorSlice.slice) option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 220.17-220.23 *)
val Int8VectorSlice.isEmpty: Int8VectorSlice.slice -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 219.17-219.23 *)
val Int8VectorSlice.length: Int8VectorSlice.slice -> int (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 134.17-134.22 *)
val Int8VectorSlice.map: (Int8.int -> Int8.int) -> Int8VectorSlice.slice -> Int8Vector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 228.17-228.19 *)
val Int8VectorSlice.mapi: (int * Int8.int -> Int8.int) -> Int8VectorSlice.slice -> Int8Vector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 227.17-227.20 *)
val Int8VectorSlice.slice: Int8Vector.vector * int * int option -> Int8VectorSlice.slice (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 206.17-206.21 *)
val Int8VectorSlice.sub: Int8VectorSlice.slice * int -> Int8.int (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 142.17-142.19 *)
val Int8VectorSlice.subslice: Int8VectorSlice.slice * int * int option -> Int8VectorSlice.slice (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 199.17-199.24 *)
val Int8VectorSlice.vector: Int8VectorSlice.slice -> Int8Vector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/vector.sml 21.17-21.22 *)
structure Int9: INTEGER where type int = Int9.int (* @ $(SML_LIB)/basis/libs/basis-extra/top-level/basis.sml 74.17-74.20 *)
type Int9.int = Int9.int (* @ $(SML_LIB)/basis/primitive/prim-basis.sml 113.12-113.14 *)
val Int9.* : Int9.int * Int9.int -> Int9.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 64.17-64.17 *)
val Int9.+ : Int9.int * Int9.int -> Int9.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 65.17-65.17 *)
val Int9.- : Int9.int * Int9.int -> Int9.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 66.17-66.17 *)
val Int9.< : Int9.int * Int9.int -> bool (* @ $(SML_LIB)/basis/integer/embed-int.sml 77.17-77.17 *)
val Int9.<= : Int9.int * Int9.int -> bool (* @ $(SML_LIB)/basis/integer/embed-int.sml 78.17-78.18 *)
val Int9.> : Int9.int * Int9.int -> bool (* @ $(SML_LIB)/basis/integer/embed-int.sml 79.17-79.17 *)
val Int9.>= : Int9.int * Int9.int -> bool (* @ $(SML_LIB)/basis/integer/embed-int.sml 80.17-80.18 *)
val Int9.abs: Int9.int -> Int9.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 93.14-93.16 *)
val Int9.compare: Int9.int * Int9.int -> order (* @ $(SML_LIB)/basis/integer/embed-int.sml 81.14-81.20 *)
val Int9.div: Int9.int * Int9.int -> Int9.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 67.17-67.19 *)
val Int9.fmt: StringCvt.radix -> Int9.int -> string (* @ $(SML_LIB)/basis/integer/embed-int.sml 96.11-96.13 *)
val Int9.fromInt: int -> Int9.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 84.11-84.17 *)
val Int9.fromLarge: LargeInt.int -> Int9.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 98.11-98.19 *)
val Int9.fromString: string -> Int9.int option (* @ $(SML_LIB)/basis/integer/embed-int.sml 100.11-100.20 *)
val Int9.max: Int9.int * Int9.int -> Int9.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 102.11-102.13 *)
val Int9.maxInt: Int9.int option (* @ $(SML_LIB)/basis/integer/embed-int.sml 56.11-56.16 *)
val Int9.min: Int9.int * Int9.int -> Int9.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 104.11-104.13 *)
val Int9.minInt: Int9.int option (* @ $(SML_LIB)/basis/integer/embed-int.sml 58.11-58.16 *)
val Int9.mod: Int9.int * Int9.int -> Int9.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 68.17-68.19 *)
val Int9.precision: int option (* @ $(SML_LIB)/basis/integer/embed-int.sml 39.11-39.19 *)
val Int9.quot: Int9.int * Int9.int -> Int9.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 69.14-69.17 *)
val Int9.rem: Int9.int * Int9.int -> Int9.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 70.14-70.16 *)
val Int9.sameSign: Int9.int * Int9.int -> bool (* @ $(SML_LIB)/basis/integer/embed-int.sml 113.11-113.18 *)
val Int9.scan: StringCvt.radix -> ('a -> (char * 'a) option) -> 'a -> (Int9.int * 'a) option (* @ $(SML_LIB)/basis/integer/embed-int.sml 106.11-106.14 *)
val Int9.sign: Int9.int -> int (* @ $(SML_LIB)/basis/integer/embed-int.sml 111.11-111.14 *)
val Int9.toInt: Int9.int -> int (* @ $(SML_LIB)/basis/integer/embed-int.sml 86.11-86.15 *)
val Int9.toLarge: Int9.int -> LargeInt.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 115.11-115.17 *)
val Int9.toString: Int9.int -> string (* @ $(SML_LIB)/basis/integer/embed-int.sml 117.11-117.18 *)
val Int9.~ : Int9.int -> Int9.int (* @ $(SML_LIB)/basis/integer/embed-int.sml 92.14-92.14 *)
structure IntArray: MONO_ARRAY where type array = IntArray.array where type elem = int where type vector = IntVector.vector (* @ $(SML_LIB)/basis/libs/basis-2002/top-level/top-level.sml 37.11-37.18 *)
type IntArray.array = IntArray.array (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array.fun 23.12-23.16 *)
type IntArray.elem = int (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array.fun 22.12-22.15 *)
type IntArray.vector = IntVector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array.fun 24.12-24.17 *)
val IntArray.all: (int -> bool) -> IntArray.array -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 476.13-476.15 *)
val IntArray.app: (int -> unit) -> IntArray.array -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 464.13-464.15 *)
val IntArray.appi: (int * int -> unit) -> IntArray.array -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 463.13-463.16 *)
val IntArray.array: int * int -> IntArray.array (* @ $(SML_LIB)/basis/arrays-and-vectors/array.sml 34.11-34.15 *)
val IntArray.collate: (int * int -> order) -> IntArray.array * IntArray.array -> order (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 477.13-477.19 *)
val IntArray.copy: {di: int, dst: IntArray.array, src: IntArray.array} -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 457.13-457.16 *)
val IntArray.copyVec: {di: int, dst: IntArray.array, src: IntVector.vector} -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array.sml 37.11-37.17 *)
val IntArray.exists: (int -> bool) -> IntArray.array -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 474.13-474.18 *)
val IntArray.find: (int -> bool) -> IntArray.array -> int option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 472.13-472.16 *)
val IntArray.findi: (int * int -> bool) -> IntArray.array -> (int * int) option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 471.13-471.17 *)
val IntArray.foldl: (int * 'a -> 'a) -> 'a -> IntArray.array -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 468.13-468.17 *)
val IntArray.foldli: (int * int * 'a -> 'a) -> 'a -> IntArray.array -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 467.13-467.18 *)
val IntArray.foldr: (int * 'a -> 'a) -> 'a -> IntArray.array -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 470.13-470.17 *)
val IntArray.foldri: (int * int * 'a -> 'a) -> 'a -> IntArray.array -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 469.13-469.18 *)
val IntArray.fromList: int list -> IntArray.array (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 122.11-122.18 *)
val IntArray.length: IntArray.array -> int (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 90.11-90.16 *)
val IntArray.maxLen: int (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 88.11-88.16 *)
val IntArray.modify: (int -> int) -> IntArray.array -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array.sml 40.11-40.16 *)
val IntArray.modifyi: (int * int -> int) -> IntArray.array -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array.sml 39.11-39.17 *)
val IntArray.sub: IntArray.array * int -> int (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 450.13-450.15 *)
val IntArray.tabulate: int * (int -> int) -> IntArray.array (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 114.11-114.18 *)
val IntArray.update: IntArray.array * int * int -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 452.13-452.18 *)
val IntArray.vector: IntArray.array -> IntVector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/array.sml 36.11-36.16 *)
structure IntArray2: MONO_ARRAY2 where type array = IntArray2.array where type elem = int where type vector = IntVector.vector (* @ $(SML_LIB)/basis/libs/basis-2002/top-level/top-level.sml 38.11-38.19 *)
type IntArray2.array = IntArray2.array (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array2.fun 18.12-18.16 *)
type IntArray2.elem = int (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array2.fun 15.12-15.15 *)
type IntArray2.region = {base: IntArray2.array, col: int, ncols: int option, nrows: int option, row: int} (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array2.fun 19.12-19.17 *)
datatype IntArray2.traversal = ColMajor | RowMajor (* = datatype Array2.traversal *) (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 106.16-106.24 *)
type IntArray2.vector = IntVector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array2.fun 16.12-16.17 *)
con IntArray2.ColMajor: Array2.traversal (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 106.39-106.46 *)
con IntArray2.RowMajor: Array2.traversal (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 106.28-106.35 *)
val IntArray2.app: Array2.traversal -> (int -> unit) -> IntArray2.array -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 294.11-294.13 *)
val IntArray2.appi: Array2.traversal -> (int * int * int -> unit) -> {base: IntArray2.array, col: int, ncols: int option, nrows: int option, row: int} -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 291.11-291.14 *)
val IntArray2.array: int * int * int -> IntArray2.array (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 140.14-140.18 *)
val IntArray2.column: IntArray2.array * int -> IntVector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 237.11-237.16 *)
val IntArray2.copy: {dst: IntArray2.array, dst_col: int, dst_row: int, src: {base: IntArray2.array, col: int, ncols: int option, nrows: int option, row: int}} -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 309.11-309.14 *)
val IntArray2.dimensions: IntArray2.array -> int * int (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 33.11-33.20 *)
val IntArray2.fold: Array2.traversal -> (int * 'a -> 'a) -> 'a -> IntArray2.array -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 288.11-288.14 *)
val IntArray2.foldi: Array2.traversal -> (int * int * int * 'a -> 'a) -> 'a -> {base: IntArray2.array, col: int, ncols: int option, nrows: int option, row: int} -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 283.11-283.15 *)
val IntArray2.fromList: int list list -> IntArray2.array (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 188.14-188.21 *)
val IntArray2.modify: Array2.traversal -> (int -> int) -> IntArray2.array -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 299.11-299.16 *)
val IntArray2.modifyi: Array2.traversal -> (int * int * int -> int) -> {base: IntArray2.array, col: int, ncols: int option, nrows: int option, row: int} -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 296.11-296.17 *)
val IntArray2.nCols: IntArray2.array -> int (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 38.11-38.15 *)
val IntArray2.nRows: IntArray2.array -> int (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 36.11-36.15 *)
val IntArray2.row: IntArray2.array * int -> IntVector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 222.11-222.13 *)
val IntArray2.sub: IntArray2.array * int * int -> int (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 182.14-182.16 *)
val IntArray2.tabulate: Array2.traversal -> int * int * (int * int -> int) -> IntArray2.array (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 301.11-301.18 *)
val IntArray2.update: IntArray2.array * int * int * int -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 184.14-184.19 *)
structure IntArraySlice: MONO_ARRAY_SLICE where type array = IntArray.array where type elem = int where type slice = IntArraySlice.slice where type vector = IntVector.vector where type vector_slice = IntVectorSlice.slice (* @ $(SML_LIB)/basis/libs/basis-extra/top-level/basis.sml 102.17-102.29 *)
type IntArraySlice.array = IntArray.array (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array.fun 35.18-35.22 *)
type IntArraySlice.elem = int (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array.fun 34.18-34.21 *)
type IntArraySlice.slice = IntArraySlice.slice (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array.fun 36.18-36.22 *)
type IntArraySlice.vector = IntVector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array.fun 37.18-37.23 *)
type IntArraySlice.vector_slice = IntVectorSlice.slice (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array.fun 38.18-38.29 *)
val IntArraySlice.all: (int -> bool) -> IntArraySlice.slice -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 235.17-235.19 *)
val IntArraySlice.app: (int -> unit) -> IntArraySlice.slice -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 226.17-226.19 *)
val IntArraySlice.appi: (int * int -> unit) -> IntArraySlice.slice -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 225.17-225.20 *)
val IntArraySlice.base: IntArraySlice.slice -> IntArray.array * int * int (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 208.17-208.20 *)
val IntArraySlice.collate: (int * int -> order) -> IntArraySlice.slice * IntArraySlice.slice -> order (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 236.17-236.23 *)
val IntArraySlice.copy: {di: int, dst: IntArray.array, src: IntArraySlice.slice} -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 185.17-185.20 *)
val IntArraySlice.copyVec: {di: int, dst: IntArray.array, src: IntVectorSlice.slice} -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array.sml 28.17-28.23 *)
val IntArraySlice.exists: (int -> bool) -> IntArraySlice.slice -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 233.17-233.22 *)
val IntArraySlice.find: (int -> bool) -> IntArraySlice.slice -> int option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 231.17-231.20 *)
val IntArraySlice.findi: (int * int -> bool) -> IntArraySlice.slice -> (int * int) option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 229.17-229.21 *)
val IntArraySlice.foldl: (int * 'a -> 'a) -> 'a -> IntArraySlice.slice -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 223.17-223.21 *)
val IntArraySlice.foldli: (int * int * 'a -> 'a) -> 'a -> IntArraySlice.slice -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 221.17-221.22 *)
val IntArraySlice.foldr: (int * 'a -> 'a) -> 'a -> IntArraySlice.slice -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 224.17-224.21 *)
val IntArraySlice.foldri: (int * int * 'a -> 'a) -> 'a -> IntArraySlice.slice -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 222.17-222.22 *)
val IntArraySlice.full: IntArray.array -> IntArraySlice.slice (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 192.17-192.20 *)
val IntArraySlice.getItem: IntArraySlice.slice -> (int * IntArraySlice.slice) option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 220.17-220.23 *)
val IntArraySlice.isEmpty: IntArraySlice.slice -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 219.17-219.23 *)
val IntArraySlice.length: IntArraySlice.slice -> int (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 134.17-134.22 *)
val IntArraySlice.modify: (int -> int) -> IntArraySlice.slice -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array.sml 31.17-31.22 *)
val IntArraySlice.modifyi: (int * int -> int) -> IntArraySlice.slice -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array.sml 30.17-30.23 *)
val IntArraySlice.slice: IntArray.array * int * int option -> IntArraySlice.slice (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 206.17-206.21 *)
val IntArraySlice.sub: IntArraySlice.slice * int -> int (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 142.17-142.19 *)
val IntArraySlice.subslice: IntArraySlice.slice * int * int option -> IntArraySlice.slice (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 199.17-199.24 *)
val IntArraySlice.update: IntArraySlice.slice * int * int -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 155.17-155.22 *)
val IntArraySlice.vector: IntArraySlice.slice -> IntVector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/array.sml 27.17-27.22 *)
structure IntInf: INT_INF where type int = LargeInt.int (* @ $(SML_LIB)/basis/libs/basis-2002/top-level/top-level.sml 80.11-80.16 *)
type IntInf.int = LargeInt.int (* @ $(SML_LIB)/basis/integer/int-inf0.sml 1318.12-1318.14 *)
val IntInf.* : LargeInt.int * LargeInt.int -> LargeInt.int (* @ $(SML_LIB)/basis/integer/int-inf0.sml 1336.14-1336.14 *)
val IntInf.+ : LargeInt.int * LargeInt.int -> LargeInt.int (* @ $(SML_LIB)/basis/integer/int-inf0.sml 1329.14-1329.14 *)
val IntInf.- : LargeInt.int * LargeInt.int -> LargeInt.int (* @ $(SML_LIB)/basis/integer/int-inf0.sml 1345.14-1345.14 *)
val IntInf.< : LargeInt.int * LargeInt.int -> bool (* @ $(SML_LIB)/basis/integer/int-inf0.sml 1347.14-1347.14 *)
val IntInf.<< : LargeInt.int * word -> LargeInt.int (* @ $(SML_LIB)/basis/integer/int-inf.sml 47.14-47.15 *)
val IntInf.<= : LargeInt.int * LargeInt.int -> bool (* @ $(SML_LIB)/basis/integer/int-inf0.sml 1348.14-1348.15 *)
val IntInf.> : LargeInt.int * LargeInt.int -> bool (* @ $(SML_LIB)/basis/integer/int-inf0.sml 1349.14-1349.14 *)
val IntInf.>= : LargeInt.int * LargeInt.int -> bool (* @ $(SML_LIB)/basis/integer/int-inf0.sml 1350.14-1350.15 *)
val IntInf.abs: LargeInt.int -> LargeInt.int (* @ $(SML_LIB)/basis/integer/int-inf0.sml 1326.11-1326.13 *)
val IntInf.andb: LargeInt.int * LargeInt.int -> LargeInt.int (* @ $(SML_LIB)/basis/integer/int-inf0.sml 1359.11-1359.14 *)
val IntInf.compare: LargeInt.int * LargeInt.int -> order (* @ $(SML_LIB)/basis/integer/int-inf0.sml 1351.11-1351.17 *)
val IntInf.div: LargeInt.int * LargeInt.int -> LargeInt.int (* @ $(SML_LIB)/basis/integer/int-inf0.sml 1331.14-1331.16 *)
val IntInf.divMod: LargeInt.int * LargeInt.int -> LargeInt.int * LargeInt.int (* @ $(SML_LIB)/basis/integer/int-inf0.sml 1330.11-1330.16 *)
val IntInf.fmt: StringCvt.radix -> LargeInt.int -> string (* @ $(SML_LIB)/basis/integer/int-inf.sml 64.14-64.16 *)
val IntInf.fromInt: int -> LargeInt.int (* @ $(SML_LIB)/basis/integer/int-inf.sml 51.11-51.17 *)
val IntInf.fromLarge: LargeInt.int -> LargeInt.int (* @ $(SML_LIB)/basis/integer/int-inf.sml 53.11-53.19 *)
val IntInf.fromString: string -> LargeInt.int option (* @ $(SML_LIB)/basis/integer/int-inf.sml 300.11-300.20 *)
val IntInf.log2: LargeInt.int -> int (* @ $(SML_LIB)/basis/integer/int-inf.sml 331.11-331.14 *)
val IntInf.max: LargeInt.int * LargeInt.int -> LargeInt.int (* @ $(SML_LIB)/basis/integer/int-inf0.sml 1353.11-1353.13 *)
val IntInf.maxInt: LargeInt.int option (* @ $(SML_LIB)/basis/integer/int-inf0.sml 1323.11-1323.16 *)
val IntInf.min: LargeInt.int * LargeInt.int -> LargeInt.int (* @ $(SML_LIB)/basis/integer/int-inf0.sml 1352.11-1352.13 *)
val IntInf.minInt: LargeInt.int option (* @ $(SML_LIB)/basis/integer/int-inf0.sml 1324.11-1324.16 *)
val IntInf.mod: LargeInt.int * LargeInt.int -> LargeInt.int (* @ $(SML_LIB)/basis/integer/int-inf0.sml 1333.14-1333.16 *)
val IntInf.notb: LargeInt.int -> LargeInt.int (* @ $(SML_LIB)/basis/integer/int-inf0.sml 1362.11-1362.14 *)
val IntInf.orb: LargeInt.int * LargeInt.int -> LargeInt.int (* @ $(SML_LIB)/basis/integer/int-inf0.sml 1363.11-1363.13 *)
val IntInf.pow: LargeInt.int * int -> LargeInt.int (* @ $(SML_LIB)/basis/integer/int-inf.sml 305.14-305.16 *)
val IntInf.precision: int option (* @ $(SML_LIB)/basis/integer/int-inf.sml 22.11-22.19 *)
val IntInf.quot: LargeInt.int * LargeInt.int -> LargeInt.int (* @ $(SML_LIB)/basis/integer/int-inf0.sml 1341.11-1341.14 *)
val IntInf.quotRem: LargeInt.int * LargeInt.int -> LargeInt.int * LargeInt.int (* @ $(SML_LIB)/basis/integer/int-inf0.sml 1340.11-1340.17 *)
val IntInf.rem: LargeInt.int * LargeInt.int -> LargeInt.int (* @ $(SML_LIB)/basis/integer/int-inf0.sml 1342.11-1342.13 *)
val IntInf.sameSign: LargeInt.int * LargeInt.int -> bool (* @ $(SML_LIB)/basis/integer/int-inf.sml 30.11-30.18 *)
val IntInf.scan: StringCvt.radix -> ('a -> (char * 'a) option) -> 'a -> (LargeInt.int * 'a) option (* @ $(SML_LIB)/basis/integer/int-inf.sml 292.14-292.17 *)
val IntInf.sign: LargeInt.int -> int (* @ $(SML_LIB)/basis/integer/int-inf.sml 24.11-24.14 *)
val IntInf.toInt: LargeInt.int -> int (* @ $(SML_LIB)/basis/integer/int-inf.sml 52.11-52.15 *)
val IntInf.toLarge: LargeInt.int -> LargeInt.int (* @ $(SML_LIB)/basis/integer/int-inf.sml 54.11-54.17 *)
val IntInf.toString: LargeInt.int -> string (* @ $(SML_LIB)/basis/integer/int-inf.sml 70.14-70.21 *)
val IntInf.xorb: LargeInt.int * LargeInt.int -> LargeInt.int (* @ $(SML_LIB)/basis/integer/int-inf0.sml 1366.11-1366.14 *)
val IntInf.~ : LargeInt.int -> LargeInt.int (* @ $(SML_LIB)/basis/integer/int-inf0.sml 1339.14-1339.14 *)
val IntInf.~>> : LargeInt.int * word -> LargeInt.int (* @ $(SML_LIB)/basis/integer/int-inf.sml 48.14-48.16 *)
structure IntVector: MONO_VECTOR where type elem = int where type vector = IntVector.vector (* @ $(SML_LIB)/basis/libs/basis-2002/top-level/top-level.sml 39.11-39.19 *)
type IntVector.elem = int (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-vector.fun 35.12-35.15 *)
type IntVector.vector = IntVector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-vector.fun 36.12-36.17 *)
val IntVector.all: (int -> bool) -> IntVector.vector -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 476.13-476.15 *)
val IntVector.app: (int -> unit) -> IntVector.vector -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 464.13-464.15 *)
val IntVector.appi: (int * int -> unit) -> IntVector.vector -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 463.13-463.16 *)
val IntVector.collate: (int * int -> order) -> IntVector.vector * IntVector.vector -> order (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 477.13-477.19 *)
val IntVector.concat: IntVector.vector list -> IntVector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 462.13-462.18 *)
val IntVector.exists: (int -> bool) -> IntVector.vector -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 474.13-474.18 *)
val IntVector.find: (int -> bool) -> IntVector.vector -> int option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 472.13-472.16 *)
val IntVector.findi: (int * int -> bool) -> IntVector.vector -> (int * int) option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 471.13-471.17 *)
val IntVector.foldl: (int * 'a -> 'a) -> 'a -> IntVector.vector -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 468.13-468.17 *)
val IntVector.foldli: (int * int * 'a -> 'a) -> 'a -> IntVector.vector -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 467.13-467.18 *)
val IntVector.foldr: (int * 'a -> 'a) -> 'a -> IntVector.vector -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 470.13-470.17 *)
val IntVector.foldri: (int * int * 'a -> 'a) -> 'a -> IntVector.vector -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 469.13-469.18 *)
val IntVector.fromList: int list -> IntVector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 122.11-122.18 *)
val IntVector.length: IntVector.vector -> int (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 90.11-90.16 *)
val IntVector.map: (int -> int) -> IntVector.vector -> IntVector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 466.13-466.15 *)
val IntVector.mapi: (int * int -> int) -> IntVector.vector -> IntVector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 465.13-465.16 *)
val IntVector.maxLen: int (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 88.11-88.16 *)
val IntVector.sub: IntVector.vector * int -> int (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 450.13-450.15 *)
val IntVector.tabulate: int * (int -> int) -> IntVector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 114.11-114.18 *)
val IntVector.update: IntVector.vector * int * int -> IntVector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/vector.sml 30.11-30.16 *)
structure IntVectorSlice: MONO_VECTOR_SLICE where type elem = int where type slice = IntVectorSlice.slice where type vector = IntVector.vector (* @ $(SML_LIB)/basis/libs/basis-extra/top-level/basis.sml 104.17-104.30 *)
type IntVectorSlice.elem = int (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-vector.fun 43.18-43.21 *)
type IntVectorSlice.slice = IntVectorSlice.slice (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-vector.fun 45.18-45.22 *)
type IntVectorSlice.vector = IntVector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-vector.fun 44.18-44.23 *)
val IntVectorSlice.all: (int -> bool) -> IntVectorSlice.slice -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 235.17-235.19 *)
val IntVectorSlice.app: (int -> unit) -> IntVectorSlice.slice -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 226.17-226.19 *)
val IntVectorSlice.appi: (int * int -> unit) -> IntVectorSlice.slice -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 225.17-225.20 *)
val IntVectorSlice.base: IntVectorSlice.slice -> IntVector.vector * int * int (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 208.17-208.20 *)
val IntVectorSlice.collate: (int * int -> order) -> IntVectorSlice.slice * IntVectorSlice.slice -> order (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 236.17-236.23 *)
val IntVectorSlice.concat: IntVectorSlice.slice list -> IntVector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 240.17-240.22 *)
val IntVectorSlice.exists: (int -> bool) -> IntVectorSlice.slice -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 233.17-233.22 *)
val IntVectorSlice.find: (int -> bool) -> IntVectorSlice.slice -> int option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 231.17-231.20 *)
val IntVectorSlice.findi: (int * int -> bool) -> IntVectorSlice.slice -> (int * int) option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 229.17-229.21 *)
val IntVectorSlice.foldl: (int * 'a -> 'a) -> 'a -> IntVectorSlice.slice -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 223.17-223.21 *)
val IntVectorSlice.foldli: (int * int * 'a -> 'a) -> 'a -> IntVectorSlice.slice -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 221.17-221.22 *)
val IntVectorSlice.foldr: (int * 'a -> 'a) -> 'a -> IntVectorSlice.slice -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 224.17-224.21 *)
val IntVectorSlice.foldri: (int * int * 'a -> 'a) -> 'a -> IntVectorSlice.slice -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 222.17-222.22 *)
val IntVectorSlice.full: IntVector.vector -> IntVectorSlice.slice (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 192.17-192.20 *)
val IntVectorSlice.getItem: IntVectorSlice.slice -> (int * IntVectorSlice.slice) option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 220.17-220.23 *)
val IntVectorSlice.isEmpty: IntVectorSlice.slice -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 219.17-219.23 *)
val IntVectorSlice.length: IntVectorSlice.slice -> int (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 134.17-134.22 *)
val IntVectorSlice.map: (int -> int) -> IntVectorSlice.slice -> IntVector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 228.17-228.19 *)
val IntVectorSlice.mapi: (int * int -> int) -> IntVectorSlice.slice -> IntVector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 227.17-227.20 *)
val IntVectorSlice.slice: IntVector.vector * int * int option -> IntVectorSlice.slice (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 206.17-206.21 *)
val IntVectorSlice.sub: IntVectorSlice.slice * int -> int (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 142.17-142.19 *)
val IntVectorSlice.subslice: IntVectorSlice.slice * int * int option -> IntVectorSlice.slice (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 199.17-199.24 *)
val IntVectorSlice.vector: IntVectorSlice.slice -> IntVector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/vector.sml 21.17-21.22 *)
structure LargeInt: INTEGER where type int = LargeInt.int (* @ $(SML_LIB)/basis/libs/basis-2002/top-level/top-level.sml 81.11-81.18 *)
type LargeInt.int = LargeInt.int (* @ $(SML_LIB)/basis/integer/int-inf0.sml 1318.12-1318.14 *)
val LargeInt.* : LargeInt.int * LargeInt.int -> LargeInt.int (* @ $(SML_LIB)/basis/integer/int-inf0.sml 1336.14-1336.14 *)
val LargeInt.+ : LargeInt.int * LargeInt.int -> LargeInt.int (* @ $(SML_LIB)/basis/integer/int-inf0.sml 1329.14-1329.14 *)
val LargeInt.- : LargeInt.int * LargeInt.int -> LargeInt.int (* @ $(SML_LIB)/basis/integer/int-inf0.sml 1345.14-1345.14 *)
val LargeInt.< : LargeInt.int * LargeInt.int -> bool (* @ $(SML_LIB)/basis/integer/int-inf0.sml 1347.14-1347.14 *)
val LargeInt.<= : LargeInt.int * LargeInt.int -> bool (* @ $(SML_LIB)/basis/integer/int-inf0.sml 1348.14-1348.15 *)
val LargeInt.> : LargeInt.int * LargeInt.int -> bool (* @ $(SML_LIB)/basis/integer/int-inf0.sml 1349.14-1349.14 *)
val LargeInt.>= : LargeInt.int * LargeInt.int -> bool (* @ $(SML_LIB)/basis/integer/int-inf0.sml 1350.14-1350.15 *)
val LargeInt.abs: LargeInt.int -> LargeInt.int (* @ $(SML_LIB)/basis/integer/int-inf0.sml 1326.11-1326.13 *)
val LargeInt.compare: LargeInt.int * LargeInt.int -> order (* @ $(SML_LIB)/basis/integer/int-inf0.sml 1351.11-1351.17 *)
val LargeInt.div: LargeInt.int * LargeInt.int -> LargeInt.int (* @ $(SML_LIB)/basis/integer/int-inf0.sml 1331.14-1331.16 *)
val LargeInt.fmt: StringCvt.radix -> LargeInt.int -> string (* @ $(SML_LIB)/basis/integer/int-inf.sml 64.14-64.16 *)
val LargeInt.fromInt: int -> LargeInt.int (* @ $(SML_LIB)/basis/integer/int-inf.sml 51.11-51.17 *)
val LargeInt.fromLarge: LargeInt.int -> LargeInt.int (* @ $(SML_LIB)/basis/integer/int-inf.sml 53.11-53.19 *)
val LargeInt.fromString: string -> LargeInt.int option (* @ $(SML_LIB)/basis/integer/int-inf.sml 300.11-300.20 *)
val LargeInt.max: LargeInt.int * LargeInt.int -> LargeInt.int (* @ $(SML_LIB)/basis/integer/int-inf0.sml 1353.11-1353.13 *)
val LargeInt.maxInt: LargeInt.int option (* @ $(SML_LIB)/basis/integer/int-inf0.sml 1323.11-1323.16 *)
val LargeInt.min: LargeInt.int * LargeInt.int -> LargeInt.int (* @ $(SML_LIB)/basis/integer/int-inf0.sml 1352.11-1352.13 *)
val LargeInt.minInt: LargeInt.int option (* @ $(SML_LIB)/basis/integer/int-inf0.sml 1324.11-1324.16 *)
val LargeInt.mod: LargeInt.int * LargeInt.int -> LargeInt.int (* @ $(SML_LIB)/basis/integer/int-inf0.sml 1333.14-1333.16 *)
val LargeInt.precision: int option (* @ $(SML_LIB)/basis/integer/int-inf.sml 22.11-22.19 *)
val LargeInt.quot: LargeInt.int * LargeInt.int -> LargeInt.int (* @ $(SML_LIB)/basis/integer/int-inf0.sml 1341.11-1341.14 *)
val LargeInt.rem: LargeInt.int * LargeInt.int -> LargeInt.int (* @ $(SML_LIB)/basis/integer/int-inf0.sml 1342.11-1342.13 *)
val LargeInt.sameSign: LargeInt.int * LargeInt.int -> bool (* @ $(SML_LIB)/basis/integer/int-inf.sml 30.11-30.18 *)
val LargeInt.scan: StringCvt.radix -> ('a -> (char * 'a) option) -> 'a -> (LargeInt.int * 'a) option (* @ $(SML_LIB)/basis/integer/int-inf.sml 292.14-292.17 *)
val LargeInt.sign: LargeInt.int -> int (* @ $(SML_LIB)/basis/integer/int-inf.sml 24.11-24.14 *)
val LargeInt.toInt: LargeInt.int -> int (* @ $(SML_LIB)/basis/integer/int-inf.sml 52.11-52.15 *)
val LargeInt.toLarge: LargeInt.int -> LargeInt.int (* @ $(SML_LIB)/basis/integer/int-inf.sml 54.11-54.17 *)
val LargeInt.toString: LargeInt.int -> string (* @ $(SML_LIB)/basis/integer/int-inf.sml 70.14-70.21 *)
val LargeInt.~ : LargeInt.int -> LargeInt.int (* @ $(SML_LIB)/basis/integer/int-inf0.sml 1339.14-1339.14 *)
structure LargeIntArray: MONO_ARRAY where type array = LargeIntArray.array where type elem = LargeInt.int where type vector = LargeIntVector.vector (* @ $(SML_LIB)/basis/libs/basis-2002/top-level/top-level.sml 40.11-40.23 *)
type LargeIntArray.array = LargeIntArray.array (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array.fun 23.12-23.16 *)
type LargeIntArray.elem = LargeInt.int (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array.fun 22.12-22.15 *)
type LargeIntArray.vector = LargeIntVector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array.fun 24.12-24.17 *)
val LargeIntArray.all: (LargeInt.int -> bool) -> LargeIntArray.array -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 476.13-476.15 *)
val LargeIntArray.app: (LargeInt.int -> unit) -> LargeIntArray.array -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 464.13-464.15 *)
val LargeIntArray.appi: (int * LargeInt.int -> unit) -> LargeIntArray.array -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 463.13-463.16 *)
val LargeIntArray.array: int * LargeInt.int -> LargeIntArray.array (* @ $(SML_LIB)/basis/arrays-and-vectors/array.sml 34.11-34.15 *)
val LargeIntArray.collate: (LargeInt.int * LargeInt.int -> order) -> LargeIntArray.array * LargeIntArray.array -> order (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 477.13-477.19 *)
val LargeIntArray.copy: {di: int, dst: LargeIntArray.array, src: LargeIntArray.array} -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 457.13-457.16 *)
val LargeIntArray.copyVec: {di: int, dst: LargeIntArray.array, src: LargeIntVector.vector} -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array.sml 37.11-37.17 *)
val LargeIntArray.exists: (LargeInt.int -> bool) -> LargeIntArray.array -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 474.13-474.18 *)
val LargeIntArray.find: (LargeInt.int -> bool) -> LargeIntArray.array -> LargeInt.int option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 472.13-472.16 *)
val LargeIntArray.findi: (int * LargeInt.int -> bool) -> LargeIntArray.array -> (int * LargeInt.int) option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 471.13-471.17 *)
val LargeIntArray.foldl: (LargeInt.int * 'a -> 'a) -> 'a -> LargeIntArray.array -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 468.13-468.17 *)
val LargeIntArray.foldli: (int * LargeInt.int * 'a -> 'a) -> 'a -> LargeIntArray.array -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 467.13-467.18 *)
val LargeIntArray.foldr: (LargeInt.int * 'a -> 'a) -> 'a -> LargeIntArray.array -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 470.13-470.17 *)
val LargeIntArray.foldri: (int * LargeInt.int * 'a -> 'a) -> 'a -> LargeIntArray.array -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 469.13-469.18 *)
val LargeIntArray.fromList: LargeInt.int list -> LargeIntArray.array (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 122.11-122.18 *)
val LargeIntArray.length: LargeIntArray.array -> int (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 90.11-90.16 *)
val LargeIntArray.maxLen: int (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 88.11-88.16 *)
val LargeIntArray.modify: (LargeInt.int -> LargeInt.int) -> LargeIntArray.array -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array.sml 40.11-40.16 *)
val LargeIntArray.modifyi: (int * LargeInt.int -> LargeInt.int) -> LargeIntArray.array -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array.sml 39.11-39.17 *)
val LargeIntArray.sub: LargeIntArray.array * int -> LargeInt.int (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 450.13-450.15 *)
val LargeIntArray.tabulate: int * (int -> LargeInt.int) -> LargeIntArray.array (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 114.11-114.18 *)
val LargeIntArray.update: LargeIntArray.array * int * LargeInt.int -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 452.13-452.18 *)
val LargeIntArray.vector: LargeIntArray.array -> LargeIntVector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/array.sml 36.11-36.16 *)
structure LargeIntArray2: MONO_ARRAY2 where type array = LargeIntArray2.array where type elem = LargeInt.int where type vector = LargeIntVector.vector (* @ $(SML_LIB)/basis/libs/basis-2002/top-level/top-level.sml 41.11-41.24 *)
type LargeIntArray2.array = LargeIntArray2.array (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array2.fun 18.12-18.16 *)
type LargeIntArray2.elem = LargeInt.int (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array2.fun 15.12-15.15 *)
type LargeIntArray2.region = {base: LargeIntArray2.array, col: int, ncols: int option, nrows: int option, row: int} (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array2.fun 19.12-19.17 *)
datatype LargeIntArray2.traversal = ColMajor | RowMajor (* = datatype Array2.traversal *) (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 106.16-106.24 *)
type LargeIntArray2.vector = LargeIntVector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array2.fun 16.12-16.17 *)
con LargeIntArray2.ColMajor: Array2.traversal (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 106.39-106.46 *)
con LargeIntArray2.RowMajor: Array2.traversal (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 106.28-106.35 *)
val LargeIntArray2.app: Array2.traversal -> (LargeInt.int -> unit) -> LargeIntArray2.array -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 294.11-294.13 *)
val LargeIntArray2.appi: Array2.traversal -> (int * int * LargeInt.int -> unit) -> {base: LargeIntArray2.array, col: int, ncols: int option, nrows: int option, row: int} -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 291.11-291.14 *)
val LargeIntArray2.array: int * int * LargeInt.int -> LargeIntArray2.array (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 140.14-140.18 *)
val LargeIntArray2.column: LargeIntArray2.array * int -> LargeIntVector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 237.11-237.16 *)
val LargeIntArray2.copy: {dst: LargeIntArray2.array, dst_col: int, dst_row: int, src: {base: LargeIntArray2.array, col: int, ncols: int option, nrows: int option, row: int}} -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 309.11-309.14 *)
val LargeIntArray2.dimensions: LargeIntArray2.array -> int * int (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 33.11-33.20 *)
val LargeIntArray2.fold: Array2.traversal -> (LargeInt.int * 'a -> 'a) -> 'a -> LargeIntArray2.array -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 288.11-288.14 *)
val LargeIntArray2.foldi: Array2.traversal -> (int * int * LargeInt.int * 'a -> 'a) -> 'a -> {base: LargeIntArray2.array, col: int, ncols: int option, nrows: int option, row: int} -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 283.11-283.15 *)
val LargeIntArray2.fromList: LargeInt.int list list -> LargeIntArray2.array (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 188.14-188.21 *)
val LargeIntArray2.modify: Array2.traversal -> (LargeInt.int -> LargeInt.int) -> LargeIntArray2.array -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 299.11-299.16 *)
val LargeIntArray2.modifyi: Array2.traversal -> (int * int * LargeInt.int -> LargeInt.int) -> {base: LargeIntArray2.array, col: int, ncols: int option, nrows: int option, row: int} -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 296.11-296.17 *)
val LargeIntArray2.nCols: LargeIntArray2.array -> int (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 38.11-38.15 *)
val LargeIntArray2.nRows: LargeIntArray2.array -> int (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 36.11-36.15 *)
val LargeIntArray2.row: LargeIntArray2.array * int -> LargeIntVector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 222.11-222.13 *)
val LargeIntArray2.sub: LargeIntArray2.array * int * int -> LargeInt.int (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 182.14-182.16 *)
val LargeIntArray2.tabulate: Array2.traversal -> int * int * (int * int -> LargeInt.int) -> LargeIntArray2.array (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 301.11-301.18 *)
val LargeIntArray2.update: LargeIntArray2.array * int * int * LargeInt.int -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 184.14-184.19 *)
structure LargeIntArraySlice: MONO_ARRAY_SLICE where type array = LargeIntArray.array where type elem = LargeInt.int where type slice = LargeIntArraySlice.slice where type vector = LargeIntVector.vector where type vector_slice = LargeIntVectorSlice.slice (* @ $(SML_LIB)/basis/libs/basis-extra/top-level/basis.sml 133.17-133.34 *)
type LargeIntArraySlice.array = LargeIntArray.array (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array.fun 35.18-35.22 *)
type LargeIntArraySlice.elem = LargeInt.int (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array.fun 34.18-34.21 *)
type LargeIntArraySlice.slice = LargeIntArraySlice.slice (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array.fun 36.18-36.22 *)
type LargeIntArraySlice.vector = LargeIntVector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array.fun 37.18-37.23 *)
type LargeIntArraySlice.vector_slice = LargeIntVectorSlice.slice (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array.fun 38.18-38.29 *)
val LargeIntArraySlice.all: (LargeInt.int -> bool) -> LargeIntArraySlice.slice -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 235.17-235.19 *)
val LargeIntArraySlice.app: (LargeInt.int -> unit) -> LargeIntArraySlice.slice -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 226.17-226.19 *)
val LargeIntArraySlice.appi: (int * LargeInt.int -> unit) -> LargeIntArraySlice.slice -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 225.17-225.20 *)
val LargeIntArraySlice.base: LargeIntArraySlice.slice -> LargeIntArray.array * int * int (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 208.17-208.20 *)
val LargeIntArraySlice.collate: (LargeInt.int * LargeInt.int -> order) -> LargeIntArraySlice.slice * LargeIntArraySlice.slice -> order (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 236.17-236.23 *)
val LargeIntArraySlice.copy: {di: int, dst: LargeIntArray.array, src: LargeIntArraySlice.slice} -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 185.17-185.20 *)
val LargeIntArraySlice.copyVec: {di: int, dst: LargeIntArray.array, src: LargeIntVectorSlice.slice} -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array.sml 28.17-28.23 *)
val LargeIntArraySlice.exists: (LargeInt.int -> bool) -> LargeIntArraySlice.slice -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 233.17-233.22 *)
val LargeIntArraySlice.find: (LargeInt.int -> bool) -> LargeIntArraySlice.slice -> LargeInt.int option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 231.17-231.20 *)
val LargeIntArraySlice.findi: (int * LargeInt.int -> bool) -> LargeIntArraySlice.slice -> (int * LargeInt.int) option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 229.17-229.21 *)
val LargeIntArraySlice.foldl: (LargeInt.int * 'a -> 'a) -> 'a -> LargeIntArraySlice.slice -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 223.17-223.21 *)
val LargeIntArraySlice.foldli: (int * LargeInt.int * 'a -> 'a) -> 'a -> LargeIntArraySlice.slice -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 221.17-221.22 *)
val LargeIntArraySlice.foldr: (LargeInt.int * 'a -> 'a) -> 'a -> LargeIntArraySlice.slice -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 224.17-224.21 *)
val LargeIntArraySlice.foldri: (int * LargeInt.int * 'a -> 'a) -> 'a -> LargeIntArraySlice.slice -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 222.17-222.22 *)
val LargeIntArraySlice.full: LargeIntArray.array -> LargeIntArraySlice.slice (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 192.17-192.20 *)
val LargeIntArraySlice.getItem: LargeIntArraySlice.slice -> (LargeInt.int * LargeIntArraySlice.slice) option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 220.17-220.23 *)
val LargeIntArraySlice.isEmpty: LargeIntArraySlice.slice -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 219.17-219.23 *)
val LargeIntArraySlice.length: LargeIntArraySlice.slice -> int (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 134.17-134.22 *)
val LargeIntArraySlice.modify: (LargeInt.int -> LargeInt.int) -> LargeIntArraySlice.slice -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array.sml 31.17-31.22 *)
val LargeIntArraySlice.modifyi: (int * LargeInt.int -> LargeInt.int) -> LargeIntArraySlice.slice -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array.sml 30.17-30.23 *)
val LargeIntArraySlice.slice: LargeIntArray.array * int * int option -> LargeIntArraySlice.slice (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 206.17-206.21 *)
val LargeIntArraySlice.sub: LargeIntArraySlice.slice * int -> LargeInt.int (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 142.17-142.19 *)
val LargeIntArraySlice.subslice: LargeIntArraySlice.slice * int * int option -> LargeIntArraySlice.slice (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 199.17-199.24 *)
val LargeIntArraySlice.update: LargeIntArraySlice.slice * int * LargeInt.int -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 155.17-155.22 *)
val LargeIntArraySlice.vector: LargeIntArraySlice.slice -> LargeIntVector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/array.sml 27.17-27.22 *)
structure LargeIntVector: MONO_VECTOR where type elem = LargeInt.int where type vector = LargeIntVector.vector (* @ $(SML_LIB)/basis/libs/basis-2002/top-level/top-level.sml 42.11-42.24 *)
type LargeIntVector.elem = LargeInt.int (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-vector.fun 35.12-35.15 *)
type LargeIntVector.vector = LargeIntVector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-vector.fun 36.12-36.17 *)
val LargeIntVector.all: (LargeInt.int -> bool) -> LargeIntVector.vector -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 476.13-476.15 *)
val LargeIntVector.app: (LargeInt.int -> unit) -> LargeIntVector.vector -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 464.13-464.15 *)
val LargeIntVector.appi: (int * LargeInt.int -> unit) -> LargeIntVector.vector -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 463.13-463.16 *)
val LargeIntVector.collate: (LargeInt.int * LargeInt.int -> order) -> LargeIntVector.vector * LargeIntVector.vector -> order (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 477.13-477.19 *)
val LargeIntVector.concat: LargeIntVector.vector list -> LargeIntVector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 462.13-462.18 *)
val LargeIntVector.exists: (LargeInt.int -> bool) -> LargeIntVector.vector -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 474.13-474.18 *)
val LargeIntVector.find: (LargeInt.int -> bool) -> LargeIntVector.vector -> LargeInt.int option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 472.13-472.16 *)
val LargeIntVector.findi: (int * LargeInt.int -> bool) -> LargeIntVector.vector -> (int * LargeInt.int) option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 471.13-471.17 *)
val LargeIntVector.foldl: (LargeInt.int * 'a -> 'a) -> 'a -> LargeIntVector.vector -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 468.13-468.17 *)
val LargeIntVector.foldli: (int * LargeInt.int * 'a -> 'a) -> 'a -> LargeIntVector.vector -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 467.13-467.18 *)
val LargeIntVector.foldr: (LargeInt.int * 'a -> 'a) -> 'a -> LargeIntVector.vector -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 470.13-470.17 *)
val LargeIntVector.foldri: (int * LargeInt.int * 'a -> 'a) -> 'a -> LargeIntVector.vector -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 469.13-469.18 *)
val LargeIntVector.fromList: LargeInt.int list -> LargeIntVector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 122.11-122.18 *)
val LargeIntVector.length: LargeIntVector.vector -> int (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 90.11-90.16 *)
val LargeIntVector.map: (LargeInt.int -> LargeInt.int) -> LargeIntVector.vector -> LargeIntVector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 466.13-466.15 *)
val LargeIntVector.mapi: (int * LargeInt.int -> LargeInt.int) -> LargeIntVector.vector -> LargeIntVector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 465.13-465.16 *)
val LargeIntVector.maxLen: int (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 88.11-88.16 *)
val LargeIntVector.sub: LargeIntVector.vector * int -> LargeInt.int (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 450.13-450.15 *)
val LargeIntVector.tabulate: int * (int -> LargeInt.int) -> LargeIntVector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 114.11-114.18 *)
val LargeIntVector.update: LargeIntVector.vector * int * LargeInt.int -> LargeIntVector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/vector.sml 30.11-30.16 *)
structure LargeIntVectorSlice: MONO_VECTOR_SLICE where type elem = LargeInt.int where type slice = LargeIntVectorSlice.slice where type vector = LargeIntVector.vector (* @ $(SML_LIB)/basis/libs/basis-extra/top-level/basis.sml 135.17-135.35 *)
type LargeIntVectorSlice.elem = LargeInt.int (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-vector.fun 43.18-43.21 *)
type LargeIntVectorSlice.slice = LargeIntVectorSlice.slice (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-vector.fun 45.18-45.22 *)
type LargeIntVectorSlice.vector = LargeIntVector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-vector.fun 44.18-44.23 *)
val LargeIntVectorSlice.all: (LargeInt.int -> bool) -> LargeIntVectorSlice.slice -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 235.17-235.19 *)
val LargeIntVectorSlice.app: (LargeInt.int -> unit) -> LargeIntVectorSlice.slice -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 226.17-226.19 *)
val LargeIntVectorSlice.appi: (int * LargeInt.int -> unit) -> LargeIntVectorSlice.slice -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 225.17-225.20 *)
val LargeIntVectorSlice.base: LargeIntVectorSlice.slice -> LargeIntVector.vector * int * int (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 208.17-208.20 *)
val LargeIntVectorSlice.collate: (LargeInt.int * LargeInt.int -> order) -> LargeIntVectorSlice.slice * LargeIntVectorSlice.slice -> order (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 236.17-236.23 *)
val LargeIntVectorSlice.concat: LargeIntVectorSlice.slice list -> LargeIntVector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 240.17-240.22 *)
val LargeIntVectorSlice.exists: (LargeInt.int -> bool) -> LargeIntVectorSlice.slice -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 233.17-233.22 *)
val LargeIntVectorSlice.find: (LargeInt.int -> bool) -> LargeIntVectorSlice.slice -> LargeInt.int option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 231.17-231.20 *)
val LargeIntVectorSlice.findi: (int * LargeInt.int -> bool) -> LargeIntVectorSlice.slice -> (int * LargeInt.int) option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 229.17-229.21 *)
val LargeIntVectorSlice.foldl: (LargeInt.int * 'a -> 'a) -> 'a -> LargeIntVectorSlice.slice -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 223.17-223.21 *)
val LargeIntVectorSlice.foldli: (int * LargeInt.int * 'a -> 'a) -> 'a -> LargeIntVectorSlice.slice -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 221.17-221.22 *)
val LargeIntVectorSlice.foldr: (LargeInt.int * 'a -> 'a) -> 'a -> LargeIntVectorSlice.slice -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 224.17-224.21 *)
val LargeIntVectorSlice.foldri: (int * LargeInt.int * 'a -> 'a) -> 'a -> LargeIntVectorSlice.slice -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 222.17-222.22 *)
val LargeIntVectorSlice.full: LargeIntVector.vector -> LargeIntVectorSlice.slice (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 192.17-192.20 *)
val LargeIntVectorSlice.getItem: LargeIntVectorSlice.slice -> (LargeInt.int * LargeIntVectorSlice.slice) option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 220.17-220.23 *)
val LargeIntVectorSlice.isEmpty: LargeIntVectorSlice.slice -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 219.17-219.23 *)
val LargeIntVectorSlice.length: LargeIntVectorSlice.slice -> int (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 134.17-134.22 *)
val LargeIntVectorSlice.map: (LargeInt.int -> LargeInt.int) -> LargeIntVectorSlice.slice -> LargeIntVector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 228.17-228.19 *)
val LargeIntVectorSlice.mapi: (int * LargeInt.int -> LargeInt.int) -> LargeIntVectorSlice.slice -> LargeIntVector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 227.17-227.20 *)
val LargeIntVectorSlice.slice: LargeIntVector.vector * int * int option -> LargeIntVectorSlice.slice (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 206.17-206.21 *)
val LargeIntVectorSlice.sub: LargeIntVectorSlice.slice * int -> LargeInt.int (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 142.17-142.19 *)
val LargeIntVectorSlice.subslice: LargeIntVectorSlice.slice * int * int option -> LargeIntVectorSlice.slice (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 199.17-199.24 *)
val LargeIntVectorSlice.vector: LargeIntVectorSlice.slice -> LargeIntVector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/vector.sml 21.17-21.22 *)
structure LargeReal: REAL where type real = real (* @ $(SML_LIB)/basis/libs/basis-2002/top-level/top-level.sml 85.11-85.19 *)
type LargeReal.real = real (* @ $(SML_LIB)/basis/real/real.sml 26.12-26.15 *)
val LargeReal.!= : real * real -> bool (* @ $(SML_LIB)/basis/real/real.sml 176.14-176.15 *)
val LargeReal.* : real * real -> real (* @ $(SML_LIB)/basis/real/real.sml 103.17-103.17 *)
val LargeReal.*+ : real * real * real -> real (* @ $(SML_LIB)/basis/real/real.sml 101.17-101.18 *)
val LargeReal.*- : real * real * real -> real (* @ $(SML_LIB)/basis/real/real.sml 102.17-102.18 *)
val LargeReal.+ : real * real -> real (* @ $(SML_LIB)/basis/real/real.sml 104.17-104.17 *)
val LargeReal.- : real * real -> real (* @ $(SML_LIB)/basis/real/real.sml 105.17-105.17 *)
val LargeReal./ : real * real -> real (* @ $(SML_LIB)/basis/real/real.sml 106.17-106.17 *)
val LargeReal.< : real * real -> bool (* @ $(SML_LIB)/basis/real/real.sml 107.17-107.17 *)
val LargeReal.<= : real * real -> bool (* @ $(SML_LIB)/basis/real/real.sml 108.17-108.18 *)
val LargeReal.== : real * real -> bool (* @ $(SML_LIB)/basis/real/real.sml 174.14-174.15 *)
val LargeReal.> : real * real -> bool (* @ $(SML_LIB)/basis/real/real.sml 109.17-109.17 *)
val LargeReal.>= : real * real -> bool (* @ $(SML_LIB)/basis/real/real.sml 110.17-110.18 *)
val LargeReal.?= : real * real -> bool (* @ $(SML_LIB)/basis/real/real.sml 182.14-182.15 *)
val LargeReal.abs: real -> real (* @ $(SML_LIB)/basis/real/real.sml 112.14-112.16 *)
val LargeReal.ceil: real -> int (* @ $(SML_LIB)/basis/real/real.sml 859.11-859.14 *)
val LargeReal.checkFloat: real -> real (* @ $(SML_LIB)/basis/real/real.sml 328.11-328.20 *)
val LargeReal.class: real -> IEEEReal.float_class (* @ $(SML_LIB)/basis/real/real.sml 54.11-54.15 *)
val LargeReal.compare: real * real -> order (* @ $(SML_LIB)/basis/real/real.sml 234.14-234.20 *)
val LargeReal.compareReal: real * real -> IEEEReal.real_order (* @ $(SML_LIB)/basis/real/real.sml 223.14-223.24 *)
val LargeReal.copySign: real * real -> real (* @ $(SML_LIB)/basis/real/real.sml 215.11-215.18 *)
val LargeReal.floor: real -> int (* @ $(SML_LIB)/basis/real/real.sml 858.11-858.15 *)
val LargeReal.fmt: StringCvt.realfmt -> real -> string (* @ $(SML_LIB)/basis/real/real.sml 607.14-607.16 *)
val LargeReal.fromDecimal: {class: IEEEReal.float_class, digits: int list, exp: int, sign: bool} -> real option (* @ $(SML_LIB)/basis/real/real.sml 416.11-416.21 *)
val LargeReal.fromInt: int -> real (* @ $(SML_LIB)/basis/real/real.sml 819.14-819.20 *)
val LargeReal.fromLarge: IEEEReal.rounding_mode -> real -> real (* @ $(SML_LIB)/basis/real/real.sml 151.14-151.22 *)
val LargeReal.fromLargeInt: LargeInt.int -> real (* @ $(SML_LIB)/basis/real/real.sml 831.14-831.25 *)
val LargeReal.fromManExp: {exp: int, man: real} -> real (* @ $(SML_LIB)/basis/real/real.sml 289.11-289.20 *)
val LargeReal.fromString: string -> real option (* @ $(SML_LIB)/basis/real/real.sml 426.11-426.20 *)
val LargeReal.isFinite: real -> bool (* @ $(SML_LIB)/basis/real/real.sml 171.11-171.18 *)
val LargeReal.isNan: real -> bool (* @ $(SML_LIB)/basis/real/real.sml 178.11-178.15 *)
val LargeReal.isNormal: real -> bool (* @ $(SML_LIB)/basis/real/real.sml 180.11-180.18 *)
val LargeReal.max: real * real -> real (* @ $(SML_LIB)/basis/real/real.sml 199.11-199.13 *)
val LargeReal.maxFinite: real (* @ $(SML_LIB)/basis/real/real.sml 163.11-163.19 *)
val LargeReal.min: real * real -> real (* @ $(SML_LIB)/basis/real/real.sml 193.11-193.13 *)
val LargeReal.minNormalPos: real (* @ $(SML_LIB)/basis/real/real.sml 159.11-159.22 *)
val LargeReal.minPos: real (* @ $(SML_LIB)/basis/real/real.sml 158.11-158.16 *)
val LargeReal.negInf: real (* @ $(SML_LIB)/basis/real/real.sml 154.11-154.16 *)
val LargeReal.nextAfter: real * real -> real (* @ $(SML_LIB)/basis/real/real.sml 252.11-252.19 *)
val LargeReal.posInf: real (* @ $(SML_LIB)/basis/real/real.sml 164.11-164.16 *)
val LargeReal.precision: int (* @ $(SML_LIB)/basis/real/real.sml 33.14-33.22 *)
val LargeReal.radix: int (* @ $(SML_LIB)/basis/real/real.sml 34.14-34.18 *)
val LargeReal.realCeil: real -> real (* @ $(SML_LIB)/basis/real/real.sml 333.11-333.18 *)
val LargeReal.realFloor: real -> real (* @ $(SML_LIB)/basis/real/real.sml 334.11-334.19 *)
val LargeReal.realMod: real -> real (* @ $(SML_LIB)/basis/real/real.sml 326.11-326.17 *)
val LargeReal.realRound: real -> real (* @ $(SML_LIB)/basis/real/real.sml 339.11-339.19 *)
val LargeReal.realTrunc: real -> real (* @ $(SML_LIB)/basis/real/real.sml 335.11-335.19 *)
val LargeReal.rem: real * real -> real (* @ $(SML_LIB)/basis/real/real.sml 341.11-341.13 *)
val LargeReal.round: real -> int (* @ $(SML_LIB)/basis/real/real.sml 861.11-861.15 *)
val LargeReal.sameSign: real * real -> bool (* @ $(SML_LIB)/basis/real/real.sml 213.11-213.18 *)
val LargeReal.scan: ('a -> (char * 'a) option) -> 'a -> (real * 'a) option (* @ $(SML_LIB)/basis/real/real.sml 418.11-418.14 *)
val LargeReal.sign: real -> int (* @ $(SML_LIB)/basis/real/real.sml 205.11-205.14 *)
val LargeReal.signBit: real -> bool (* @ $(SML_LIB)/basis/real/real.sml 211.11-211.17 *)
val LargeReal.split: real -> {frac: real, whole: real} (* @ $(SML_LIB)/basis/real/real.sml 303.14-303.18 *)
val LargeReal.toDecimal: real -> {class: IEEEReal.float_class, digits: int list, exp: int, sign: bool} (* @ $(SML_LIB)/basis/real/real.sml 455.11-455.19 *)
val LargeReal.toInt: IEEEReal.rounding_mode -> real -> int (* @ $(SML_LIB)/basis/real/real.sml 843.14-843.18 *)
val LargeReal.toLarge: real -> real (* @ $(SML_LIB)/basis/real/real.sml 142.14-142.20 *)
val LargeReal.toLargeInt: IEEEReal.rounding_mode -> real -> LargeInt.int (* @ $(SML_LIB)/basis/real/real.sml 855.14-855.23 *)
val LargeReal.toManExp: real -> {exp: int, man: real} (* @ $(SML_LIB)/basis/real/real.sml 271.14-271.21 *)
val LargeReal.toString: real -> string (* @ $(SML_LIB)/basis/real/real.sml 664.11-664.18 *)
val LargeReal.trunc: real -> int (* @ $(SML_LIB)/basis/real/real.sml 860.11-860.15 *)
val LargeReal.unordered: real * real -> bool (* @ $(SML_LIB)/basis/real/real.sml 242.11-242.19 *)
val LargeReal.~ : real -> real (* @ $(SML_LIB)/basis/real/real.sml 111.14-111.14 *)
structure LargeReal.Math: MATH where type real = real (* @ $(SML_LIB)/basis/real/real.sml 1002.17-1002.20 *)
type LargeReal.Math.real = real (* @ $(SML_LIB)/basis/primitive/prim-real.sml 205.18-205.21 *)
val LargeReal.Math.acos: real -> real (* @ $(SML_LIB)/basis/real/real.sml 1016.20-1016.23 *)
val LargeReal.Math.asin: real -> real (* @ $(SML_LIB)/basis/real/real.sml 1017.20-1017.23 *)
val LargeReal.Math.atan: real -> real (* @ $(SML_LIB)/basis/primitive/prim-real.sml 209.17-209.20 *)
val LargeReal.Math.atan2: real * real -> real (* @ $(SML_LIB)/basis/primitive/prim-real.sml 210.17-210.21 *)
val LargeReal.Math.cos: real -> real (* @ $(SML_LIB)/basis/primitive/prim-real.sml 211.17-211.19 *)
val LargeReal.Math.cosh: real -> real (* @ $(SML_LIB)/basis/real/real.sml 1099.17-1099.20 *)
val LargeReal.Math.e: real (* @ $(SML_LIB)/basis/primitive/prim-real.sml 213.17-213.17 *)
val LargeReal.Math.exp: real -> real (* @ $(SML_LIB)/basis/real/real.sml 1028.17-1028.19 *)
val LargeReal.Math.ln: real -> real (* @ $(SML_LIB)/basis/real/real.sml 1023.20-1023.21 *)
val LargeReal.Math.log10: real -> real (* @ $(SML_LIB)/basis/real/real.sml 1024.20-1024.24 *)
val LargeReal.Math.pi: real (* @ $(SML_LIB)/basis/primitive/prim-real.sml 217.17-217.18 *)
val LargeReal.Math.pow: real * real -> real (* @ $(SML_LIB)/basis/real/real.sml 1055.17-1055.19 *)
val LargeReal.Math.sin: real -> real (* @ $(SML_LIB)/basis/primitive/prim-real.sml 219.17-219.19 *)
val LargeReal.Math.sinh: real -> real (* @ $(SML_LIB)/basis/real/real.sml 1105.17-1105.20 *)
val LargeReal.Math.sqrt: real -> real (* @ $(SML_LIB)/basis/primitive/prim-real.sml 221.17-221.20 *)
val LargeReal.Math.tan: real -> real (* @ $(SML_LIB)/basis/primitive/prim-real.sml 222.17-222.19 *)
val LargeReal.Math.tanh: real -> real (* @ $(SML_LIB)/basis/real/real.sml 1111.17-1111.20 *)
structure LargeRealArray: MONO_ARRAY where type array = LargeRealArray.array where type elem = real where type vector = LargeRealVector.vector (* @ $(SML_LIB)/basis/libs/basis-2002/top-level/top-level.sml 43.11-43.24 *)
type LargeRealArray.array = LargeRealArray.array (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array.fun 23.12-23.16 *)
type LargeRealArray.elem = real (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array.fun 22.12-22.15 *)
type LargeRealArray.vector = LargeRealVector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array.fun 24.12-24.17 *)
val LargeRealArray.all: (real -> bool) -> LargeRealArray.array -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 476.13-476.15 *)
val LargeRealArray.app: (real -> unit) -> LargeRealArray.array -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 464.13-464.15 *)
val LargeRealArray.appi: (int * real -> unit) -> LargeRealArray.array -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 463.13-463.16 *)
val LargeRealArray.array: int * real -> LargeRealArray.array (* @ $(SML_LIB)/basis/arrays-and-vectors/array.sml 34.11-34.15 *)
val LargeRealArray.collate: (real * real -> order) -> LargeRealArray.array * LargeRealArray.array -> order (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 477.13-477.19 *)
val LargeRealArray.copy: {di: int, dst: LargeRealArray.array, src: LargeRealArray.array} -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 457.13-457.16 *)
val LargeRealArray.copyVec: {di: int, dst: LargeRealArray.array, src: LargeRealVector.vector} -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array.sml 37.11-37.17 *)
val LargeRealArray.exists: (real -> bool) -> LargeRealArray.array -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 474.13-474.18 *)
val LargeRealArray.find: (real -> bool) -> LargeRealArray.array -> real option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 472.13-472.16 *)
val LargeRealArray.findi: (int * real -> bool) -> LargeRealArray.array -> (int * real) option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 471.13-471.17 *)
val LargeRealArray.foldl: (real * 'a -> 'a) -> 'a -> LargeRealArray.array -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 468.13-468.17 *)
val LargeRealArray.foldli: (int * real * 'a -> 'a) -> 'a -> LargeRealArray.array -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 467.13-467.18 *)
val LargeRealArray.foldr: (real * 'a -> 'a) -> 'a -> LargeRealArray.array -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 470.13-470.17 *)
val LargeRealArray.foldri: (int * real * 'a -> 'a) -> 'a -> LargeRealArray.array -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 469.13-469.18 *)
val LargeRealArray.fromList: real list -> LargeRealArray.array (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 122.11-122.18 *)
val LargeRealArray.length: LargeRealArray.array -> int (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 90.11-90.16 *)
val LargeRealArray.maxLen: int (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 88.11-88.16 *)
val LargeRealArray.modify: (real -> real) -> LargeRealArray.array -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array.sml 40.11-40.16 *)
val LargeRealArray.modifyi: (int * real -> real) -> LargeRealArray.array -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array.sml 39.11-39.17 *)
val LargeRealArray.sub: LargeRealArray.array * int -> real (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 450.13-450.15 *)
val LargeRealArray.tabulate: int * (int -> real) -> LargeRealArray.array (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 114.11-114.18 *)
val LargeRealArray.update: LargeRealArray.array * int * real -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 452.13-452.18 *)
val LargeRealArray.vector: LargeRealArray.array -> LargeRealVector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/array.sml 36.11-36.16 *)
structure LargeRealArray2: MONO_ARRAY2 where type array = LargeRealArray2.array where type elem = real where type vector = LargeRealVector.vector (* @ $(SML_LIB)/basis/libs/basis-2002/top-level/top-level.sml 44.11-44.25 *)
type LargeRealArray2.array = LargeRealArray2.array (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array2.fun 18.12-18.16 *)
type LargeRealArray2.elem = real (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array2.fun 15.12-15.15 *)
type LargeRealArray2.region = {base: LargeRealArray2.array, col: int, ncols: int option, nrows: int option, row: int} (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array2.fun 19.12-19.17 *)
datatype LargeRealArray2.traversal = ColMajor | RowMajor (* = datatype Array2.traversal *) (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 106.16-106.24 *)
type LargeRealArray2.vector = LargeRealVector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array2.fun 16.12-16.17 *)
con LargeRealArray2.ColMajor: Array2.traversal (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 106.39-106.46 *)
con LargeRealArray2.RowMajor: Array2.traversal (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 106.28-106.35 *)
val LargeRealArray2.app: Array2.traversal -> (real -> unit) -> LargeRealArray2.array -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 294.11-294.13 *)
val LargeRealArray2.appi: Array2.traversal -> (int * int * real -> unit) -> {base: LargeRealArray2.array, col: int, ncols: int option, nrows: int option, row: int} -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 291.11-291.14 *)
val LargeRealArray2.array: int * int * real -> LargeRealArray2.array (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 140.14-140.18 *)
val LargeRealArray2.column: LargeRealArray2.array * int -> LargeRealVector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 237.11-237.16 *)
val LargeRealArray2.copy: {dst: LargeRealArray2.array, dst_col: int, dst_row: int, src: {base: LargeRealArray2.array, col: int, ncols: int option, nrows: int option, row: int}} -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 309.11-309.14 *)
val LargeRealArray2.dimensions: LargeRealArray2.array -> int * int (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 33.11-33.20 *)
val LargeRealArray2.fold: Array2.traversal -> (real * 'a -> 'a) -> 'a -> LargeRealArray2.array -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 288.11-288.14 *)
val LargeRealArray2.foldi: Array2.traversal -> (int * int * real * 'a -> 'a) -> 'a -> {base: LargeRealArray2.array, col: int, ncols: int option, nrows: int option, row: int} -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 283.11-283.15 *)
val LargeRealArray2.fromList: real list list -> LargeRealArray2.array (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 188.14-188.21 *)
val LargeRealArray2.modify: Array2.traversal -> (real -> real) -> LargeRealArray2.array -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 299.11-299.16 *)
val LargeRealArray2.modifyi: Array2.traversal -> (int * int * real -> real) -> {base: LargeRealArray2.array, col: int, ncols: int option, nrows: int option, row: int} -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 296.11-296.17 *)
val LargeRealArray2.nCols: LargeRealArray2.array -> int (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 38.11-38.15 *)
val LargeRealArray2.nRows: LargeRealArray2.array -> int (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 36.11-36.15 *)
val LargeRealArray2.row: LargeRealArray2.array * int -> LargeRealVector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 222.11-222.13 *)
val LargeRealArray2.sub: LargeRealArray2.array * int * int -> real (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 182.14-182.16 *)
val LargeRealArray2.tabulate: Array2.traversal -> int * int * (int * int -> real) -> LargeRealArray2.array (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 301.11-301.18 *)
val LargeRealArray2.update: LargeRealArray2.array * int * int * real -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 184.14-184.19 *)
structure LargeRealArraySlice: MONO_ARRAY_SLICE where type array = LargeRealArray.array where type elem = real where type slice = LargeRealArraySlice.slice where type vector = LargeRealVector.vector where type vector_slice = LargeRealVectorSlice.slice (* @ $(SML_LIB)/basis/libs/basis-extra/top-level/basis.sml 138.17-138.35 *)
type LargeRealArraySlice.array = LargeRealArray.array (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array.fun 35.18-35.22 *)
type LargeRealArraySlice.elem = real (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array.fun 34.18-34.21 *)
type LargeRealArraySlice.slice = LargeRealArraySlice.slice (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array.fun 36.18-36.22 *)
type LargeRealArraySlice.vector = LargeRealVector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array.fun 37.18-37.23 *)
type LargeRealArraySlice.vector_slice = LargeRealVectorSlice.slice (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array.fun 38.18-38.29 *)
val LargeRealArraySlice.all: (real -> bool) -> LargeRealArraySlice.slice -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 235.17-235.19 *)
val LargeRealArraySlice.app: (real -> unit) -> LargeRealArraySlice.slice -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 226.17-226.19 *)
val LargeRealArraySlice.appi: (int * real -> unit) -> LargeRealArraySlice.slice -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 225.17-225.20 *)
val LargeRealArraySlice.base: LargeRealArraySlice.slice -> LargeRealArray.array * int * int (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 208.17-208.20 *)
val LargeRealArraySlice.collate: (real * real -> order) -> LargeRealArraySlice.slice * LargeRealArraySlice.slice -> order (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 236.17-236.23 *)
val LargeRealArraySlice.copy: {di: int, dst: LargeRealArray.array, src: LargeRealArraySlice.slice} -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 185.17-185.20 *)
val LargeRealArraySlice.copyVec: {di: int, dst: LargeRealArray.array, src: LargeRealVectorSlice.slice} -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array.sml 28.17-28.23 *)
val LargeRealArraySlice.exists: (real -> bool) -> LargeRealArraySlice.slice -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 233.17-233.22 *)
val LargeRealArraySlice.find: (real -> bool) -> LargeRealArraySlice.slice -> real option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 231.17-231.20 *)
val LargeRealArraySlice.findi: (int * real -> bool) -> LargeRealArraySlice.slice -> (int * real) option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 229.17-229.21 *)
val LargeRealArraySlice.foldl: (real * 'a -> 'a) -> 'a -> LargeRealArraySlice.slice -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 223.17-223.21 *)
val LargeRealArraySlice.foldli: (int * real * 'a -> 'a) -> 'a -> LargeRealArraySlice.slice -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 221.17-221.22 *)
val LargeRealArraySlice.foldr: (real * 'a -> 'a) -> 'a -> LargeRealArraySlice.slice -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 224.17-224.21 *)
val LargeRealArraySlice.foldri: (int * real * 'a -> 'a) -> 'a -> LargeRealArraySlice.slice -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 222.17-222.22 *)
val LargeRealArraySlice.full: LargeRealArray.array -> LargeRealArraySlice.slice (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 192.17-192.20 *)
val LargeRealArraySlice.getItem: LargeRealArraySlice.slice -> (real * LargeRealArraySlice.slice) option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 220.17-220.23 *)
val LargeRealArraySlice.isEmpty: LargeRealArraySlice.slice -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 219.17-219.23 *)
val LargeRealArraySlice.length: LargeRealArraySlice.slice -> int (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 134.17-134.22 *)
val LargeRealArraySlice.modify: (real -> real) -> LargeRealArraySlice.slice -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array.sml 31.17-31.22 *)
val LargeRealArraySlice.modifyi: (int * real -> real) -> LargeRealArraySlice.slice -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array.sml 30.17-30.23 *)
val LargeRealArraySlice.slice: LargeRealArray.array * int * int option -> LargeRealArraySlice.slice (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 206.17-206.21 *)
val LargeRealArraySlice.sub: LargeRealArraySlice.slice * int -> real (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 142.17-142.19 *)
val LargeRealArraySlice.subslice: LargeRealArraySlice.slice * int * int option -> LargeRealArraySlice.slice (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 199.17-199.24 *)
val LargeRealArraySlice.update: LargeRealArraySlice.slice * int * real -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 155.17-155.22 *)
val LargeRealArraySlice.vector: LargeRealArraySlice.slice -> LargeRealVector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/array.sml 27.17-27.22 *)
structure LargeRealVector: MONO_VECTOR where type elem = real where type vector = LargeRealVector.vector (* @ $(SML_LIB)/basis/libs/basis-2002/top-level/top-level.sml 45.11-45.25 *)
type LargeRealVector.elem = real (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-vector.fun 15.12-15.15 *)
type LargeRealVector.vector = LargeRealVector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-vector.fun 16.12-16.17 *)
val LargeRealVector.all: (real -> bool) -> LargeRealVector.vector -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 476.13-476.15 *)
val LargeRealVector.app: (real -> unit) -> LargeRealVector.vector -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 464.13-464.15 *)
val LargeRealVector.appi: (int * real -> unit) -> LargeRealVector.vector -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 463.13-463.16 *)
val LargeRealVector.collate: (real * real -> order) -> LargeRealVector.vector * LargeRealVector.vector -> order (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 477.13-477.19 *)
val LargeRealVector.concat: LargeRealVector.vector list -> LargeRealVector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 462.13-462.18 *)
val LargeRealVector.exists: (real -> bool) -> LargeRealVector.vector -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 474.13-474.18 *)
val LargeRealVector.find: (real -> bool) -> LargeRealVector.vector -> real option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 472.13-472.16 *)
val LargeRealVector.findi: (int * real -> bool) -> LargeRealVector.vector -> (int * real) option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 471.13-471.17 *)
val LargeRealVector.foldl: (real * 'a -> 'a) -> 'a -> LargeRealVector.vector -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 468.13-468.17 *)
val LargeRealVector.foldli: (int * real * 'a -> 'a) -> 'a -> LargeRealVector.vector -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 467.13-467.18 *)
val LargeRealVector.foldr: (real * 'a -> 'a) -> 'a -> LargeRealVector.vector -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 470.13-470.17 *)
val LargeRealVector.foldri: (int * real * 'a -> 'a) -> 'a -> LargeRealVector.vector -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 469.13-469.18 *)
val LargeRealVector.fromList: real list -> LargeRealVector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 122.11-122.18 *)
val LargeRealVector.length: LargeRealVector.vector -> int (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 90.11-90.16 *)
val LargeRealVector.map: (real -> real) -> LargeRealVector.vector -> LargeRealVector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 466.13-466.15 *)
val LargeRealVector.mapi: (int * real -> real) -> LargeRealVector.vector -> LargeRealVector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 465.13-465.16 *)
val LargeRealVector.maxLen: int (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 88.11-88.16 *)
val LargeRealVector.sub: LargeRealVector.vector * int -> real (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 450.13-450.15 *)
val LargeRealVector.tabulate: int * (int -> real) -> LargeRealVector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 114.11-114.18 *)
val LargeRealVector.update: LargeRealVector.vector * int * real -> LargeRealVector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/vector.sml 30.11-30.16 *)
structure LargeRealVectorSlice: MONO_VECTOR_SLICE where type elem = real where type slice = LargeRealVectorSlice.slice where type vector = LargeRealVector.vector (* @ $(SML_LIB)/basis/libs/basis-extra/top-level/basis.sml 140.17-140.36 *)
type LargeRealVectorSlice.elem = real (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-vector.fun 22.18-22.21 *)
type LargeRealVectorSlice.slice = LargeRealVectorSlice.slice (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-vector.fun 24.18-24.22 *)
type LargeRealVectorSlice.vector = LargeRealVector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-vector.fun 23.18-23.23 *)
val LargeRealVectorSlice.all: (real -> bool) -> LargeRealVectorSlice.slice -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 235.17-235.19 *)
val LargeRealVectorSlice.app: (real -> unit) -> LargeRealVectorSlice.slice -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 226.17-226.19 *)
val LargeRealVectorSlice.appi: (int * real -> unit) -> LargeRealVectorSlice.slice -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 225.17-225.20 *)
val LargeRealVectorSlice.base: LargeRealVectorSlice.slice -> LargeRealVector.vector * int * int (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 208.17-208.20 *)
val LargeRealVectorSlice.collate: (real * real -> order) -> LargeRealVectorSlice.slice * LargeRealVectorSlice.slice -> order (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 236.17-236.23 *)
val LargeRealVectorSlice.concat: LargeRealVectorSlice.slice list -> LargeRealVector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 240.17-240.22 *)
val LargeRealVectorSlice.exists: (real -> bool) -> LargeRealVectorSlice.slice -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 233.17-233.22 *)
val LargeRealVectorSlice.find: (real -> bool) -> LargeRealVectorSlice.slice -> real option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 231.17-231.20 *)
val LargeRealVectorSlice.findi: (int * real -> bool) -> LargeRealVectorSlice.slice -> (int * real) option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 229.17-229.21 *)
val LargeRealVectorSlice.foldl: (real * 'a -> 'a) -> 'a -> LargeRealVectorSlice.slice -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 223.17-223.21 *)
val LargeRealVectorSlice.foldli: (int * real * 'a -> 'a) -> 'a -> LargeRealVectorSlice.slice -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 221.17-221.22 *)
val LargeRealVectorSlice.foldr: (real * 'a -> 'a) -> 'a -> LargeRealVectorSlice.slice -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 224.17-224.21 *)
val LargeRealVectorSlice.foldri: (int * real * 'a -> 'a) -> 'a -> LargeRealVectorSlice.slice -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 222.17-222.22 *)
val LargeRealVectorSlice.full: LargeRealVector.vector -> LargeRealVectorSlice.slice (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 192.17-192.20 *)
val LargeRealVectorSlice.getItem: LargeRealVectorSlice.slice -> (real * LargeRealVectorSlice.slice) option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 220.17-220.23 *)
val LargeRealVectorSlice.isEmpty: LargeRealVectorSlice.slice -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 219.17-219.23 *)
val LargeRealVectorSlice.length: LargeRealVectorSlice.slice -> int (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 134.17-134.22 *)
val LargeRealVectorSlice.map: (real -> real) -> LargeRealVectorSlice.slice -> LargeRealVector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 228.17-228.19 *)
val LargeRealVectorSlice.mapi: (int * real -> real) -> LargeRealVectorSlice.slice -> LargeRealVector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 227.17-227.20 *)
val LargeRealVectorSlice.slice: LargeRealVector.vector * int * int option -> LargeRealVectorSlice.slice (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 206.17-206.21 *)
val LargeRealVectorSlice.sub: LargeRealVectorSlice.slice * int -> real (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 142.17-142.19 *)
val LargeRealVectorSlice.subslice: LargeRealVectorSlice.slice * int * int option -> LargeRealVectorSlice.slice (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 199.17-199.24 *)
val LargeRealVectorSlice.vector: LargeRealVectorSlice.slice -> LargeRealVector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/vector.sml 21.17-21.22 *)
structure LargeWord: WORD where type word = LargeWord.word (* @ $(SML_LIB)/basis/libs/basis-2002/top-level/top-level.sml 91.11-91.19 *)
type LargeWord.word = LargeWord.word (* @ $(SML_LIB)/basis/primitive/prim-basis.sml 431.12-431.15 *)
val LargeWord.* : LargeWord.word * LargeWord.word -> LargeWord.word (* @ $(SML_LIB)/basis/primitive/prim-word.sml 396.11-396.11 *)
val LargeWord.+ : LargeWord.word * LargeWord.word -> LargeWord.word (* @ $(SML_LIB)/basis/primitive/prim-word.sml 393.11-393.11 *)
val LargeWord.- : LargeWord.word * LargeWord.word -> LargeWord.word (* @ $(SML_LIB)/basis/primitive/prim-word.sml 406.11-406.11 *)
val LargeWord.< : LargeWord.word * LargeWord.word -> bool (* @ $(SML_LIB)/basis/util/integral-comparisons.sml 11.11-11.11 *)
val LargeWord.<< : LargeWord.word * word -> LargeWord.word (* @ $(SML_LIB)/basis/integer/word.sml 19.5-19.6 *)
val LargeWord.<= : LargeWord.word * LargeWord.word -> bool (* @ $(SML_LIB)/basis/util/integral-comparisons.sml 12.11-12.12 *)
val LargeWord.> : LargeWord.word * LargeWord.word -> bool (* @ $(SML_LIB)/basis/util/integral-comparisons.sml 13.11-13.11 *)
val LargeWord.>= : LargeWord.word * LargeWord.word -> bool (* @ $(SML_LIB)/basis/util/integral-comparisons.sml 14.11-14.12 *)
val LargeWord.>> : LargeWord.word * word -> LargeWord.word (* @ $(SML_LIB)/basis/integer/word.sml 23.5-23.6 *)
val LargeWord.andb: LargeWord.word * LargeWord.word -> LargeWord.word (* @ $(SML_LIB)/basis/primitive/prim-word.sml 394.11-394.14 *)
val LargeWord.compare: LargeWord.word * LargeWord.word -> order (* @ $(SML_LIB)/basis/util/integral-comparisons.sml 16.11-16.17 *)
val LargeWord.div: LargeWord.word * LargeWord.word -> LargeWord.word (* @ $(SML_LIB)/basis/integer/num0.sml 97.23-97.25 *)
val LargeWord.fmt: StringCvt.radix -> LargeWord.word -> string (* @ $(SML_LIB)/basis/integer/word.sml 104.8-104.10 *)
val LargeWord.fromInt: int -> LargeWord.word (* @ $(SML_LIB)/basis/integer/word.sml 55.5-55.11 *)
val LargeWord.fromLarge: LargeWord.word -> LargeWord.word (* @ $(SML_LIB)/basis/integer/word.sml 87.5-87.13 *)
val LargeWord.fromLargeInt: LargeInt.int -> LargeWord.word (* @ $(SML_LIB)/basis/integer/word.sml 70.5-70.16 *)
val LargeWord.fromLargeWord: LargeWord.word -> LargeWord.word (* @ $(SML_LIB)/basis/integer/word.sml 86.5-86.17 *)
val LargeWord.fromString: string -> LargeWord.word option (* @ $(SML_LIB)/basis/integer/word.sml 209.5-209.14 *)
val LargeWord.max: LargeWord.word * LargeWord.word -> LargeWord.word (* @ $(SML_LIB)/basis/util/integral-comparisons.sml 21.11-21.13 *)
val LargeWord.min: LargeWord.word * LargeWord.word -> LargeWord.word (* @ $(SML_LIB)/basis/util/integral-comparisons.sml 20.11-20.13 *)
val LargeWord.mod: LargeWord.word * LargeWord.word -> LargeWord.word (* @ $(SML_LIB)/basis/integer/num0.sml 98.23-98.25 *)
val LargeWord.notb: LargeWord.word -> LargeWord.word (* @ $(SML_LIB)/basis/primitive/prim-word.sml 398.11-398.14 *)
val LargeWord.orb: LargeWord.word * LargeWord.word -> LargeWord.word (* @ $(SML_LIB)/basis/primitive/prim-word.sml 399.11-399.13 *)
val LargeWord.scan: StringCvt.radix -> ('a -> (char * 'a) option) -> 'a -> (LargeWord.word * 'a) option (* @ $(SML_LIB)/basis/integer/word.sml 146.5-146.8 *)
val LargeWord.toInt: LargeWord.word -> int (* @ $(SML_LIB)/basis/integer/word.sml 57.5-57.9 *)
val LargeWord.toIntX: LargeWord.word -> int (* @ $(SML_LIB)/basis/integer/word.sml 56.5-56.10 *)
val LargeWord.toLarge: LargeWord.word -> LargeWord.word (* @ $(SML_LIB)/basis/integer/word.sml 91.5-91.11 *)
val LargeWord.toLargeInt: LargeWord.word -> LargeInt.int (* @ $(SML_LIB)/basis/integer/word.sml 72.5-72.14 *)
val LargeWord.toLargeIntX: LargeWord.word -> LargeInt.int (* @ $(SML_LIB)/basis/integer/word.sml 71.5-71.15 *)
val LargeWord.toLargeWord: LargeWord.word -> LargeWord.word (* @ $(SML_LIB)/basis/integer/word.sml 90.5-90.15 *)
val LargeWord.toLargeWordX: LargeWord.word -> LargeWord.word (* @ $(SML_LIB)/basis/integer/word.sml 88.5-88.16 *)
val LargeWord.toLargeX: LargeWord.word -> LargeWord.word (* @ $(SML_LIB)/basis/integer/word.sml 89.5-89.12 *)
val LargeWord.toString: LargeWord.word -> string (* @ $(SML_LIB)/basis/integer/word.sml 144.5-144.12 *)
val LargeWord.wordSize: int (* @ $(SML_LIB)/basis/integer/word.sml 16.5-16.12 *)
val LargeWord.xorb: LargeWord.word * LargeWord.word -> LargeWord.word (* @ $(SML_LIB)/basis/primitive/prim-word.sml 407.11-407.14 *)
val LargeWord.~ : LargeWord.word -> LargeWord.word (* @ $(SML_LIB)/basis/primitive/prim-word.sml 397.11-397.11 *)
val LargeWord.~>> : LargeWord.word * word -> LargeWord.word (* @ $(SML_LIB)/basis/integer/word.sml 27.5-27.7 *)
structure LargeWordArray: MONO_ARRAY where type array = LargeWordArray.array where type elem = LargeWord.word where type vector = LargeWordVector.vector (* @ $(SML_LIB)/basis/libs/basis-2002/top-level/top-level.sml 46.11-46.24 *)
type LargeWordArray.array = LargeWordArray.array (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array.fun 23.12-23.16 *)
type LargeWordArray.elem = LargeWord.word (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array.fun 22.12-22.15 *)
type LargeWordArray.vector = LargeWordVector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array.fun 24.12-24.17 *)
val LargeWordArray.all: (LargeWord.word -> bool) -> LargeWordArray.array -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 476.13-476.15 *)
val LargeWordArray.app: (LargeWord.word -> unit) -> LargeWordArray.array -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 464.13-464.15 *)
val LargeWordArray.appi: (int * LargeWord.word -> unit) -> LargeWordArray.array -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 463.13-463.16 *)
val LargeWordArray.array: int * LargeWord.word -> LargeWordArray.array (* @ $(SML_LIB)/basis/arrays-and-vectors/array.sml 34.11-34.15 *)
val LargeWordArray.collate: (LargeWord.word * LargeWord.word -> order) -> LargeWordArray.array * LargeWordArray.array -> order (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 477.13-477.19 *)
val LargeWordArray.copy: {di: int, dst: LargeWordArray.array, src: LargeWordArray.array} -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 457.13-457.16 *)
val LargeWordArray.copyVec: {di: int, dst: LargeWordArray.array, src: LargeWordVector.vector} -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array.sml 37.11-37.17 *)
val LargeWordArray.exists: (LargeWord.word -> bool) -> LargeWordArray.array -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 474.13-474.18 *)
val LargeWordArray.find: (LargeWord.word -> bool) -> LargeWordArray.array -> LargeWord.word option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 472.13-472.16 *)
val LargeWordArray.findi: (int * LargeWord.word -> bool) -> LargeWordArray.array -> (int * LargeWord.word) option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 471.13-471.17 *)
val LargeWordArray.foldl: (LargeWord.word * 'a -> 'a) -> 'a -> LargeWordArray.array -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 468.13-468.17 *)
val LargeWordArray.foldli: (int * LargeWord.word * 'a -> 'a) -> 'a -> LargeWordArray.array -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 467.13-467.18 *)
val LargeWordArray.foldr: (LargeWord.word * 'a -> 'a) -> 'a -> LargeWordArray.array -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 470.13-470.17 *)
val LargeWordArray.foldri: (int * LargeWord.word * 'a -> 'a) -> 'a -> LargeWordArray.array -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 469.13-469.18 *)
val LargeWordArray.fromList: LargeWord.word list -> LargeWordArray.array (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 122.11-122.18 *)
val LargeWordArray.length: LargeWordArray.array -> int (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 90.11-90.16 *)
val LargeWordArray.maxLen: int (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 88.11-88.16 *)
val LargeWordArray.modify: (LargeWord.word -> LargeWord.word) -> LargeWordArray.array -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array.sml 40.11-40.16 *)
val LargeWordArray.modifyi: (int * LargeWord.word -> LargeWord.word) -> LargeWordArray.array -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array.sml 39.11-39.17 *)
val LargeWordArray.sub: LargeWordArray.array * int -> LargeWord.word (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 450.13-450.15 *)
val LargeWordArray.tabulate: int * (int -> LargeWord.word) -> LargeWordArray.array (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 114.11-114.18 *)
val LargeWordArray.update: LargeWordArray.array * int * LargeWord.word -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 452.13-452.18 *)
val LargeWordArray.vector: LargeWordArray.array -> LargeWordVector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/array.sml 36.11-36.16 *)
structure LargeWordArray2: MONO_ARRAY2 where type array = LargeWordArray2.array where type elem = LargeWord.word where type vector = LargeWordVector.vector (* @ $(SML_LIB)/basis/libs/basis-2002/top-level/top-level.sml 47.11-47.25 *)
type LargeWordArray2.array = LargeWordArray2.array (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array2.fun 18.12-18.16 *)
type LargeWordArray2.elem = LargeWord.word (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array2.fun 15.12-15.15 *)
type LargeWordArray2.region = {base: LargeWordArray2.array, col: int, ncols: int option, nrows: int option, row: int} (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array2.fun 19.12-19.17 *)
datatype LargeWordArray2.traversal = ColMajor | RowMajor (* = datatype Array2.traversal *) (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 106.16-106.24 *)
type LargeWordArray2.vector = LargeWordVector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array2.fun 16.12-16.17 *)
con LargeWordArray2.ColMajor: Array2.traversal (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 106.39-106.46 *)
con LargeWordArray2.RowMajor: Array2.traversal (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 106.28-106.35 *)
val LargeWordArray2.app: Array2.traversal -> (LargeWord.word -> unit) -> LargeWordArray2.array -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 294.11-294.13 *)
val LargeWordArray2.appi: Array2.traversal -> (int * int * LargeWord.word -> unit) -> {base: LargeWordArray2.array, col: int, ncols: int option, nrows: int option, row: int} -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 291.11-291.14 *)
val LargeWordArray2.array: int * int * LargeWord.word -> LargeWordArray2.array (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 140.14-140.18 *)
val LargeWordArray2.column: LargeWordArray2.array * int -> LargeWordVector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 237.11-237.16 *)
val LargeWordArray2.copy: {dst: LargeWordArray2.array, dst_col: int, dst_row: int, src: {base: LargeWordArray2.array, col: int, ncols: int option, nrows: int option, row: int}} -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 309.11-309.14 *)
val LargeWordArray2.dimensions: LargeWordArray2.array -> int * int (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 33.11-33.20 *)
val LargeWordArray2.fold: Array2.traversal -> (LargeWord.word * 'a -> 'a) -> 'a -> LargeWordArray2.array -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 288.11-288.14 *)
val LargeWordArray2.foldi: Array2.traversal -> (int * int * LargeWord.word * 'a -> 'a) -> 'a -> {base: LargeWordArray2.array, col: int, ncols: int option, nrows: int option, row: int} -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 283.11-283.15 *)
val LargeWordArray2.fromList: LargeWord.word list list -> LargeWordArray2.array (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 188.14-188.21 *)
val LargeWordArray2.modify: Array2.traversal -> (LargeWord.word -> LargeWord.word) -> LargeWordArray2.array -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 299.11-299.16 *)
val LargeWordArray2.modifyi: Array2.traversal -> (int * int * LargeWord.word -> LargeWord.word) -> {base: LargeWordArray2.array, col: int, ncols: int option, nrows: int option, row: int} -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 296.11-296.17 *)
val LargeWordArray2.nCols: LargeWordArray2.array -> int (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 38.11-38.15 *)
val LargeWordArray2.nRows: LargeWordArray2.array -> int (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 36.11-36.15 *)
val LargeWordArray2.row: LargeWordArray2.array * int -> LargeWordVector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 222.11-222.13 *)
val LargeWordArray2.sub: LargeWordArray2.array * int * int -> LargeWord.word (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 182.14-182.16 *)
val LargeWordArray2.tabulate: Array2.traversal -> int * int * (int * int -> LargeWord.word) -> LargeWordArray2.array (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 301.11-301.18 *)
val LargeWordArray2.update: LargeWordArray2.array * int * int * LargeWord.word -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 184.14-184.19 *)
structure LargeWordArraySlice: MONO_ARRAY_SLICE where type array = LargeWordArray.array where type elem = LargeWord.word where type slice = LargeWordArraySlice.slice where type vector = LargeWordVector.vector where type vector_slice = LargeWordVectorSlice.slice (* @ $(SML_LIB)/basis/libs/basis-extra/top-level/basis.sml 143.17-143.35 *)
type LargeWordArraySlice.array = LargeWordArray.array (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array.fun 35.18-35.22 *)
type LargeWordArraySlice.elem = LargeWord.word (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array.fun 34.18-34.21 *)
type LargeWordArraySlice.slice = LargeWordArraySlice.slice (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array.fun 36.18-36.22 *)
type LargeWordArraySlice.vector = LargeWordVector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array.fun 37.18-37.23 *)
type LargeWordArraySlice.vector_slice = LargeWordVectorSlice.slice (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array.fun 38.18-38.29 *)
val LargeWordArraySlice.all: (LargeWord.word -> bool) -> LargeWordArraySlice.slice -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 235.17-235.19 *)
val LargeWordArraySlice.app: (LargeWord.word -> unit) -> LargeWordArraySlice.slice -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 226.17-226.19 *)
val LargeWordArraySlice.appi: (int * LargeWord.word -> unit) -> LargeWordArraySlice.slice -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 225.17-225.20 *)
val LargeWordArraySlice.base: LargeWordArraySlice.slice -> LargeWordArray.array * int * int (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 208.17-208.20 *)
val LargeWordArraySlice.collate: (LargeWord.word * LargeWord.word -> order) -> LargeWordArraySlice.slice * LargeWordArraySlice.slice -> order (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 236.17-236.23 *)
val LargeWordArraySlice.copy: {di: int, dst: LargeWordArray.array, src: LargeWordArraySlice.slice} -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 185.17-185.20 *)
val LargeWordArraySlice.copyVec: {di: int, dst: LargeWordArray.array, src: LargeWordVectorSlice.slice} -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array.sml 28.17-28.23 *)
val LargeWordArraySlice.exists: (LargeWord.word -> bool) -> LargeWordArraySlice.slice -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 233.17-233.22 *)
val LargeWordArraySlice.find: (LargeWord.word -> bool) -> LargeWordArraySlice.slice -> LargeWord.word option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 231.17-231.20 *)
val LargeWordArraySlice.findi: (int * LargeWord.word -> bool) -> LargeWordArraySlice.slice -> (int * LargeWord.word) option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 229.17-229.21 *)
val LargeWordArraySlice.foldl: (LargeWord.word * 'a -> 'a) -> 'a -> LargeWordArraySlice.slice -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 223.17-223.21 *)
val LargeWordArraySlice.foldli: (int * LargeWord.word * 'a -> 'a) -> 'a -> LargeWordArraySlice.slice -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 221.17-221.22 *)
val LargeWordArraySlice.foldr: (LargeWord.word * 'a -> 'a) -> 'a -> LargeWordArraySlice.slice -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 224.17-224.21 *)
val LargeWordArraySlice.foldri: (int * LargeWord.word * 'a -> 'a) -> 'a -> LargeWordArraySlice.slice -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 222.17-222.22 *)
val LargeWordArraySlice.full: LargeWordArray.array -> LargeWordArraySlice.slice (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 192.17-192.20 *)
val LargeWordArraySlice.getItem: LargeWordArraySlice.slice -> (LargeWord.word * LargeWordArraySlice.slice) option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 220.17-220.23 *)
val LargeWordArraySlice.isEmpty: LargeWordArraySlice.slice -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 219.17-219.23 *)
val LargeWordArraySlice.length: LargeWordArraySlice.slice -> int (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 134.17-134.22 *)
val LargeWordArraySlice.modify: (LargeWord.word -> LargeWord.word) -> LargeWordArraySlice.slice -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array.sml 31.17-31.22 *)
val LargeWordArraySlice.modifyi: (int * LargeWord.word -> LargeWord.word) -> LargeWordArraySlice.slice -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array.sml 30.17-30.23 *)
val LargeWordArraySlice.slice: LargeWordArray.array * int * int option -> LargeWordArraySlice.slice (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 206.17-206.21 *)
val LargeWordArraySlice.sub: LargeWordArraySlice.slice * int -> LargeWord.word (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 142.17-142.19 *)
val LargeWordArraySlice.subslice: LargeWordArraySlice.slice * int * int option -> LargeWordArraySlice.slice (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 199.17-199.24 *)
val LargeWordArraySlice.update: LargeWordArraySlice.slice * int * LargeWord.word -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 155.17-155.22 *)
val LargeWordArraySlice.vector: LargeWordArraySlice.slice -> LargeWordVector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/array.sml 27.17-27.22 *)
structure LargeWordVector: MONO_VECTOR where type elem = LargeWord.word where type vector = LargeWordVector.vector (* @ $(SML_LIB)/basis/libs/basis-2002/top-level/top-level.sml 48.11-48.25 *)
type LargeWordVector.elem = LargeWord.word (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-vector.fun 35.12-35.15 *)
type LargeWordVector.vector = LargeWordVector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-vector.fun 36.12-36.17 *)
val LargeWordVector.all: (LargeWord.word -> bool) -> LargeWordVector.vector -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 476.13-476.15 *)
val LargeWordVector.app: (LargeWord.word -> unit) -> LargeWordVector.vector -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 464.13-464.15 *)
val LargeWordVector.appi: (int * LargeWord.word -> unit) -> LargeWordVector.vector -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 463.13-463.16 *)
val LargeWordVector.collate: (LargeWord.word * LargeWord.word -> order) -> LargeWordVector.vector * LargeWordVector.vector -> order (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 477.13-477.19 *)
val LargeWordVector.concat: LargeWordVector.vector list -> LargeWordVector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 462.13-462.18 *)
val LargeWordVector.exists: (LargeWord.word -> bool) -> LargeWordVector.vector -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 474.13-474.18 *)
val LargeWordVector.find: (LargeWord.word -> bool) -> LargeWordVector.vector -> LargeWord.word option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 472.13-472.16 *)
val LargeWordVector.findi: (int * LargeWord.word -> bool) -> LargeWordVector.vector -> (int * LargeWord.word) option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 471.13-471.17 *)
val LargeWordVector.foldl: (LargeWord.word * 'a -> 'a) -> 'a -> LargeWordVector.vector -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 468.13-468.17 *)
val LargeWordVector.foldli: (int * LargeWord.word * 'a -> 'a) -> 'a -> LargeWordVector.vector -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 467.13-467.18 *)
val LargeWordVector.foldr: (LargeWord.word * 'a -> 'a) -> 'a -> LargeWordVector.vector -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 470.13-470.17 *)
val LargeWordVector.foldri: (int * LargeWord.word * 'a -> 'a) -> 'a -> LargeWordVector.vector -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 469.13-469.18 *)
val LargeWordVector.fromList: LargeWord.word list -> LargeWordVector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 122.11-122.18 *)
val LargeWordVector.length: LargeWordVector.vector -> int (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 90.11-90.16 *)
val LargeWordVector.map: (LargeWord.word -> LargeWord.word) -> LargeWordVector.vector -> LargeWordVector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 466.13-466.15 *)
val LargeWordVector.mapi: (int * LargeWord.word -> LargeWord.word) -> LargeWordVector.vector -> LargeWordVector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 465.13-465.16 *)
val LargeWordVector.maxLen: int (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 88.11-88.16 *)
val LargeWordVector.sub: LargeWordVector.vector * int -> LargeWord.word (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 450.13-450.15 *)
val LargeWordVector.tabulate: int * (int -> LargeWord.word) -> LargeWordVector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 114.11-114.18 *)
val LargeWordVector.update: LargeWordVector.vector * int * LargeWord.word -> LargeWordVector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/vector.sml 30.11-30.16 *)
structure LargeWordVectorSlice: MONO_VECTOR_SLICE where type elem = LargeWord.word where type slice = LargeWordVectorSlice.slice where type vector = LargeWordVector.vector (* @ $(SML_LIB)/basis/libs/basis-extra/top-level/basis.sml 145.17-145.36 *)
type LargeWordVectorSlice.elem = LargeWord.word (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-vector.fun 43.18-43.21 *)
type LargeWordVectorSlice.slice = LargeWordVectorSlice.slice (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-vector.fun 45.18-45.22 *)
type LargeWordVectorSlice.vector = LargeWordVector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-vector.fun 44.18-44.23 *)
val LargeWordVectorSlice.all: (LargeWord.word -> bool) -> LargeWordVectorSlice.slice -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 235.17-235.19 *)
val LargeWordVectorSlice.app: (LargeWord.word -> unit) -> LargeWordVectorSlice.slice -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 226.17-226.19 *)
val LargeWordVectorSlice.appi: (int * LargeWord.word -> unit) -> LargeWordVectorSlice.slice -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 225.17-225.20 *)
val LargeWordVectorSlice.base: LargeWordVectorSlice.slice -> LargeWordVector.vector * int * int (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 208.17-208.20 *)
val LargeWordVectorSlice.collate: (LargeWord.word * LargeWord.word -> order) -> LargeWordVectorSlice.slice * LargeWordVectorSlice.slice -> order (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 236.17-236.23 *)
val LargeWordVectorSlice.concat: LargeWordVectorSlice.slice list -> LargeWordVector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 240.17-240.22 *)
val LargeWordVectorSlice.exists: (LargeWord.word -> bool) -> LargeWordVectorSlice.slice -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 233.17-233.22 *)
val LargeWordVectorSlice.find: (LargeWord.word -> bool) -> LargeWordVectorSlice.slice -> LargeWord.word option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 231.17-231.20 *)
val LargeWordVectorSlice.findi: (int * LargeWord.word -> bool) -> LargeWordVectorSlice.slice -> (int * LargeWord.word) option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 229.17-229.21 *)
val LargeWordVectorSlice.foldl: (LargeWord.word * 'a -> 'a) -> 'a -> LargeWordVectorSlice.slice -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 223.17-223.21 *)
val LargeWordVectorSlice.foldli: (int * LargeWord.word * 'a -> 'a) -> 'a -> LargeWordVectorSlice.slice -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 221.17-221.22 *)
val LargeWordVectorSlice.foldr: (LargeWord.word * 'a -> 'a) -> 'a -> LargeWordVectorSlice.slice -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 224.17-224.21 *)
val LargeWordVectorSlice.foldri: (int * LargeWord.word * 'a -> 'a) -> 'a -> LargeWordVectorSlice.slice -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 222.17-222.22 *)
val LargeWordVectorSlice.full: LargeWordVector.vector -> LargeWordVectorSlice.slice (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 192.17-192.20 *)
val LargeWordVectorSlice.getItem: LargeWordVectorSlice.slice -> (LargeWord.word * LargeWordVectorSlice.slice) option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 220.17-220.23 *)
val LargeWordVectorSlice.isEmpty: LargeWordVectorSlice.slice -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 219.17-219.23 *)
val LargeWordVectorSlice.length: LargeWordVectorSlice.slice -> int (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 134.17-134.22 *)
val LargeWordVectorSlice.map: (LargeWord.word -> LargeWord.word) -> LargeWordVectorSlice.slice -> LargeWordVector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 228.17-228.19 *)
val LargeWordVectorSlice.mapi: (int * LargeWord.word -> LargeWord.word) -> LargeWordVectorSlice.slice -> LargeWordVector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 227.17-227.20 *)
val LargeWordVectorSlice.slice: LargeWordVector.vector * int * int option -> LargeWordVectorSlice.slice (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 206.17-206.21 *)
val LargeWordVectorSlice.sub: LargeWordVectorSlice.slice * int -> LargeWord.word (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 142.17-142.19 *)
val LargeWordVectorSlice.subslice: LargeWordVectorSlice.slice * int * int option -> LargeWordVectorSlice.slice (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 199.17-199.24 *)
val LargeWordVectorSlice.vector: LargeWordVectorSlice.slice -> LargeWordVector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/vector.sml 21.17-21.22 *)
structure List: LIST (* @ $(SML_LIB)/basis/libs/basis-extra/top-level/basis.sml 31.17-31.20 *)
datatype 'a List.list = :: of 'a * 'a list | nil (* = datatype 'a list *) (* @ $(SML_LIB)/basis/list/list.sml 13.15-13.18 *)
con List.:: : 'a * 'a list -> 'a list (* @ <bogus> ~1.~1 *)
val List.@ : 'a list * 'a list -> 'a list (* @ $(SML_LIB)/basis/list/list.sml 55.13-55.13 *)
exn List.Empty: exn (* @ $(SML_LIB)/basis/list/list.sml 15.16-15.20 *)
val List.all: ('a -> bool) -> 'a list -> bool (* @ $(SML_LIB)/basis/list/list.sml 101.10-101.12 *)
val List.app: ('a -> unit) -> 'a list -> unit (* @ $(SML_LIB)/basis/list/list.sml 64.10-64.12 *)
val List.collate: ('a * 'a -> order) -> 'a list * 'a list -> order (* @ $(SML_LIB)/basis/list/list.sml 157.10-157.16 *)
val List.concat: 'a list list -> 'a list (* @ $(SML_LIB)/basis/list/list.sml 62.10-62.15 *)
val List.drop: 'a list * int -> 'a list (* @ $(SML_LIB)/basis/list/list.sml 143.10-143.13 *)
val List.exists: ('a -> bool) -> 'a list -> bool (* @ $(SML_LIB)/basis/list/list.sml 96.10-96.15 *)
val List.filter: ('a -> bool) -> 'a list -> 'a list (* @ $(SML_LIB)/basis/list/list.sml 74.10-74.15 *)
val List.find: ('a -> bool) -> 'a list -> 'a option (* @ $(SML_LIB)/basis/list/list.sml 86.10-86.13 *)
val List.foldl: ('a * 'b -> 'b) -> 'b -> 'a list -> 'b (* @ $(SML_LIB)/basis/list/list.sml 38.10-38.14 *)
val List.foldr: ('a * 'b -> 'b) -> 'b -> 'a list -> 'b (* @ $(SML_LIB)/basis/list/list.sml 60.10-60.14 *)
val List.getItem: 'a list -> ('a * 'a list) option (* @ $(SML_LIB)/basis/list/list.sml 34.10-34.16 *)
val List.hd: 'a list -> 'a (* @ $(SML_LIB)/basis/list/list.sml 21.10-21.11 *)
val List.last: 'a list -> 'a (* @ $(SML_LIB)/basis/list/list.sml 29.14-29.17 *)
val List.length: 'a list -> int (* @ $(SML_LIB)/basis/list/list.sml 47.10-47.15 *)
val List.map: ('a -> 'b) -> 'a list -> 'b list (* @ $(SML_LIB)/basis/list/list.sml 66.10-66.12 *)
val List.mapPartial: ('a -> 'b option) -> 'a list -> 'b list (* @ $(SML_LIB)/basis/list/list.sml 68.10-68.19 *)
con List.nil: 'a list (* @ <bogus> ~1.~1 *)
val List.nth: 'a list * int -> 'a (* @ $(SML_LIB)/basis/list/list.sml 114.10-114.12 *)
val List.null: 'a list -> bool (* @ $(SML_LIB)/basis/list/list.sml 17.10-17.13 *)
val List.partition: ('a -> bool) -> 'a list -> 'a list * 'a list (* @ $(SML_LIB)/basis/list/list.sml 76.10-76.18 *)
val List.rev: 'a list -> 'a list (* @ $(SML_LIB)/basis/list/list.sml 53.10-53.12 *)
val List.revAppend: 'a list * 'a list -> 'a list (* @ $(SML_LIB)/basis/list/list.sml 51.10-51.18 *)
val List.tabulate: int * (int -> 'a) -> 'a list (* @ $(SML_LIB)/basis/list/list.sml 103.10-103.17 *)
val List.take: 'a list * int -> 'a list (* @ $(SML_LIB)/basis/list/list.sml 129.10-129.13 *)
val List.tl: 'a list -> 'a list (* @ $(SML_LIB)/basis/list/list.sml 25.10-25.11 *)
structure ListPair: LIST_PAIR (* @ $(SML_LIB)/basis/libs/basis-extra/top-level/basis.sml 32.17-32.24 *)
exn ListPair.UnequalLengths: exn (* @ $(SML_LIB)/basis/list/list-pair.sml 11.17-11.30 *)
val ListPair.all: ('a * 'b -> bool) -> 'a list * 'b list -> bool (* @ $(SML_LIB)/basis/list/list-pair.sml 79.11-79.13 *)
val ListPair.allEq: ('a * 'b -> bool) -> 'a list * 'b list -> bool (* @ $(SML_LIB)/basis/list/list-pair.sml 81.11-81.15 *)
val ListPair.app: ('a * 'b -> unit) -> 'a list * 'b list -> unit (* @ $(SML_LIB)/basis/list/list-pair.sml 65.11-65.13 *)
val ListPair.appEq: ('a * 'b -> unit) -> 'a list * 'b list -> unit (* @ $(SML_LIB)/basis/list/list-pair.sml 67.11-67.15 *)
val ListPair.exists: ('a * 'b -> bool) -> 'a list * 'b list -> bool (* @ $(SML_LIB)/basis/list/list-pair.sml 69.11-69.16 *)
val ListPair.foldl: ('a * 'b * 'c -> 'c) -> 'c -> 'a list * 'b list -> 'c (* @ $(SML_LIB)/basis/list/list-pair.sml 31.11-31.15 *)
val ListPair.foldlEq: ('a * 'b * 'c -> 'c) -> 'c -> 'a list * 'b list -> 'c (* @ $(SML_LIB)/basis/list/list-pair.sml 33.11-33.17 *)
val ListPair.foldr: ('a * 'b * 'c -> 'c) -> 'c -> 'a list * 'b list -> 'c (* @ $(SML_LIB)/basis/list/list-pair.sml 46.11-46.15 *)
val ListPair.foldrEq: ('a * 'b * 'c -> 'c) -> 'c -> 'a list * 'b list -> 'c (* @ $(SML_LIB)/basis/list/list-pair.sml 48.11-48.17 *)
val ListPair.map: ('a * 'b -> 'c) -> 'a list * 'b list -> 'c list (* @ $(SML_LIB)/basis/list/list-pair.sml 59.11-59.13 *)
val ListPair.mapEq: ('a * 'b -> 'c) -> 'a list * 'b list -> 'c list (* @ $(SML_LIB)/basis/list/list-pair.sml 61.11-61.15 *)
val ListPair.unzip: ('a * 'b) list -> 'a list * 'b list (* @ $(SML_LIB)/basis/list/list-pair.sml 17.11-17.15 *)
val ListPair.zip: 'a list * 'b list -> ('a * 'b) list (* @ $(SML_LIB)/basis/list/list-pair.sml 53.11-53.13 *)
val ListPair.zipEq: 'a list * 'b list -> ('a * 'b) list (* @ $(SML_LIB)/basis/list/list-pair.sml 55.11-55.15 *)
structure MLton: MLTON where type BinIO.instream = BinIO.instream where type BinIO.outstream = BinIO.outstream where type CharArray.elem = char where type CharArray.t = CharArray.array where type CharVector.elem = char where type CharVector.t = string where type 'a Cont.t = 'a MLton.Cont.t where type 'a Finalizable.t = 'a MLton.Finalizable.t where type IntInf.BigWord.word = MLton.IntInf.BigWord.word where type IntInf.SmallInt.int = MLton.IntInf.SmallInt.int where type IntInf.rep = MLton.IntInf.rep where type IntInf.t = LargeInt.int where type Itimer.t = MLton.Itimer.t where type LargeReal.t = real where type LargeWord.t = LargeWord.word where type Platform.Arch.t = MLton.Platform.Arch.t where type Platform.Format.t = MLton.Platform.Format.t where type Platform.OS.t = MLton.Platform.OS.t where type Pointer.t = MLton.Pointer.t where type ProcEnv.gid = Posix.SysDB.gid where type ('a, 'b) Process.Child.t = ('a, 'b) MLton.Process.Child.t where type ('a, 'b) Process.Param.t = ('a, 'b) MLton.Process.Param.t where type Process.any = MLton.Process.any where type Process.chain = MLton.Process.chain where type Process.input = MLton.Process.input where type Process.none = MLton.Process.none where type Process.output = MLton.Process.output where type Process.pid = Posix.TTY.pid where type ('a, 'b, 'c) Process.t = ('a, 'b, 'c) MLton.Process.t where type Profile.Data.t = MLton.Profile.Data.t where type Real.t = real where type Real32.t = Real32.real where type Real64.t = real where type Rlimit.RLim.t = MLton.Rlimit.RLim.t where type Rlimit.t = MLton.Rlimit.t where type Signal.Handler.t = MLton.Signal.Handler.t where type Signal.Mask.t = MLton.Signal.Mask.t where type Signal.t = Unix.signal where type Syslog.facility = MLton.Syslog.facility where type Syslog.loglevel = MLton.Syslog.loglevel where type Syslog.openflag = MLton.Syslog.openflag where type TextIO.instream = TextIO.instream where type TextIO.outstream = TextIO.outstream where type Thread.AtomicState.t = MLton.Thread.AtomicState.t where type Thread.Runnable.t = MLton.Thread.Runnable.t where type 'a Thread.t = 'a MLton.Thread.t where type 'a Weak.t = 'a MLton.Weak.t where type Word.t = word where type Word16.t = Word16.word where type Word32.t = word where type Word64.t = LargeWord.word where type Word8.t = Word8.word where type Word8Array.elem = Word8.word where type Word8Array.t = Word8Array.array where type Word8Vector.elem = Word8.word where type Word8Vector.t = Word8Vector.vector where type World.status = MLton.World.status (* @ $(SML_LIB)/basis/mlton.mlb 49.17-49.21 *)
val MLton.debug: bool (* @ $(SML_LIB)/basis/mlton/mlton.sml 35.5-35.9 *)
val MLton.eq: 'a * 'a -> bool (* @ $(SML_LIB)/basis/mlton/mlton.sml 36.5-36.6 *)
val MLton.equal: 'a * 'a -> bool (* @ $(SML_LIB)/basis/mlton/mlton.sml 37.5-37.9 *)
val MLton.hash: 'a -> word (* @ $(SML_LIB)/basis/mlton/mlton.sml 38.5-38.8 *)
val MLton.isMLton: bool (* @ $(SML_LIB)/basis/mlton/mlton.sml 13.5-13.11 *)
val MLton.safe: bool (* @ $(SML_LIB)/basis/mlton/mlton.sml 40.5-40.8 *)
val MLton.share: 'a -> unit (* @ $(SML_LIB)/basis/mlton/mlton.sml 22.5-22.9 *)
val MLton.shareAll: unit -> unit (* @ $(SML_LIB)/basis/mlton/mlton.sml 26.5-26.12 *)
val MLton.size: 'a -> int (* @ $(SML_LIB)/basis/mlton/mlton.sml 30.5-30.8 *)
structure MLton.Array: MLTON_ARRAY (* @ $(SML_LIB)/basis/mlton/mlton.sml 42.11-42.15 *)
val MLton.Array.unfoldi: int * 'a * (int * 'a -> 'b * 'a) -> 'b array * 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 108.11-108.17 *)
structure MLton.BinIO: MLTON_TEXT_IO where type instream = BinIO.instream where type outstream = BinIO.outstream (* @ $(SML_LIB)/basis/mlton/mlton.sml 43.11-43.15 *)
type MLton.BinIO.instream = BinIO.instream (* @ $(SML_LIB)/basis/io/imperative-io.fun 213.10-213.17 *)
type MLton.BinIO.outstream = BinIO.outstream (* @ $(SML_LIB)/basis/io/imperative-io.fun 100.6-100.14 *)
val MLton.BinIO.inFd: BinIO.instream -> Posix.TTY.file_desc (* @ $(SML_LIB)/basis/io/imperative-io.fun 248.5-248.8 *)
val MLton.BinIO.mkstemp: string -> string * BinIO.outstream (* @ $(SML_LIB)/basis/mlton/io.fun 35.5-35.11 *)
val MLton.BinIO.mkstemps: {prefix: string, suffix: string} -> string * BinIO.outstream (* @ $(SML_LIB)/basis/mlton/io.fun 14.5-14.12 *)
val MLton.BinIO.newIn: Posix.TTY.file_desc * string -> BinIO.instream (* @ $(SML_LIB)/basis/io/imperative-io.fun 737.5-737.9 *)
val MLton.BinIO.newOut: Posix.TTY.file_desc * string -> BinIO.outstream (* @ $(SML_LIB)/basis/io/imperative-io.fun 195.5-195.10 *)
val MLton.BinIO.outFd: BinIO.outstream -> Posix.TTY.file_desc (* @ $(SML_LIB)/basis/io/imperative-io.fun 198.5-198.9 *)
val MLton.BinIO.tempPrefix: string -> string (* @ $(SML_LIB)/basis/mlton/io.fun 37.5-37.14 *)
structure MLton.CharArray: MLTON_MONO_ARRAY where type elem = char where type t = CharArray.array (* @ $(SML_LIB)/basis/mlton/mlton.sml 45.11-45.19 *)
type MLton.CharArray.elem = char (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array.fun 22.12-22.15 *)
type MLton.CharArray.t = CharArray.array (* @ $(SML_LIB)/basis/mlton/mlton.sml 47.9-47.9 *)
val MLton.CharArray.fromPoly: char array -> CharArray.array (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array.fun 27.11-27.18 *)
val MLton.CharArray.toPoly: CharArray.array -> char array (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array.fun 28.11-28.16 *)
structure MLton.CharVector: MLTON_MONO_VECTOR where type elem = char where type t = string (* @ $(SML_LIB)/basis/mlton/mlton.sml 49.11-49.20 *)
type MLton.CharVector.elem = char (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-vector.fun 35.12-35.15 *)
type MLton.CharVector.t = string (* @ $(SML_LIB)/basis/mlton/mlton.sml 51.9-51.9 *)
val MLton.CharVector.fromPoly: string -> string (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-vector.fun 38.11-38.18 *)
val MLton.CharVector.toPoly: string -> string (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-vector.fun 39.11-39.16 *)
structure MLton.Cont: MLTON_CONT where type 'a t = 'a MLton.Cont.t (* @ $(SML_LIB)/basis/mlton/mlton.sml 53.11-53.14 *)
type 'a MLton.Cont.t = 'a MLton.Cont.t (* @ $(SML_LIB)/basis/mlton/cont.sml 25.9-25.9 *)
val MLton.Cont.callcc: ('a MLton.Cont.t -> 'a) -> 'a (* @ $(SML_LIB)/basis/mlton/cont.sml 27.5-27.10 *)
val MLton.Cont.isolate: ('a -> unit) -> 'a MLton.Cont.t (* @ $(SML_LIB)/basis/mlton/cont.sml 91.5-91.11 *)
val MLton.Cont.prepend: 'a MLton.Cont.t * ('b -> 'a) -> 'b MLton.Cont.t (* @ $(SML_LIB)/basis/mlton/cont.sml 70.5-70.11 *)
val MLton.Cont.throw: 'a MLton.Cont.t * 'a -> 'b (* @ $(SML_LIB)/basis/mlton/cont.sml 68.14-68.18 *)
val MLton.Cont.throw': 'a MLton.Cont.t * (unit -> 'a) -> 'b (* @ $(SML_LIB)/basis/mlton/cont.sml 65.14-65.19 *)
structure MLton.Exn: MLTON_EXN (* @ $(SML_LIB)/basis/mlton/mlton.sml 54.11-54.13 *)
val MLton.Exn.addExnMessager: (exn -> string option) -> unit (* @ $(SML_LIB)/basis/mlton/exn.sml 14.11-14.24 *)
val MLton.Exn.defaultTopLevelHandler: exn -> 'a (* @ $(SML_LIB)/basis/mlton/exn.sml 63.17-63.38 *)
val MLton.Exn.getTopLevelHandler: unit -> exn -> unit (* @ $(SML_LIB)/basis/mlton/exn.sml 61.14-61.31 *)
val MLton.Exn.history: exn -> string list (* @ $(SML_LIB)/basis/mlton/exn.sml 16.11-16.17 *)
val MLton.Exn.setTopLevelHandler: (exn -> unit) -> unit (* @ $(SML_LIB)/basis/mlton/exn.sml 62.14-62.31 *)
val MLton.Exn.topLevelHandler: exn -> 'a (* @ $(SML_LIB)/basis/mlton/exn.sml 65.17-65.31 *)
structure MLton.Finalizable: MLTON_FINALIZABLE where type 'a t = 'a MLton.Finalizable.t (* @ $(SML_LIB)/basis/mlton/mlton.sml 55.11-55.21 *)
type 'a MLton.Finalizable.t = 'a MLton.Finalizable.t (* @ $(SML_LIB)/basis/mlton/finalizable.sml 20.13-20.13 *)
val MLton.Finalizable.addFinalizer: 'a MLton.Finalizable.t * ('a -> unit) -> unit (* @ $(SML_LIB)/basis/mlton/finalizable.sml 30.5-30.16 *)
val MLton.Finalizable.finalizeBefore: 'a MLton.Finalizable.t * 'b MLton.Finalizable.t -> unit (* @ $(SML_LIB)/basis/mlton/finalizable.sml 88.5-88.18 *)
val MLton.Finalizable.new: 'a -> 'a MLton.Finalizable.t (* @ $(SML_LIB)/basis/mlton/finalizable.sml 70.5-70.7 *)
val MLton.Finalizable.touch: 'a MLton.Finalizable.t -> unit (* @ $(SML_LIB)/basis/mlton/finalizable.sml 24.5-24.9 *)
val MLton.Finalizable.withValue: 'a MLton.Finalizable.t * ('a -> 'b) -> 'b (* @ $(SML_LIB)/basis/mlton/finalizable.sml 26.5-26.13 *)
structure MLton.GC: MLTON_GC (* @ $(SML_LIB)/basis/mlton/mlton.sml 24.11-24.12 *)
val MLton.GC.collect: unit -> unit (* @ $(SML_LIB)/basis/primitive/prim-mlton.sml 121.11-121.17 *)
val MLton.GC.pack: unit -> unit (* @ $(SML_LIB)/basis/mlton/gc.sml 15.11-15.14 *)
val MLton.GC.setMessages: bool -> unit (* @ $(SML_LIB)/basis/mlton/gc.sml 22.11-22.21 *)
val MLton.GC.setSummary: bool -> unit (* @ $(SML_LIB)/basis/mlton/gc.sml 26.11-26.20 *)
val MLton.GC.unpack: unit -> unit (* @ $(SML_LIB)/basis/mlton/gc.sml 17.11-17.16 *)
structure MLton.GC.Statistics:
   sig
      val bytesAllocated: unit -> LargeInt.int
      val lastBytesLive: unit -> LargeInt.int
      val maxBytesLive: unit -> LargeInt.int
      val numCopyingGCs: unit -> LargeInt.int
      val numMarkCompactGCs: unit -> LargeInt.int
      val numMinorGCs: unit -> LargeInt.int
   end
   (* @ $(SML_LIB)/basis/mlton/gc.sml 29.17-29.26 *)
val MLton.GC.Statistics.bytesAllocated: unit -> LargeInt.int (* @ $(SML_LIB)/basis/mlton/gc.sml 37.20-37.33 *)
val MLton.GC.Statistics.lastBytesLive: unit -> LargeInt.int (* @ $(SML_LIB)/basis/mlton/gc.sml 38.20-38.32 *)
val MLton.GC.Statistics.maxBytesLive: unit -> LargeInt.int (* @ $(SML_LIB)/basis/mlton/gc.sml 39.20-39.31 *)
val MLton.GC.Statistics.numCopyingGCs: unit -> LargeInt.int (* @ $(SML_LIB)/basis/mlton/gc.sml 40.20-40.32 *)
val MLton.GC.Statistics.numMarkCompactGCs: unit -> LargeInt.int (* @ $(SML_LIB)/basis/mlton/gc.sml 41.20-41.36 *)
val MLton.GC.Statistics.numMinorGCs: unit -> LargeInt.int (* @ $(SML_LIB)/basis/mlton/gc.sml 42.20-42.30 *)
structure MLton.IntInf: MLTON_INT_INF where type BigWord.word = MLton.IntInf.BigWord.word where type SmallInt.int = MLton.IntInf.SmallInt.int where type rep = MLton.IntInf.rep where type t = LargeInt.int (* @ $(SML_LIB)/basis/mlton/mlton.sml 56.11-56.16 *)
datatype MLton.IntInf.rep = Big of MLton.IntInf.BigWord.word vector | Small of MLton.IntInf.SmallInt.int (* = datatype MLton.IntInf.rep *) (* @ $(SML_LIB)/basis/integer/int-inf0.sml 432.16-432.18 *)
type MLton.IntInf.t = LargeInt.int (* @ $(SML_LIB)/basis/mlton/mlton.sml 59.12-59.12 *)
con MLton.IntInf.Big: MLton.IntInf.BigWord.word vector -> MLton.IntInf.rep (* @ $(SML_LIB)/basis/integer/int-inf0.sml 433.10-433.12 *)
con MLton.IntInf.Small: MLton.IntInf.SmallInt.int -> MLton.IntInf.rep (* @ $(SML_LIB)/basis/integer/int-inf0.sml 434.10-434.14 *)
val MLton.IntInf.areSmall: LargeInt.int * LargeInt.int -> bool (* @ $(SML_LIB)/basis/integer/int-inf0.sml 411.11-411.18 *)
val MLton.IntInf.fromRep: MLton.IntInf.rep -> LargeInt.int option (* @ $(SML_LIB)/basis/integer/int-inf0.sml 441.11-441.17 *)
val MLton.IntInf.gcd: LargeInt.int * LargeInt.int -> LargeInt.int (* @ $(SML_LIB)/basis/integer/int-inf0.sml 1332.11-1332.13 *)
val MLton.IntInf.isSmall: LargeInt.int -> bool (* @ $(SML_LIB)/basis/integer/int-inf0.sml 407.11-407.17 *)
val MLton.IntInf.rep: LargeInt.int -> MLton.IntInf.rep (* @ $(SML_LIB)/basis/integer/int-inf0.sml 436.11-436.13 *)
structure MLton.IntInf.BigWord: WORD where type word = MLton.IntInf.BigWord.word (* @ $(SML_LIB)/basis/integer/int-inf.sml 15.17-15.23 *)
type MLton.IntInf.BigWord.word = MLton.IntInf.BigWord.word (* @ $(SML_LIB)/basis/primitive/prim-basis.sml 431.12-431.15 *)
val MLton.IntInf.BigWord.* : MLton.IntInf.BigWord.word * MLton.IntInf.BigWord.word -> MLton.IntInf.BigWord.word (* @ $(SML_LIB)/basis/primitive/prim-word.sml 396.11-396.11 *)
val MLton.IntInf.BigWord.+ : MLton.IntInf.BigWord.word * MLton.IntInf.BigWord.word -> MLton.IntInf.BigWord.word (* @ $(SML_LIB)/basis/primitive/prim-word.sml 393.11-393.11 *)
val MLton.IntInf.BigWord.- : MLton.IntInf.BigWord.word * MLton.IntInf.BigWord.word -> MLton.IntInf.BigWord.word (* @ $(SML_LIB)/basis/primitive/prim-word.sml 406.11-406.11 *)
val MLton.IntInf.BigWord.< : MLton.IntInf.BigWord.word * MLton.IntInf.BigWord.word -> bool (* @ $(SML_LIB)/basis/util/integral-comparisons.sml 11.11-11.11 *)
val MLton.IntInf.BigWord.<< : MLton.IntInf.BigWord.word * word -> MLton.IntInf.BigWord.word (* @ $(SML_LIB)/basis/integer/word.sml 19.5-19.6 *)
val MLton.IntInf.BigWord.<= : MLton.IntInf.BigWord.word * MLton.IntInf.BigWord.word -> bool (* @ $(SML_LIB)/basis/util/integral-comparisons.sml 12.11-12.12 *)
val MLton.IntInf.BigWord.> : MLton.IntInf.BigWord.word * MLton.IntInf.BigWord.word -> bool (* @ $(SML_LIB)/basis/util/integral-comparisons.sml 13.11-13.11 *)
val MLton.IntInf.BigWord.>= : MLton.IntInf.BigWord.word * MLton.IntInf.BigWord.word -> bool (* @ $(SML_LIB)/basis/util/integral-comparisons.sml 14.11-14.12 *)
val MLton.IntInf.BigWord.>> : MLton.IntInf.BigWord.word * word -> MLton.IntInf.BigWord.word (* @ $(SML_LIB)/basis/integer/word.sml 23.5-23.6 *)
val MLton.IntInf.BigWord.andb: MLton.IntInf.BigWord.word * MLton.IntInf.BigWord.word -> MLton.IntInf.BigWord.word (* @ $(SML_LIB)/basis/primitive/prim-word.sml 394.11-394.14 *)
val MLton.IntInf.BigWord.compare: MLton.IntInf.BigWord.word * MLton.IntInf.BigWord.word -> order (* @ $(SML_LIB)/basis/util/integral-comparisons.sml 16.11-16.17 *)
val MLton.IntInf.BigWord.div: MLton.IntInf.BigWord.word * MLton.IntInf.BigWord.word -> MLton.IntInf.BigWord.word (* @ $(SML_LIB)/basis/integer/num0.sml 97.23-97.25 *)
val MLton.IntInf.BigWord.fmt: StringCvt.radix -> MLton.IntInf.BigWord.word -> string (* @ $(SML_LIB)/basis/integer/word.sml 104.8-104.10 *)
val MLton.IntInf.BigWord.fromInt: int -> MLton.IntInf.BigWord.word (* @ $(SML_LIB)/basis/integer/word.sml 55.5-55.11 *)
val MLton.IntInf.BigWord.fromLarge: LargeWord.word -> MLton.IntInf.BigWord.word (* @ $(SML_LIB)/basis/integer/word.sml 87.5-87.13 *)
val MLton.IntInf.BigWord.fromLargeInt: LargeInt.int -> MLton.IntInf.BigWord.word (* @ $(SML_LIB)/basis/integer/word.sml 70.5-70.16 *)
val MLton.IntInf.BigWord.fromLargeWord: LargeWord.word -> MLton.IntInf.BigWord.word (* @ $(SML_LIB)/basis/integer/word.sml 86.5-86.17 *)
val MLton.IntInf.BigWord.fromString: string -> MLton.IntInf.BigWord.word option (* @ $(SML_LIB)/basis/integer/word.sml 209.5-209.14 *)
val MLton.IntInf.BigWord.max: MLton.IntInf.BigWord.word * MLton.IntInf.BigWord.word -> MLton.IntInf.BigWord.word (* @ $(SML_LIB)/basis/util/integral-comparisons.sml 21.11-21.13 *)
val MLton.IntInf.BigWord.min: MLton.IntInf.BigWord.word * MLton.IntInf.BigWord.word -> MLton.IntInf.BigWord.word (* @ $(SML_LIB)/basis/util/integral-comparisons.sml 20.11-20.13 *)
val MLton.IntInf.BigWord.mod: MLton.IntInf.BigWord.word * MLton.IntInf.BigWord.word -> MLton.IntInf.BigWord.word (* @ $(SML_LIB)/basis/integer/num0.sml 98.23-98.25 *)
val MLton.IntInf.BigWord.notb: MLton.IntInf.BigWord.word -> MLton.IntInf.BigWord.word (* @ $(SML_LIB)/basis/primitive/prim-word.sml 398.11-398.14 *)
val MLton.IntInf.BigWord.orb: MLton.IntInf.BigWord.word * MLton.IntInf.BigWord.word -> MLton.IntInf.BigWord.word (* @ $(SML_LIB)/basis/primitive/prim-word.sml 399.11-399.13 *)
val MLton.IntInf.BigWord.scan: StringCvt.radix -> ('a -> (char * 'a) option) -> 'a -> (MLton.IntInf.BigWord.word * 'a) option (* @ $(SML_LIB)/basis/integer/word.sml 146.5-146.8 *)
val MLton.IntInf.BigWord.toInt: MLton.IntInf.BigWord.word -> int (* @ $(SML_LIB)/basis/integer/word.sml 57.5-57.9 *)
val MLton.IntInf.BigWord.toIntX: MLton.IntInf.BigWord.word -> int (* @ $(SML_LIB)/basis/integer/word.sml 56.5-56.10 *)
val MLton.IntInf.BigWord.toLarge: MLton.IntInf.BigWord.word -> LargeWord.word (* @ $(SML_LIB)/basis/integer/word.sml 91.5-91.11 *)
val MLton.IntInf.BigWord.toLargeInt: MLton.IntInf.BigWord.word -> LargeInt.int (* @ $(SML_LIB)/basis/integer/word.sml 72.5-72.14 *)
val MLton.IntInf.BigWord.toLargeIntX: MLton.IntInf.BigWord.word -> LargeInt.int (* @ $(SML_LIB)/basis/integer/word.sml 71.5-71.15 *)
val MLton.IntInf.BigWord.toLargeWord: MLton.IntInf.BigWord.word -> LargeWord.word (* @ $(SML_LIB)/basis/integer/word.sml 90.5-90.15 *)
val MLton.IntInf.BigWord.toLargeWordX: MLton.IntInf.BigWord.word -> LargeWord.word (* @ $(SML_LIB)/basis/integer/word.sml 88.5-88.16 *)
val MLton.IntInf.BigWord.toLargeX: MLton.IntInf.BigWord.word -> LargeWord.word (* @ $(SML_LIB)/basis/integer/word.sml 89.5-89.12 *)
val MLton.IntInf.BigWord.toString: MLton.IntInf.BigWord.word -> string (* @ $(SML_LIB)/basis/integer/word.sml 144.5-144.12 *)
val MLton.IntInf.BigWord.wordSize: int (* @ $(SML_LIB)/basis/integer/word.sml 16.5-16.12 *)
val MLton.IntInf.BigWord.xorb: MLton.IntInf.BigWord.word * MLton.IntInf.BigWord.word -> MLton.IntInf.BigWord.word (* @ $(SML_LIB)/basis/primitive/prim-word.sml 407.11-407.14 *)
val MLton.IntInf.BigWord.~ : MLton.IntInf.BigWord.word -> MLton.IntInf.BigWord.word (* @ $(SML_LIB)/basis/primitive/prim-word.sml 397.11-397.11 *)
val MLton.IntInf.BigWord.~>> : MLton.IntInf.BigWord.word * word -> MLton.IntInf.BigWord.word (* @ $(SML_LIB)/basis/integer/word.sml 27.5-27.7 *)
structure MLton.IntInf.SmallInt: INTEGER where type int = MLton.IntInf.SmallInt.int (* @ $(SML_LIB)/basis/integer/int-inf.sml 16.17-16.24 *)
type MLton.IntInf.SmallInt.int = MLton.IntInf.SmallInt.int (* @ $(SML_LIB)/basis/primitive/prim-basis.sml 233.12-233.14 *)
val MLton.IntInf.SmallInt.* : MLton.IntInf.SmallInt.int * MLton.IntInf.SmallInt.int -> MLton.IntInf.SmallInt.int (* @ $(SML_LIB)/basis/primitive/prim-int.sml 438.11-438.11 *)
val MLton.IntInf.SmallInt.+ : MLton.IntInf.SmallInt.int * MLton.IntInf.SmallInt.int -> MLton.IntInf.SmallInt.int (* @ $(SML_LIB)/basis/primitive/prim-int.sml 432.11-432.11 *)
val MLton.IntInf.SmallInt.- : MLton.IntInf.SmallInt.int * MLton.IntInf.SmallInt.int -> MLton.IntInf.SmallInt.int (* @ $(SML_LIB)/basis/primitive/prim-int.sml 451.11-451.11 *)
val MLton.IntInf.SmallInt.< : MLton.IntInf.SmallInt.int * MLton.IntInf.SmallInt.int -> bool (* @ $(SML_LIB)/basis/util/integral-comparisons.sml 11.11-11.11 *)
val MLton.IntInf.SmallInt.<= : MLton.IntInf.SmallInt.int * MLton.IntInf.SmallInt.int -> bool (* @ $(SML_LIB)/basis/util/integral-comparisons.sml 12.11-12.12 *)
val MLton.IntInf.SmallInt.> : MLton.IntInf.SmallInt.int * MLton.IntInf.SmallInt.int -> bool (* @ $(SML_LIB)/basis/util/integral-comparisons.sml 13.11-13.11 *)
val MLton.IntInf.SmallInt.>= : MLton.IntInf.SmallInt.int * MLton.IntInf.SmallInt.int -> bool (* @ $(SML_LIB)/basis/util/integral-comparisons.sml 14.11-14.12 *)
val MLton.IntInf.SmallInt.abs: MLton.IntInf.SmallInt.int -> MLton.IntInf.SmallInt.int (* @ $(SML_LIB)/basis/integer/num0.sml 161.17-161.19 *)
val MLton.IntInf.SmallInt.compare: MLton.IntInf.SmallInt.int * MLton.IntInf.SmallInt.int -> order (* @ $(SML_LIB)/basis/util/integral-comparisons.sml 16.11-16.17 *)
val MLton.IntInf.SmallInt.div: MLton.IntInf.SmallInt.int * MLton.IntInf.SmallInt.int -> MLton.IntInf.SmallInt.int (* @ $(SML_LIB)/basis/integer/num0.sml 183.19-183.21 *)
val MLton.IntInf.SmallInt.fmt: StringCvt.radix -> MLton.IntInf.SmallInt.int -> string (* @ $(SML_LIB)/basis/integer/int.sml 74.8-74.10 *)
val MLton.IntInf.SmallInt.fromInt: int -> MLton.IntInf.SmallInt.int (* @ $(SML_LIB)/basis/integer/int.sml 46.5-46.11 *)
val MLton.IntInf.SmallInt.fromLarge: LargeInt.int -> MLton.IntInf.SmallInt.int (* @ $(SML_LIB)/basis/integer/int.sml 51.5-51.13 *)
val MLton.IntInf.SmallInt.fromString: string -> MLton.IntInf.SmallInt.int option (* @ $(SML_LIB)/basis/integer/int.sml 165.5-165.14 *)
val MLton.IntInf.SmallInt.max: MLton.IntInf.SmallInt.int * MLton.IntInf.SmallInt.int -> MLton.IntInf.SmallInt.int (* @ $(SML_LIB)/basis/util/integral-comparisons.sml 21.11-21.13 *)
val MLton.IntInf.SmallInt.maxInt: MLton.IntInf.SmallInt.int option (* @ $(SML_LIB)/basis/integer/int.sml 19.5-19.10 *)
val MLton.IntInf.SmallInt.min: MLton.IntInf.SmallInt.int * MLton.IntInf.SmallInt.int -> MLton.IntInf.SmallInt.int (* @ $(SML_LIB)/basis/util/integral-comparisons.sml 20.11-20.13 *)
val MLton.IntInf.SmallInt.minInt: MLton.IntInf.SmallInt.int option (* @ $(SML_LIB)/basis/integer/int.sml 20.5-20.10 *)
val MLton.IntInf.SmallInt.mod: MLton.IntInf.SmallInt.int * MLton.IntInf.SmallInt.int -> MLton.IntInf.SmallInt.int (* @ $(SML_LIB)/basis/integer/num0.sml 204.19-204.21 *)
val MLton.IntInf.SmallInt.precision: int option (* @ $(SML_LIB)/basis/integer/int.sml 16.5-16.13 *)
val MLton.IntInf.SmallInt.quot: MLton.IntInf.SmallInt.int * MLton.IntInf.SmallInt.int -> MLton.IntInf.SmallInt.int (* @ $(SML_LIB)/basis/integer/num0.sml 163.17-163.20 *)
val MLton.IntInf.SmallInt.rem: MLton.IntInf.SmallInt.int * MLton.IntInf.SmallInt.int -> MLton.IntInf.SmallInt.int (* @ $(SML_LIB)/basis/integer/num0.sml 175.17-175.19 *)
val MLton.IntInf.SmallInt.sameSign: MLton.IntInf.SmallInt.int * MLton.IntInf.SmallInt.int -> bool (* @ $(SML_LIB)/basis/integer/int.sml 29.5-29.12 *)
val MLton.IntInf.SmallInt.scan: StringCvt.radix -> ('a -> (char * 'a) option) -> 'a -> (MLton.IntInf.SmallInt.int * 'a) option (* @ $(SML_LIB)/basis/integer/int.sml 112.5-112.8 *)
val MLton.IntInf.SmallInt.sign: MLton.IntInf.SmallInt.int -> int (* @ $(SML_LIB)/basis/integer/int.sml 22.5-22.8 *)
val MLton.IntInf.SmallInt.toInt: MLton.IntInf.SmallInt.int -> int (* @ $(SML_LIB)/basis/integer/int.sml 47.5-47.9 *)
val MLton.IntInf.SmallInt.toLarge: MLton.IntInf.SmallInt.int -> LargeInt.int (* @ $(SML_LIB)/basis/integer/int.sml 52.5-52.11 *)
val MLton.IntInf.SmallInt.toString: MLton.IntInf.SmallInt.int -> string (* @ $(SML_LIB)/basis/integer/int.sml 110.5-110.12 *)
val MLton.IntInf.SmallInt.~ : MLton.IntInf.SmallInt.int -> MLton.IntInf.SmallInt.int (* @ $(SML_LIB)/basis/primitive/prim-int.sml 444.11-444.11 *)
structure MLton.Itimer: MLTON_ITIMER where type t = MLton.Itimer.t (* @ $(SML_LIB)/basis/mlton/mlton.sml 61.11-61.16 *)
datatype MLton.Itimer.t = Prof | Real | Virtual (* = datatype MLton.Itimer.t *) (* @ $(SML_LIB)/basis/mlton/itimer.sml 13.16-13.16 *)
con MLton.Itimer.Prof: MLton.Itimer.t (* @ $(SML_LIB)/basis/mlton/itimer.sml 13.20-13.23 *)
con MLton.Itimer.Real: MLton.Itimer.t (* @ $(SML_LIB)/basis/mlton/itimer.sml 13.27-13.30 *)
con MLton.Itimer.Virtual: MLton.Itimer.t (* @ $(SML_LIB)/basis/mlton/itimer.sml 13.34-13.40 *)
val MLton.Itimer.set: MLton.Itimer.t * {interval: Time.time, value: Time.time} -> unit (* @ $(SML_LIB)/basis/mlton/itimer.sml 40.11-40.13 *)
val MLton.Itimer.signal: MLton.Itimer.t -> Unix.signal (* @ $(SML_LIB)/basis/mlton/itimer.sml 15.11-15.16 *)
structure MLton.LargeReal: MLTON_REAL where type t = real (* @ $(SML_LIB)/basis/mlton/mlton.sml 62.11-62.19 *)
type MLton.LargeReal.t = real (* @ $(SML_LIB)/basis/mlton/mlton.sml 65.12-65.12 *)
val MLton.LargeReal.fromLargeWord: LargeWord.word -> real (* @ $(SML_LIB)/basis/real/real.sml 977.14-977.26 *)
val MLton.LargeReal.fromWord: word -> real (* @ $(SML_LIB)/basis/real/real.sml 966.14-966.21 *)
val MLton.LargeReal.toLargeWord: IEEEReal.rounding_mode -> real -> LargeWord.word (* @ $(SML_LIB)/basis/real/real.sml 999.14-999.24 *)
val MLton.LargeReal.toWord: IEEEReal.rounding_mode -> real -> word (* @ $(SML_LIB)/basis/real/real.sml 988.14-988.19 *)
structure MLton.LargeWord: MLTON_WORD where type t = LargeWord.word (* @ $(SML_LIB)/basis/mlton/mlton.sml 67.11-67.19 *)
type MLton.LargeWord.t = LargeWord.word (* @ $(SML_LIB)/basis/mlton/mlton.sml 70.12-70.12 *)
val MLton.LargeWord.bswap: LargeWord.word -> LargeWord.word (* @ $(SML_LIB)/basis/integer/word.sml 52.8-52.12 *)
val MLton.LargeWord.rol: LargeWord.word * word -> LargeWord.word (* @ $(SML_LIB)/basis/integer/word.sml 31.5-31.7 *)
val MLton.LargeWord.ror: LargeWord.word * word -> LargeWord.word (* @ $(SML_LIB)/basis/integer/word.sml 32.5-32.7 *)
structure MLton.Platform: MLTON_PLATFORM where type Arch.t = MLton.Platform.Arch.t where type Format.t = MLton.Platform.Format.t where type OS.t = MLton.Platform.OS.t (* @ $(SML_LIB)/basis/mlton/mlton.sml 72.11-72.18 *)
structure MLton.Platform.Arch:
   sig
      datatype t = AMD64 | ARM | ARM64 | Alpha | HPPA | IA64 | MIPS | PowerPC | PowerPC64 | S390 | Sparc | X86 | m68k (* = datatype MLton.Platform.Arch.t *)
      val fromString: string -> MLton.Platform.Arch.t option
      val host: MLton.Platform.Arch.t
      val toString: MLton.Platform.Arch.t -> string
   end
   (* @ $(SML_LIB)/basis/mlton/platform.sml 15.17-15.20 *)
datatype MLton.Platform.Arch.t = AMD64 | ARM | ARM64 | Alpha | HPPA | IA64 | MIPS | PowerPC | PowerPC64 | S390 | Sparc | X86 | m68k (* = datatype MLton.Platform.Arch.t *) (* @ $(SML_LIB)/basis/primitive/prim-mlton.sml 148.22-148.22 *)
con MLton.Platform.Arch.AMD64: MLton.Platform.Arch.t (* @ $(SML_LIB)/basis/primitive/prim-mlton.sml 150.16-150.20 *)
con MLton.Platform.Arch.ARM: MLton.Platform.Arch.t (* @ $(SML_LIB)/basis/primitive/prim-mlton.sml 151.16-151.18 *)
con MLton.Platform.Arch.ARM64: MLton.Platform.Arch.t (* @ $(SML_LIB)/basis/primitive/prim-mlton.sml 152.16-152.20 *)
con MLton.Platform.Arch.Alpha: MLton.Platform.Arch.t (* @ $(SML_LIB)/basis/primitive/prim-mlton.sml 149.16-149.20 *)
con MLton.Platform.Arch.HPPA: MLton.Platform.Arch.t (* @ $(SML_LIB)/basis/primitive/prim-mlton.sml 153.16-153.19 *)
con MLton.Platform.Arch.IA64: MLton.Platform.Arch.t (* @ $(SML_LIB)/basis/primitive/prim-mlton.sml 154.16-154.19 *)
con MLton.Platform.Arch.MIPS: MLton.Platform.Arch.t (* @ $(SML_LIB)/basis/primitive/prim-mlton.sml 156.16-156.19 *)
con MLton.Platform.Arch.PowerPC: MLton.Platform.Arch.t (* @ $(SML_LIB)/basis/primitive/prim-mlton.sml 157.16-157.22 *)
con MLton.Platform.Arch.PowerPC64: MLton.Platform.Arch.t (* @ $(SML_LIB)/basis/primitive/prim-mlton.sml 158.16-158.24 *)
con MLton.Platform.Arch.S390: MLton.Platform.Arch.t (* @ $(SML_LIB)/basis/primitive/prim-mlton.sml 159.16-159.19 *)
con MLton.Platform.Arch.Sparc: MLton.Platform.Arch.t (* @ $(SML_LIB)/basis/primitive/prim-mlton.sml 160.16-160.20 *)
con MLton.Platform.Arch.X86: MLton.Platform.Arch.t (* @ $(SML_LIB)/basis/primitive/prim-mlton.sml 161.16-161.18 *)
val MLton.Platform.Arch.fromString: string -> MLton.Platform.Arch.t option (* @ $(SML_LIB)/basis/mlton/platform.sml 34.17-34.26 *)
val MLton.Platform.Arch.host: MLton.Platform.Arch.t (* @ $(SML_LIB)/basis/primitive/prim-mlton.sml 163.17-163.20 *)
con MLton.Platform.Arch.m68k: MLton.Platform.Arch.t (* @ $(SML_LIB)/basis/primitive/prim-mlton.sml 155.16-155.19 *)
val MLton.Platform.Arch.toString: MLton.Platform.Arch.t -> string (* @ $(SML_LIB)/basis/mlton/platform.sml 41.17-41.24 *)
structure MLton.Platform.Format:
   sig
      datatype t = Archive | Executable | LibArchive | Library (* = datatype MLton.Platform.Format.t *)
      val fromString: string -> MLton.Platform.Format.t option
      val host: MLton.Platform.Format.t
      val toString: MLton.Platform.Format.t -> string
   end
   (* @ $(SML_LIB)/basis/mlton/platform.sml 44.17-44.22 *)
datatype MLton.Platform.Format.t = Archive | Executable | LibArchive | Library (* = datatype MLton.Platform.Format.t *) (* @ $(SML_LIB)/basis/primitive/prim-mlton.sml 185.22-185.22 *)
con MLton.Platform.Format.Archive: MLton.Platform.Format.t (* @ $(SML_LIB)/basis/primitive/prim-mlton.sml 186.16-186.22 *)
con MLton.Platform.Format.Executable: MLton.Platform.Format.t (* @ $(SML_LIB)/basis/primitive/prim-mlton.sml 187.16-187.25 *)
con MLton.Platform.Format.LibArchive: MLton.Platform.Format.t (* @ $(SML_LIB)/basis/primitive/prim-mlton.sml 188.16-188.25 *)
con MLton.Platform.Format.Library: MLton.Platform.Format.t (* @ $(SML_LIB)/basis/primitive/prim-mlton.sml 189.16-189.22 *)
val MLton.Platform.Format.fromString: string -> MLton.Platform.Format.t option (* @ $(SML_LIB)/basis/mlton/platform.sml 54.17-54.26 *)
val MLton.Platform.Format.host: MLton.Platform.Format.t (* @ $(SML_LIB)/basis/primitive/prim-mlton.sml 191.17-191.20 *)
val MLton.Platform.Format.toString: MLton.Platform.Format.t -> string (* @ $(SML_LIB)/basis/mlton/platform.sml 61.17-61.24 *)
structure MLton.Platform.OS:
   sig
      datatype t = AIX | Cygwin | Darwin | FreeBSD | HPUX | Hurd | Linux | MinGW | NetBSD | OpenBSD | Solaris (* = datatype MLton.Platform.OS.t *)
      val fromString: string -> MLton.Platform.OS.t option
      val host: MLton.Platform.OS.t
      val toString: MLton.Platform.OS.t -> string
   end
   (* @ $(SML_LIB)/basis/mlton/platform.sml 64.17-64.18 *)
datatype MLton.Platform.OS.t = AIX | Cygwin | Darwin | FreeBSD | HPUX | Hurd | Linux | MinGW | NetBSD | OpenBSD | Solaris (* = datatype MLton.Platform.OS.t *) (* @ $(SML_LIB)/basis/primitive/prim-mlton.sml 202.22-202.22 *)
con MLton.Platform.OS.AIX: MLton.Platform.OS.t (* @ $(SML_LIB)/basis/primitive/prim-mlton.sml 203.16-203.18 *)
con MLton.Platform.OS.Cygwin: MLton.Platform.OS.t (* @ $(SML_LIB)/basis/primitive/prim-mlton.sml 204.16-204.21 *)
con MLton.Platform.OS.Darwin: MLton.Platform.OS.t (* @ $(SML_LIB)/basis/primitive/prim-mlton.sml 205.16-205.21 *)
con MLton.Platform.OS.FreeBSD: MLton.Platform.OS.t (* @ $(SML_LIB)/basis/primitive/prim-mlton.sml 206.16-206.22 *)
con MLton.Platform.OS.HPUX: MLton.Platform.OS.t (* @ $(SML_LIB)/basis/primitive/prim-mlton.sml 208.16-208.19 *)
con MLton.Platform.OS.Hurd: MLton.Platform.OS.t (* @ $(SML_LIB)/basis/primitive/prim-mlton.sml 207.16-207.19 *)
con MLton.Platform.OS.Linux: MLton.Platform.OS.t (* @ $(SML_LIB)/basis/primitive/prim-mlton.sml 209.16-209.20 *)
con MLton.Platform.OS.MinGW: MLton.Platform.OS.t (* @ $(SML_LIB)/basis/primitive/prim-mlton.sml 210.16-210.20 *)
con MLton.Platform.OS.NetBSD: MLton.Platform.OS.t (* @ $(SML_LIB)/basis/primitive/prim-mlton.sml 211.16-211.21 *)
con MLton.Platform.OS.OpenBSD: MLton.Platform.OS.t (* @ $(SML_LIB)/basis/primitive/prim-mlton.sml 212.16-212.22 *)
con MLton.Platform.OS.Solaris: MLton.Platform.OS.t (* @ $(SML_LIB)/basis/primitive/prim-mlton.sml 213.16-213.22 *)
val MLton.Platform.OS.fromString: string -> MLton.Platform.OS.t option (* @ $(SML_LIB)/basis/mlton/platform.sml 81.17-81.26 *)
val MLton.Platform.OS.host: MLton.Platform.OS.t (* @ $(SML_LIB)/basis/primitive/prim-mlton.sml 215.17-215.20 *)
val MLton.Platform.OS.toString: MLton.Platform.OS.t -> string (* @ $(SML_LIB)/basis/mlton/platform.sml 88.17-88.24 *)
structure MLton.Pointer: MLTON_POINTER where type t = MLton.Pointer.t (* @ $(SML_LIB)/basis/mlton/mlton.sml 73.11-73.17 *)
type MLton.Pointer.t = MLton.Pointer.t (* @ $(SML_LIB)/basis/primitive/prim-basis.sml 437.12-437.12 *)
val MLton.Pointer.add: MLton.Pointer.t * word -> MLton.Pointer.t (* @ $(SML_LIB)/basis/mlton/pointer.sml 17.5-17.7 *)
val MLton.Pointer.compare: MLton.Pointer.t * MLton.Pointer.t -> order (* @ $(SML_LIB)/basis/util/integral-comparisons.sml 16.11-16.17 *)
val MLton.Pointer.diff: MLton.Pointer.t * MLton.Pointer.t -> word (* @ $(SML_LIB)/basis/mlton/pointer.sml 21.5-21.8 *)
val MLton.Pointer.getInt16: MLton.Pointer.t * int -> Int16.int (* @ $(SML_LIB)/basis/mlton/pointer.sml 30.8-30.15 *)
val MLton.Pointer.getInt32: MLton.Pointer.t * int -> int (* @ $(SML_LIB)/basis/mlton/pointer.sml 31.8-31.15 *)
val MLton.Pointer.getInt64: MLton.Pointer.t * int -> Int64.int (* @ $(SML_LIB)/basis/mlton/pointer.sml 32.8-32.15 *)
val MLton.Pointer.getInt8: MLton.Pointer.t * int -> Int8.int (* @ $(SML_LIB)/basis/mlton/pointer.sml 29.8-29.14 *)
val MLton.Pointer.getPointer: MLton.Pointer.t * int -> MLton.Pointer.t (* @ $(SML_LIB)/basis/mlton/pointer.sml 41.5-41.14 *)
val MLton.Pointer.getReal32: MLton.Pointer.t * int -> Real32.real (* @ $(SML_LIB)/basis/mlton/pointer.sml 34.8-34.16 *)
val MLton.Pointer.getReal64: MLton.Pointer.t * int -> real (* @ $(SML_LIB)/basis/mlton/pointer.sml 35.8-35.16 *)
val MLton.Pointer.getWord16: MLton.Pointer.t * int -> Word16.word (* @ $(SML_LIB)/basis/mlton/pointer.sml 37.8-37.16 *)
val MLton.Pointer.getWord32: MLton.Pointer.t * int -> word (* @ $(SML_LIB)/basis/mlton/pointer.sml 38.8-38.16 *)
val MLton.Pointer.getWord64: MLton.Pointer.t * int -> LargeWord.word (* @ $(SML_LIB)/basis/mlton/pointer.sml 39.8-39.16 *)
val MLton.Pointer.getWord8: MLton.Pointer.t * int -> Word8.word (* @ $(SML_LIB)/basis/mlton/pointer.sml 36.8-36.15 *)
val MLton.Pointer.null: MLton.Pointer.t (* @ $(SML_LIB)/basis/primitive/prim-mlton.sml 265.11-265.14 *)
val MLton.Pointer.setInt16: MLton.Pointer.t * int * Int16.int -> unit (* @ $(SML_LIB)/basis/mlton/pointer.sml 49.8-49.15 *)
val MLton.Pointer.setInt32: MLton.Pointer.t * int * int -> unit (* @ $(SML_LIB)/basis/mlton/pointer.sml 50.8-50.15 *)
val MLton.Pointer.setInt64: MLton.Pointer.t * int * Int64.int -> unit (* @ $(SML_LIB)/basis/mlton/pointer.sml 51.8-51.15 *)
val MLton.Pointer.setInt8: MLton.Pointer.t * int * Int8.int -> unit (* @ $(SML_LIB)/basis/mlton/pointer.sml 48.8-48.14 *)
val MLton.Pointer.setPointer: MLton.Pointer.t * int * MLton.Pointer.t -> unit (* @ $(SML_LIB)/basis/mlton/pointer.sml 60.5-60.14 *)
val MLton.Pointer.setReal32: MLton.Pointer.t * int * Real32.real -> unit (* @ $(SML_LIB)/basis/mlton/pointer.sml 53.8-53.16 *)
val MLton.Pointer.setReal64: MLton.Pointer.t * int * real -> unit (* @ $(SML_LIB)/basis/mlton/pointer.sml 54.8-54.16 *)
val MLton.Pointer.setWord16: MLton.Pointer.t * int * Word16.word -> unit (* @ $(SML_LIB)/basis/mlton/pointer.sml 56.8-56.16 *)
val MLton.Pointer.setWord32: MLton.Pointer.t * int * word -> unit (* @ $(SML_LIB)/basis/mlton/pointer.sml 57.8-57.16 *)
val MLton.Pointer.setWord64: MLton.Pointer.t * int * LargeWord.word -> unit (* @ $(SML_LIB)/basis/mlton/pointer.sml 58.8-58.16 *)
val MLton.Pointer.setWord8: MLton.Pointer.t * int * Word8.word -> unit (* @ $(SML_LIB)/basis/mlton/pointer.sml 55.8-55.15 *)
val MLton.Pointer.sizeofPointer: word (* @ $(SML_LIB)/basis/mlton/pointer.sml 14.5-14.17 *)
val MLton.Pointer.sub: MLton.Pointer.t * word -> MLton.Pointer.t (* @ $(SML_LIB)/basis/mlton/pointer.sml 19.5-19.7 *)
structure MLton.ProcEnv: MLTON_PROC_ENV where type gid = Posix.SysDB.gid (* @ $(SML_LIB)/basis/mlton/mlton.sml 74.11-74.17 *)
type MLton.ProcEnv.gid = Posix.SysDB.gid (* @ $(SML_LIB)/basis/mlton/proc-env.sml 12.12-12.14 *)
val MLton.ProcEnv.setenv: {name: string, value: string} -> unit (* @ $(SML_LIB)/basis/mlton/proc-env.sml 14.11-14.16 *)
val MLton.ProcEnv.setgroups: Posix.SysDB.gid list -> unit (* @ $(SML_LIB)/basis/mlton/proc-env.sml 23.11-23.19 *)
structure MLton.Process: MLTON_PROCESS where type ('a, 'b) Child.t = ('a, 'b) MLton.Process.Child.t where type ('a, 'b) Param.t = ('a, 'b) MLton.Process.Param.t where type any = MLton.Process.any where type chain = MLton.Process.chain where type input = MLton.Process.input where type none = MLton.Process.none where type output = MLton.Process.output where type pid = Posix.TTY.pid where type ('a, 'b, 'c) t = ('a, 'b, 'c) MLton.Process.t (* @ $(SML_LIB)/basis/mlton/mlton.sml 75.11-75.17 *)
type MLton.Process.any = MLton.Process.any (* @ $(SML_LIB)/basis/mlton/process.sml 37.12-37.14 *)
type MLton.Process.chain = MLton.Process.chain (* @ $(SML_LIB)/basis/mlton/process.sml 36.12-36.16 *)
type MLton.Process.input = MLton.Process.input (* @ $(SML_LIB)/basis/mlton/process.sml 32.12-32.16 *)
type MLton.Process.none = MLton.Process.none (* @ $(SML_LIB)/basis/mlton/process.sml 35.12-35.15 *)
type MLton.Process.output = MLton.Process.output (* @ $(SML_LIB)/basis/mlton/process.sml 33.12-33.17 *)
type MLton.Process.pid = Posix.TTY.pid (* @ $(SML_LIB)/basis/mlton/process.sml 27.12-27.14 *)
type ('a, 'b, 'c) MLton.Process.t = ('a, 'b, 'c) MLton.Process.t (* @ $(SML_LIB)/basis/mlton/process.sml 182.43-182.43 *)
exn MLton.Process.DoublyRedirected: exn (* @ $(SML_LIB)/basis/mlton/process.sml 30.17-30.32 *)
exn MLton.Process.MisuseOfForget: exn (* @ $(SML_LIB)/basis/mlton/process.sml 29.17-29.30 *)
val MLton.Process.create: {args: string list, env: string list option, path: string, stderr: ('a, MLton.Process.output) MLton.Process.Param.t, stdin: ('b, MLton.Process.input) MLton.Process.Param.t, stdout: ('c, MLton.Process.output) MLton.Process.Param.t} -> ('b, 'c, 'a) MLton.Process.t (* @ $(SML_LIB)/basis/mlton/process.sml 381.11-381.16 *)
val MLton.Process.getStderr: ('a, 'b, 'c) MLton.Process.t -> ('c, MLton.Process.input) MLton.Process.Child.t (* @ $(SML_LIB)/basis/mlton/process.sml 196.14-196.22 *)
val MLton.Process.getStdin: ('a, 'b, 'c) MLton.Process.t -> ('a, MLton.Process.output) MLton.Process.Child.t (* @ $(SML_LIB)/basis/mlton/process.sml 197.14-197.21 *)
val MLton.Process.getStdout: ('a, 'b, 'c) MLton.Process.t -> ('b, MLton.Process.input) MLton.Process.Child.t (* @ $(SML_LIB)/basis/mlton/process.sml 198.14-198.22 *)
val MLton.Process.kill: ('a, 'b, 'c) MLton.Process.t * Unix.signal -> unit (* @ $(SML_LIB)/basis/mlton/process.sml 274.11-274.14 *)
val MLton.Process.reap: ('a, 'b, 'c) MLton.Process.t -> Unix.exit_status (* @ $(SML_LIB)/basis/mlton/process.sml 248.11-248.14 *)
val MLton.Process.spawn: {args: string list, path: string} -> Posix.TTY.pid (* @ $(SML_LIB)/basis/mlton/process.sml 427.11-427.15 *)
val MLton.Process.spawne: {args: string list, env: string list, path: string} -> Posix.TTY.pid (* @ $(SML_LIB)/basis/mlton/process.sml 408.11-408.16 *)
val MLton.Process.spawnp: {args: string list, file: string} -> Posix.TTY.pid (* @ $(SML_LIB)/basis/mlton/process.sml 432.11-432.16 *)
structure MLton.Process.Child:
   sig
      type ('a, 'b) t = ('a, 'b) MLton.Process.Child.t
      val binIn: (BinIO.instream, MLton.Process.input) MLton.Process.Child.t -> BinIO.instream
      val binOut: (BinIO.outstream, MLton.Process.output) MLton.Process.Child.t -> BinIO.outstream
      val fd: (Posix.TTY.file_desc, 'a) MLton.Process.Child.t -> Posix.TTY.file_desc
      val remember: (MLton.Process.any, 'a) MLton.Process.Child.t -> ('b, 'a) MLton.Process.Child.t
      val textIn: (TextIO.instream, MLton.Process.input) MLton.Process.Child.t -> TextIO.instream
      val textOut: (TextIO.outstream, MLton.Process.output) MLton.Process.Child.t -> TextIO.outstream
   end
   (* @ $(SML_LIB)/basis/mlton/process.sml 48.17-48.21 *)
type ('a, 'b) MLton.Process.Child.t = ('a, 'b) MLton.Process.Child.t (* @ $(SML_LIB)/basis/mlton/process.sml 54.31-54.31 *)
val MLton.Process.Child.binIn: (BinIO.instream, MLton.Process.input) MLton.Process.Child.t -> BinIO.instream (* @ $(SML_LIB)/basis/mlton/process.sml 80.20-80.24 *)
val MLton.Process.Child.binOut: (BinIO.outstream, MLton.Process.output) MLton.Process.Child.t -> BinIO.outstream (* @ $(SML_LIB)/basis/mlton/process.sml 81.20-81.25 *)
val MLton.Process.Child.fd: (Posix.TTY.file_desc, 'a) MLton.Process.Child.t -> Posix.TTY.file_desc (* @ $(SML_LIB)/basis/mlton/process.sml 86.17-86.18 *)
val MLton.Process.Child.remember: (MLton.Process.any, 'a) MLton.Process.Child.t -> ('b, 'a) MLton.Process.Child.t (* @ $(SML_LIB)/basis/mlton/process.sml 59.17-59.24 *)
val MLton.Process.Child.textIn: (TextIO.instream, MLton.Process.input) MLton.Process.Child.t -> TextIO.instream (* @ $(SML_LIB)/basis/mlton/process.sml 82.20-82.25 *)
val MLton.Process.Child.textOut: (TextIO.outstream, MLton.Process.output) MLton.Process.Child.t -> TextIO.outstream (* @ $(SML_LIB)/basis/mlton/process.sml 83.20-83.26 *)
structure MLton.Process.Param:
   sig
      type ('a, 'b) t = ('a, 'b) MLton.Process.Param.t
      val child: (MLton.Process.chain, 'a) MLton.Process.Child.t -> (MLton.Process.none, 'a) MLton.Process.Param.t
      val fd: Posix.TTY.file_desc -> (MLton.Process.none, 'a) MLton.Process.Param.t
      val file: string -> (MLton.Process.none, 'a) MLton.Process.Param.t
      val forget: ('a, 'b) MLton.Process.Param.t -> (MLton.Process.any, 'b) MLton.Process.Param.t
      val null: (MLton.Process.none, 'a) MLton.Process.Param.t
      val pipe: ('a, 'b) MLton.Process.Param.t
      val self: (MLton.Process.none, 'a) MLton.Process.Param.t
   end
   (* @ $(SML_LIB)/basis/mlton/process.sml 102.17-102.21 *)
type ('a, 'b) MLton.Process.Param.t = ('a, 'b) MLton.Process.Param.t (* @ $(SML_LIB)/basis/mlton/process.sml 104.35-104.35 *)
val MLton.Process.Param.child: (MLton.Process.chain, 'a) MLton.Process.Child.t -> (MLton.Process.none, 'a) MLton.Process.Param.t (* @ $(SML_LIB)/basis/mlton/process.sml 129.17-129.21 *)
val MLton.Process.Param.fd: Posix.TTY.file_desc -> (MLton.Process.none, 'a) MLton.Process.Param.t (* @ $(SML_LIB)/basis/mlton/process.sml 127.17-127.18 *)
val MLton.Process.Param.file: string -> (MLton.Process.none, 'a) MLton.Process.Param.t (* @ $(SML_LIB)/basis/mlton/process.sml 126.17-126.20 *)
val MLton.Process.Param.forget: ('a, 'b) MLton.Process.Param.t -> (MLton.Process.any, 'b) MLton.Process.Param.t (* @ $(SML_LIB)/basis/mlton/process.sml 113.17-113.22 *)
val MLton.Process.Param.null: (MLton.Process.none, 'a) MLton.Process.Param.t (* @ $(SML_LIB)/basis/mlton/process.sml 123.20-123.23 *)
val MLton.Process.Param.pipe: ('a, 'b) MLton.Process.Param.t (* @ $(SML_LIB)/basis/mlton/process.sml 119.17-119.20 *)
val MLton.Process.Param.self: (MLton.Process.none, 'a) MLton.Process.Param.t (* @ $(SML_LIB)/basis/mlton/process.sml 125.17-125.20 *)
structure MLton.Profile: MLTON_PROFILE where type Data.t = MLton.Profile.Data.t (* @ $(SML_LIB)/basis/mlton/mlton.sml 77.11-77.17 *)
val MLton.Profile.isOn: bool (* @ $(SML_LIB)/basis/mlton/profile.sml 15.5-15.8 *)
val MLton.Profile.withData: MLton.Profile.Data.t * (unit -> 'a) -> 'a (* @ $(SML_LIB)/basis/mlton/profile.sml 100.5-100.12 *)
structure MLton.Profile.Data:
   sig
      type t = MLton.Profile.Data.t
      val equals: MLton.Profile.Data.t * MLton.Profile.Data.t -> bool
      val free: MLton.Profile.Data.t -> unit
      val malloc: unit -> MLton.Profile.Data.t
      val write: MLton.Profile.Data.t * string -> unit
   end
   (* @ $(SML_LIB)/basis/mlton/profile.sml 17.11-17.14 *)
type MLton.Profile.Data.t = MLton.Profile.Data.t (* @ $(SML_LIB)/basis/mlton/profile.sml 19.16-19.16 *)
val MLton.Profile.Data.equals: MLton.Profile.Data.t * MLton.Profile.Data.t -> bool (* @ $(SML_LIB)/basis/mlton/profile.sml 32.11-32.16 *)
val MLton.Profile.Data.free: MLton.Profile.Data.t -> unit (* @ $(SML_LIB)/basis/mlton/profile.sml 35.11-35.14 *)
val MLton.Profile.Data.malloc: unit -> MLton.Profile.Data.t (* @ $(SML_LIB)/basis/mlton/profile.sml 56.11-56.16 *)
val MLton.Profile.Data.write: MLton.Profile.Data.t * string -> unit (* @ $(SML_LIB)/basis/mlton/profile.sml 68.11-68.15 *)
structure MLton.Random: MLTON_RANDOM (* @ $(SML_LIB)/basis/mlton/mlton.sml 78.11-78.16 *)
val MLton.Random.alphaNumChar: unit -> char (* @ $(SML_LIB)/basis/mlton/random.sml 87.14-87.25 *)
val MLton.Random.alphaNumString: int -> string (* @ $(SML_LIB)/basis/mlton/random.sml 102.11-102.24 *)
val MLton.Random.rand: unit -> word (* @ $(SML_LIB)/basis/mlton/random.sml 58.14-58.17 *)
val MLton.Random.seed: unit -> word option (* @ $(SML_LIB)/basis/mlton/random.sml 49.14-49.17 *)
val MLton.Random.srand: word -> unit (* @ $(SML_LIB)/basis/mlton/random.sml 66.14-66.18 *)
val MLton.Random.useed: unit -> word option (* @ $(SML_LIB)/basis/mlton/random.sml 50.14-50.18 *)
structure MLton.Real: MLTON_REAL where type t = real (* @ $(SML_LIB)/basis/mlton/mlton.sml 79.11-79.14 *)
type MLton.Real.t = real (* @ $(SML_LIB)/basis/mlton/mlton.sml 82.12-82.12 *)
val MLton.Real.fromLargeWord: LargeWord.word -> real (* @ $(SML_LIB)/basis/real/real.sml 977.14-977.26 *)
val MLton.Real.fromWord: word -> real (* @ $(SML_LIB)/basis/real/real.sml 966.14-966.21 *)
val MLton.Real.toLargeWord: IEEEReal.rounding_mode -> real -> LargeWord.word (* @ $(SML_LIB)/basis/real/real.sml 999.14-999.24 *)
val MLton.Real.toWord: IEEEReal.rounding_mode -> real -> word (* @ $(SML_LIB)/basis/real/real.sml 988.14-988.19 *)
structure MLton.Real32:
   sig
      type t = Real32.real
      val castFromWord: word -> Real32.real
      val castToWord: Real32.real -> word
      val fromLargeWord: LargeWord.word -> Real32.real
      val fromWord: word -> Real32.real
      val toLargeWord: IEEEReal.rounding_mode -> Real32.real -> LargeWord.word
      val toWord: IEEEReal.rounding_mode -> Real32.real -> word
   end
   (* @ $(SML_LIB)/basis/mlton/mlton.sml 84.11-84.16 *)
type MLton.Real32.t = Real32.real (* @ $(SML_LIB)/basis/mlton/mlton.sml 87.12-87.12 *)
val MLton.Real32.castFromWord: word -> Real32.real (* @ $(SML_LIB)/basis/primitive/prim-pack-real.sml 20.11-20.22 *)
val MLton.Real32.castToWord: Real32.real -> word (* @ $(SML_LIB)/basis/primitive/prim-pack-real.sml 21.11-21.20 *)
val MLton.Real32.fromLargeWord: LargeWord.word -> Real32.real (* @ $(SML_LIB)/basis/real/real.sml 977.14-977.26 *)
val MLton.Real32.fromWord: word -> Real32.real (* @ $(SML_LIB)/basis/real/real.sml 966.14-966.21 *)
val MLton.Real32.toLargeWord: IEEEReal.rounding_mode -> Real32.real -> LargeWord.word (* @ $(SML_LIB)/basis/real/real.sml 999.14-999.24 *)
val MLton.Real32.toWord: IEEEReal.rounding_mode -> Real32.real -> word (* @ $(SML_LIB)/basis/real/real.sml 988.14-988.19 *)
structure MLton.Real64:
   sig
      type t = real
      val castFromWord: LargeWord.word -> real
      val castToWord: real -> LargeWord.word
      val fromLargeWord: LargeWord.word -> real
      val fromWord: word -> real
      val toLargeWord: IEEEReal.rounding_mode -> real -> LargeWord.word
      val toWord: IEEEReal.rounding_mode -> real -> word
   end
   (* @ $(SML_LIB)/basis/mlton/mlton.sml 90.11-90.16 *)
type MLton.Real64.t = real (* @ $(SML_LIB)/basis/mlton/mlton.sml 93.12-93.12 *)
val MLton.Real64.castFromWord: LargeWord.word -> real (* @ $(SML_LIB)/basis/primitive/prim-pack-real.sml 29.11-29.22 *)
val MLton.Real64.castToWord: real -> LargeWord.word (* @ $(SML_LIB)/basis/primitive/prim-pack-real.sml 30.11-30.20 *)
val MLton.Real64.fromLargeWord: LargeWord.word -> real (* @ $(SML_LIB)/basis/real/real.sml 977.14-977.26 *)
val MLton.Real64.fromWord: word -> real (* @ $(SML_LIB)/basis/real/real.sml 966.14-966.21 *)
val MLton.Real64.toLargeWord: IEEEReal.rounding_mode -> real -> LargeWord.word (* @ $(SML_LIB)/basis/real/real.sml 999.14-999.24 *)
val MLton.Real64.toWord: IEEEReal.rounding_mode -> real -> word (* @ $(SML_LIB)/basis/real/real.sml 988.14-988.19 *)
structure MLton.Rlimit: MLTON_RLIMIT where type RLim.t = MLton.Rlimit.RLim.t where type t = MLton.Rlimit.t (* @ $(SML_LIB)/basis/mlton/mlton.sml 96.11-96.16 *)
type MLton.Rlimit.t = MLton.Rlimit.t (* @ $(SML_LIB)/basis/mlton/rlimit.sml 13.12-13.12 *)
val MLton.Rlimit.coreFileSize: MLton.Rlimit.t (* @ $(SML_LIB)/basis/mlton/rlimit.sml 30.11-30.22 *)
val MLton.Rlimit.cpuTime: MLton.Rlimit.t (* @ $(SML_LIB)/basis/mlton/rlimit.sml 31.11-31.17 *)
val MLton.Rlimit.dataSize: MLton.Rlimit.t (* @ $(SML_LIB)/basis/mlton/rlimit.sml 32.11-32.18 *)
val MLton.Rlimit.fileSize: MLton.Rlimit.t (* @ $(SML_LIB)/basis/mlton/rlimit.sml 33.11-33.18 *)
val MLton.Rlimit.get: MLton.Rlimit.t -> {hard: MLton.Rlimit.RLim.t, soft: MLton.Rlimit.RLim.t} (* @ $(SML_LIB)/basis/mlton/rlimit.sml 15.11-15.13 *)
val MLton.Rlimit.infinity: MLton.Rlimit.RLim.t (* @ $(SML_LIB)/basis/mlton/rlimit.sml 28.11-28.18 *)
val MLton.Rlimit.lockedInMemorySize: MLton.Rlimit.t (* @ $(SML_LIB)/basis/mlton/rlimit.sml 39.11-39.28 *)
val MLton.Rlimit.numFiles: MLton.Rlimit.t (* @ $(SML_LIB)/basis/mlton/rlimit.sml 34.11-34.18 *)
val MLton.Rlimit.numProcesses: MLton.Rlimit.t (* @ $(SML_LIB)/basis/mlton/rlimit.sml 40.11-40.22 *)
val MLton.Rlimit.residentSetSize: MLton.Rlimit.t (* @ $(SML_LIB)/basis/mlton/rlimit.sml 41.11-41.25 *)
val MLton.Rlimit.set: MLton.Rlimit.t * {hard: MLton.Rlimit.RLim.t, soft: MLton.Rlimit.RLim.t} -> unit (* @ $(SML_LIB)/basis/mlton/rlimit.sml 23.11-23.13 *)
val MLton.Rlimit.stackSize: MLton.Rlimit.t (* @ $(SML_LIB)/basis/mlton/rlimit.sml 35.11-35.19 *)
val MLton.Rlimit.virtualMemorySize: MLton.Rlimit.t (* @ $(SML_LIB)/basis/mlton/rlimit.sml 36.11-36.27 *)
structure MLton.Rlimit.RLim:
   sig
      type t = MLton.Rlimit.RLim.t
      val castFromSysWord: LargeWord.word -> MLton.Rlimit.RLim.t
      val castToSysWord: MLton.Rlimit.RLim.t -> LargeWord.word
   end
   (* @ $(SML_LIB)/basis/mlton/rlimit.sml 12.17-12.20 *)
type MLton.Rlimit.RLim.t = MLton.Rlimit.RLim.t (* @ /home/matthew/devel/mlton/mlton.shadow.git-wt/build/lib/mlton/targets/self/sml/c-types.sml 86.44-86.44 *)
val MLton.Rlimit.RLim.castFromSysWord: LargeWord.word -> MLton.Rlimit.RLim.t (* @ $(SML_LIB)/basis/integer/num1.sml 826.14-826.28 *)
val MLton.Rlimit.RLim.castToSysWord: MLton.Rlimit.RLim.t -> LargeWord.word (* @ $(SML_LIB)/basis/integer/num1.sml 837.14-837.26 *)
structure MLton.Rusage: MLTON_RUSAGE (* @ $(SML_LIB)/basis/mlton/mlton.sml 97.11-97.16 *)
type MLton.Rusage.t = {stime: Time.time, utime: Time.time} (* @ $(SML_LIB)/basis/mlton/rusage.sml 13.12-13.12 *)
val MLton.Rusage.measureGC: bool -> unit (* @ $(SML_LIB)/basis/mlton/rusage.sml 31.11-31.19 *)
val MLton.Rusage.rusage: unit -> {children: {stime: Time.time, utime: Time.time}, gc: {stime: Time.time, utime: Time.time}, self: {stime: Time.time, utime: Time.time}} (* @ $(SML_LIB)/basis/mlton/rusage.sml 33.11-33.16 *)
structure MLton.Signal: MLTON_SIGNAL where type Handler.t = MLton.Signal.Handler.t where type Mask.t = MLton.Signal.Mask.t where type t = Unix.signal (* @ $(SML_LIB)/basis/mlton/mlton.sml 98.11-98.16 *)
type MLton.Signal.signal = Unix.signal (* @ $(SML_LIB)/basis/posix/signal.sml 14.12-14.17 *)
type MLton.Signal.t = Unix.signal (* @ $(SML_LIB)/basis/mlton/signal.sml 19.6-19.6 *)
val MLton.Signal.getHandler: Unix.signal -> MLton.Signal.Handler.t (* @ $(SML_LIB)/basis/mlton/signal.sml 108.6-108.15 *)
val MLton.Signal.handled: unit -> MLton.Signal.Mask.t (* @ $(SML_LIB)/basis/mlton/signal.sml 125.5-125.11 *)
val MLton.Signal.prof: Unix.signal (* @ $(SML_LIB)/basis/posix/signal.sml 28.11-28.14 *)
val MLton.Signal.restart: bool ref (* @ $(SML_LIB)/basis/mlton/signal.sml 17.5-17.11 *)
val MLton.Signal.setHandler: Unix.signal * MLton.Signal.Handler.t -> unit (* @ $(SML_LIB)/basis/mlton/signal.sml 199.5-199.14 *)
val MLton.Signal.suspend: MLton.Signal.Mask.t -> unit (* @ $(SML_LIB)/basis/mlton/signal.sml 217.5-217.11 *)
val MLton.Signal.vtalrm: Unix.signal (* @ $(SML_LIB)/basis/posix/signal.sml 41.11-41.16 *)
structure MLton.Signal.Handler:
   sig
      type t = MLton.Signal.Handler.t
      val default: MLton.Signal.Handler.t
      val handler: (MLton.Thread.Runnable.t -> MLton.Thread.Runnable.t) -> MLton.Signal.Handler.t
      val ignore: MLton.Signal.Handler.t
      val isDefault: MLton.Signal.Handler.t -> bool
      val isIgnore: MLton.Signal.Handler.t -> bool
      val simple: (unit -> unit) -> MLton.Signal.Handler.t
   end
   (* @ $(SML_LIB)/basis/mlton/signal.sml 133.11-133.17 *)
type MLton.Signal.Handler.t = MLton.Signal.Handler.t (* @ $(SML_LIB)/basis/mlton/signal.sml 88.16-88.16 *)
val MLton.Signal.Handler.default: MLton.Signal.Handler.t (* @ $(SML_LIB)/basis/mlton/signal.sml 137.11-137.17 *)
val MLton.Signal.Handler.handler: (MLton.Thread.Runnable.t -> MLton.Thread.Runnable.t) -> MLton.Signal.Handler.t (* @ $(SML_LIB)/basis/mlton/signal.sml 143.11-143.17 *)
val MLton.Signal.Handler.ignore: MLton.Signal.Handler.t (* @ $(SML_LIB)/basis/mlton/signal.sml 138.11-138.16 *)
val MLton.Signal.Handler.isDefault: MLton.Signal.Handler.t -> bool (* @ $(SML_LIB)/basis/mlton/signal.sml 140.11-140.19 *)
val MLton.Signal.Handler.isIgnore: MLton.Signal.Handler.t -> bool (* @ $(SML_LIB)/basis/mlton/signal.sml 141.11-141.18 *)
val MLton.Signal.Handler.simple: (unit -> unit) -> MLton.Signal.Handler.t (* @ $(SML_LIB)/basis/mlton/signal.sml 196.11-196.16 *)
structure MLton.Signal.Mask:
   sig
      type t = MLton.Signal.Mask.t
      val all: MLton.Signal.Mask.t
      val allBut: Unix.signal list -> MLton.Signal.Mask.t
      val block: MLton.Signal.Mask.t -> unit
      val getBlocked: unit -> MLton.Signal.Mask.t
      val isMember: MLton.Signal.Mask.t * Unix.signal -> bool
      val none: MLton.Signal.Mask.t
      val setBlocked: MLton.Signal.Mask.t -> unit
      val some: Unix.signal list -> MLton.Signal.Mask.t
      val unblock: MLton.Signal.Mask.t -> unit
   end
   (* @ $(SML_LIB)/basis/mlton/signal.sml 30.11-30.14 *)
type MLton.Signal.Mask.t = MLton.Signal.Mask.t (* @ $(SML_LIB)/basis/mlton/signal.sml 42.12-42.12 *)
val MLton.Signal.Mask.all: MLton.Signal.Mask.t (* @ $(SML_LIB)/basis/mlton/signal.sml 54.11-54.13 *)
val MLton.Signal.Mask.allBut: Unix.signal list -> MLton.Signal.Mask.t (* @ $(SML_LIB)/basis/mlton/signal.sml 44.11-44.16 *)
val MLton.Signal.Mask.block: MLton.Signal.Mask.t -> unit (* @ $(SML_LIB)/basis/mlton/signal.sml 79.14-79.18 *)
val MLton.Signal.Mask.getBlocked: unit -> MLton.Signal.Mask.t (* @ $(SML_LIB)/basis/mlton/signal.sml 82.14-82.23 *)
val MLton.Signal.Mask.isMember: MLton.Signal.Mask.t * Unix.signal -> bool (* @ $(SML_LIB)/basis/mlton/signal.sml 67.11-67.18 *)
val MLton.Signal.Mask.none: MLton.Signal.Mask.t (* @ $(SML_LIB)/basis/mlton/signal.sml 65.11-65.14 *)
val MLton.Signal.Mask.setBlocked: MLton.Signal.Mask.t -> unit (* @ $(SML_LIB)/basis/mlton/signal.sml 81.14-81.23 *)
val MLton.Signal.Mask.some: Unix.signal list -> MLton.Signal.Mask.t (* @ $(SML_LIB)/basis/mlton/signal.sml 55.11-55.14 *)
val MLton.Signal.Mask.unblock: MLton.Signal.Mask.t -> unit (* @ $(SML_LIB)/basis/mlton/signal.sml 80.14-80.20 *)
structure MLton.Syslog: MLTON_SYSLOG where type facility = MLton.Syslog.facility where type loglevel = MLton.Syslog.loglevel where type openflag = MLton.Syslog.openflag (* @ $(SML_LIB)/basis/mlton/mlton.sml 99.11-99.16 *)
type MLton.Syslog.facility = MLton.Syslog.facility (* @ $(SML_LIB)/basis/mlton/syslog.sml 34.6-34.13 *)
type MLton.Syslog.loglevel = MLton.Syslog.loglevel (* @ $(SML_LIB)/basis/mlton/syslog.sml 61.6-61.13 *)
type MLton.Syslog.openflag = MLton.Syslog.openflag (* @ $(SML_LIB)/basis/mlton/syslog.sml 19.6-19.13 *)
val MLton.Syslog.ALERT: MLton.Syslog.loglevel (* @ $(SML_LIB)/basis/mlton/syslog.sml 66.8-66.12 *)
val MLton.Syslog.AUTHPRIV: MLton.Syslog.facility (* @ $(SML_LIB)/basis/mlton/syslog.sml 39.8-39.15 *)
val MLton.Syslog.CONS: MLton.Syslog.openflag (* @ $(SML_LIB)/basis/mlton/syslog.sml 24.8-24.11 *)
val MLton.Syslog.CRIT: MLton.Syslog.loglevel (* @ $(SML_LIB)/basis/mlton/syslog.sml 67.8-67.11 *)
val MLton.Syslog.CRON: MLton.Syslog.facility (* @ $(SML_LIB)/basis/mlton/syslog.sml 40.8-40.11 *)
val MLton.Syslog.DAEMON: MLton.Syslog.facility (* @ $(SML_LIB)/basis/mlton/syslog.sml 41.8-41.13 *)
val MLton.Syslog.DEBUG: MLton.Syslog.loglevel (* @ $(SML_LIB)/basis/mlton/syslog.sml 68.8-68.12 *)
val MLton.Syslog.EMERG: MLton.Syslog.loglevel (* @ $(SML_LIB)/basis/mlton/syslog.sml 69.8-69.12 *)
val MLton.Syslog.ERR: MLton.Syslog.loglevel (* @ $(SML_LIB)/basis/mlton/syslog.sml 70.8-70.10 *)
val MLton.Syslog.INFO: MLton.Syslog.loglevel (* @ $(SML_LIB)/basis/mlton/syslog.sml 71.8-71.11 *)
val MLton.Syslog.KERN: MLton.Syslog.facility (* @ $(SML_LIB)/basis/mlton/syslog.sml 42.8-42.11 *)
val MLton.Syslog.LOCAL0: MLton.Syslog.facility (* @ $(SML_LIB)/basis/mlton/syslog.sml 43.8-43.13 *)
val MLton.Syslog.LOCAL1: MLton.Syslog.facility (* @ $(SML_LIB)/basis/mlton/syslog.sml 44.8-44.13 *)
val MLton.Syslog.LOCAL2: MLton.Syslog.facility (* @ $(SML_LIB)/basis/mlton/syslog.sml 45.8-45.13 *)
val MLton.Syslog.LOCAL3: MLton.Syslog.facility (* @ $(SML_LIB)/basis/mlton/syslog.sml 46.8-46.13 *)
val MLton.Syslog.LOCAL4: MLton.Syslog.facility (* @ $(SML_LIB)/basis/mlton/syslog.sml 47.8-47.13 *)
val MLton.Syslog.LOCAL5: MLton.Syslog.facility (* @ $(SML_LIB)/basis/mlton/syslog.sml 48.8-48.13 *)
val MLton.Syslog.LOCAL6: MLton.Syslog.facility (* @ $(SML_LIB)/basis/mlton/syslog.sml 49.8-49.13 *)
val MLton.Syslog.LOCAL7: MLton.Syslog.facility (* @ $(SML_LIB)/basis/mlton/syslog.sml 50.8-50.13 *)
val MLton.Syslog.LPR: MLton.Syslog.facility (* @ $(SML_LIB)/basis/mlton/syslog.sml 51.8-51.10 *)
val MLton.Syslog.MAIL: MLton.Syslog.facility (* @ $(SML_LIB)/basis/mlton/syslog.sml 52.8-52.11 *)
val MLton.Syslog.NDELAY: MLton.Syslog.openflag (* @ $(SML_LIB)/basis/mlton/syslog.sml 25.8-25.13 *)
val MLton.Syslog.NEWS: MLton.Syslog.facility (* @ $(SML_LIB)/basis/mlton/syslog.sml 53.8-53.11 *)
val MLton.Syslog.NOTICE: MLton.Syslog.loglevel (* @ $(SML_LIB)/basis/mlton/syslog.sml 72.8-72.13 *)
val MLton.Syslog.NOWAIT: MLton.Syslog.openflag (* @ $(SML_LIB)/basis/mlton/syslog.sml 26.8-26.13 *)
val MLton.Syslog.ODELAY: MLton.Syslog.openflag (* @ $(SML_LIB)/basis/mlton/syslog.sml 27.8-27.13 *)
val MLton.Syslog.PERROR: MLton.Syslog.openflag (* @ $(SML_LIB)/basis/mlton/syslog.sml 29.8-29.13 *)
val MLton.Syslog.PID: MLton.Syslog.openflag (* @ $(SML_LIB)/basis/mlton/syslog.sml 31.8-31.10 *)
val MLton.Syslog.SYSLOG: MLton.Syslog.facility (* @ $(SML_LIB)/basis/mlton/syslog.sml 55.8-55.13 *)
val MLton.Syslog.USER: MLton.Syslog.facility (* @ $(SML_LIB)/basis/mlton/syslog.sml 57.8-57.11 *)
val MLton.Syslog.UUCP: MLton.Syslog.facility (* @ $(SML_LIB)/basis/mlton/syslog.sml 58.8-58.11 *)
val MLton.Syslog.WARNING: MLton.Syslog.loglevel (* @ $(SML_LIB)/basis/mlton/syslog.sml 73.8-73.14 *)
val MLton.Syslog.closelog: unit -> unit (* @ $(SML_LIB)/basis/mlton/syslog.sml 83.5-83.12 *)
val MLton.Syslog.log: MLton.Syslog.loglevel * string -> unit (* @ $(SML_LIB)/basis/mlton/syslog.sml 86.5-86.7 *)
val MLton.Syslog.openlog: string * MLton.Syslog.openflag list * MLton.Syslog.facility -> unit (* @ $(SML_LIB)/basis/mlton/syslog.sml 76.5-76.11 *)
structure MLton.TextIO: MLTON_TEXT_IO where type instream = TextIO.instream where type outstream = TextIO.outstream (* @ $(SML_LIB)/basis/mlton/mlton.sml 100.11-100.16 *)
type MLton.TextIO.instream = TextIO.instream (* @ $(SML_LIB)/basis/io/imperative-io.fun 213.10-213.17 *)
type MLton.TextIO.outstream = TextIO.outstream (* @ $(SML_LIB)/basis/io/imperative-io.fun 100.6-100.14 *)
val MLton.TextIO.inFd: TextIO.instream -> Posix.TTY.file_desc (* @ $(SML_LIB)/basis/io/imperative-io.fun 248.5-248.8 *)
val MLton.TextIO.mkstemp: string -> string * TextIO.outstream (* @ $(SML_LIB)/basis/mlton/io.fun 35.5-35.11 *)
val MLton.TextIO.mkstemps: {prefix: string, suffix: string} -> string * TextIO.outstream (* @ $(SML_LIB)/basis/mlton/io.fun 14.5-14.12 *)
val MLton.TextIO.newIn: Posix.TTY.file_desc * string -> TextIO.instream (* @ $(SML_LIB)/basis/io/imperative-io.fun 737.5-737.9 *)
val MLton.TextIO.newOut: Posix.TTY.file_desc * string -> TextIO.outstream (* @ $(SML_LIB)/basis/io/imperative-io.fun 195.5-195.10 *)
val MLton.TextIO.outFd: TextIO.outstream -> Posix.TTY.file_desc (* @ $(SML_LIB)/basis/io/imperative-io.fun 198.5-198.9 *)
val MLton.TextIO.tempPrefix: string -> string (* @ $(SML_LIB)/basis/mlton/io.fun 37.5-37.14 *)
structure MLton.Thread: MLTON_THREAD where type AtomicState.t = MLton.Thread.AtomicState.t where type Runnable.t = MLton.Thread.Runnable.t where type 'a t = 'a MLton.Thread.t (* @ $(SML_LIB)/basis/mlton/mlton.sml 101.11-101.16 *)
type 'a MLton.Thread.t = 'a MLton.Thread.t (* @ $(SML_LIB)/basis/mlton/thread.sml 49.13-49.13 *)
val MLton.Thread.atomicBegin: unit -> unit (* @ $(SML_LIB)/basis/mlton/thread.sml 31.8-31.18 *)
val MLton.Thread.atomicEnd: unit -> unit (* @ $(SML_LIB)/basis/mlton/thread.sml 32.8-32.16 *)
val MLton.Thread.atomicState: unit -> MLton.Thread.AtomicState.t (* @ $(SML_LIB)/basis/mlton/thread.sml 33.8-33.18 *)
val MLton.Thread.atomicSwitch: ('a MLton.Thread.t -> MLton.Thread.Runnable.t) -> 'a (* @ $(SML_LIB)/basis/mlton/thread.sml 105.11-105.22 *)
val MLton.Thread.atomically: (unit -> 'a) -> 'a (* @ $(SML_LIB)/basis/mlton/thread.sml 39.5-39.14 *)
val MLton.Thread.new: ('a -> unit) -> 'a MLton.Thread.t (* @ $(SML_LIB)/basis/mlton/thread.sml 71.5-71.7 *)
val MLton.Thread.prepare: 'a MLton.Thread.t * 'a -> MLton.Thread.Runnable.t (* @ $(SML_LIB)/basis/mlton/thread.sml 68.5-68.11 *)
val MLton.Thread.prepend: 'a MLton.Thread.t * ('b -> 'a) -> 'b MLton.Thread.t (* @ $(SML_LIB)/basis/mlton/thread.sml 56.5-56.11 *)
val MLton.Thread.switch: ('a MLton.Thread.t -> MLton.Thread.Runnable.t) -> 'a (* @ $(SML_LIB)/basis/mlton/thread.sml 140.8-140.13 *)
structure MLton.Thread.AtomicState:
   sig
      datatype t = Atomic of int | NonAtomic (* = datatype MLton.Thread.AtomicState.t *)
   end
   (* @ $(SML_LIB)/basis/mlton/thread.sml 23.11-23.21 *)
datatype MLton.Thread.AtomicState.t = Atomic of int | NonAtomic (* = datatype MLton.Thread.AtomicState.t *) (* @ $(SML_LIB)/basis/mlton/thread.sml 25.16-25.16 *)
con MLton.Thread.AtomicState.Atomic: int -> MLton.Thread.AtomicState.t (* @ $(SML_LIB)/basis/mlton/thread.sml 25.32-25.37 *)
con MLton.Thread.AtomicState.NonAtomic: MLton.Thread.AtomicState.t (* @ $(SML_LIB)/basis/mlton/thread.sml 25.20-25.28 *)
structure MLton.Thread.Runnable:
   sig
      type t = MLton.Thread.Runnable.t
   end
   (* @ $(SML_LIB)/basis/mlton/thread.sml 51.11-51.18 *)
type MLton.Thread.Runnable.t = MLton.Thread.Runnable.t (* @ $(SML_LIB)/basis/mlton/thread.sml 53.12-53.12 *)
structure MLton.Vector: MLTON_VECTOR (* @ $(SML_LIB)/basis/mlton/mlton.sml 102.11-102.16 *)
val MLton.Vector.create: int -> {done: unit -> 'a vector, sub: int -> 'a, update: int * 'a -> unit} (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 99.11-99.16 *)
val MLton.Vector.unfoldi: int * 'a * (int * 'a -> 'b * 'a) -> 'b vector * 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 108.11-108.17 *)
structure MLton.Weak: MLTON_WEAK where type 'a t = 'a MLton.Weak.t (* @ $(SML_LIB)/basis/mlton/mlton.sml 103.11-103.14 *)
type 'a MLton.Weak.t = 'a MLton.Weak.t (* @ $(SML_LIB)/basis/mlton/weak.sml 12.15-12.15 *)
val MLton.Weak.get: 'a MLton.Weak.t -> 'a option (* @ $(SML_LIB)/basis/mlton/weak.sml 16.11-16.13 *)
val MLton.Weak.new: 'a -> 'a MLton.Weak.t (* @ $(SML_LIB)/basis/mlton/weak.sml 14.11-14.13 *)
structure MLton.Word: MLTON_WORD where type t = word (* @ $(SML_LIB)/basis/mlton/mlton.sml 105.11-105.14 *)
type MLton.Word.t = word (* @ $(SML_LIB)/basis/mlton/mlton.sml 108.12-108.12 *)
val MLton.Word.bswap: word -> word (* @ $(SML_LIB)/basis/integer/word.sml 52.8-52.12 *)
val MLton.Word.rol: word * word -> word (* @ $(SML_LIB)/basis/integer/word.sml 31.5-31.7 *)
val MLton.Word.ror: word * word -> word (* @ $(SML_LIB)/basis/integer/word.sml 32.5-32.7 *)
structure MLton.Word16: MLTON_WORD where type t = Word16.word (* @ $(SML_LIB)/basis/mlton/mlton.sml 115.11-115.16 *)
type MLton.Word16.t = Word16.word (* @ $(SML_LIB)/basis/mlton/mlton.sml 118.12-118.12 *)
val MLton.Word16.bswap: Word16.word -> Word16.word (* @ $(SML_LIB)/basis/integer/word.sml 52.8-52.12 *)
val MLton.Word16.rol: Word16.word * word -> Word16.word (* @ $(SML_LIB)/basis/integer/word.sml 31.5-31.7 *)
val MLton.Word16.ror: Word16.word * word -> Word16.word (* @ $(SML_LIB)/basis/integer/word.sml 32.5-32.7 *)
structure MLton.Word32: MLTON_WORD where type t = word (* @ $(SML_LIB)/basis/mlton/mlton.sml 120.11-120.16 *)
type MLton.Word32.t = word (* @ $(SML_LIB)/basis/mlton/mlton.sml 123.12-123.12 *)
val MLton.Word32.bswap: word -> word (* @ $(SML_LIB)/basis/integer/word.sml 52.8-52.12 *)
val MLton.Word32.rol: word * word -> word (* @ $(SML_LIB)/basis/integer/word.sml 31.5-31.7 *)
val MLton.Word32.ror: word * word -> word (* @ $(SML_LIB)/basis/integer/word.sml 32.5-32.7 *)
structure MLton.Word64: MLTON_WORD where type t = LargeWord.word (* @ $(SML_LIB)/basis/mlton/mlton.sml 125.11-125.16 *)
type MLton.Word64.t = LargeWord.word (* @ $(SML_LIB)/basis/mlton/mlton.sml 128.12-128.12 *)
val MLton.Word64.bswap: LargeWord.word -> LargeWord.word (* @ $(SML_LIB)/basis/integer/word.sml 52.8-52.12 *)
val MLton.Word64.rol: LargeWord.word * word -> LargeWord.word (* @ $(SML_LIB)/basis/integer/word.sml 31.5-31.7 *)
val MLton.Word64.ror: LargeWord.word * word -> LargeWord.word (* @ $(SML_LIB)/basis/integer/word.sml 32.5-32.7 *)
structure MLton.Word8: MLTON_WORD where type t = Word8.word (* @ $(SML_LIB)/basis/mlton/mlton.sml 110.11-110.15 *)
type MLton.Word8.t = Word8.word (* @ $(SML_LIB)/basis/mlton/mlton.sml 113.12-113.12 *)
val MLton.Word8.bswap: Word8.word -> Word8.word (* @ $(SML_LIB)/basis/integer/word.sml 52.8-52.12 *)
val MLton.Word8.rol: Word8.word * word -> Word8.word (* @ $(SML_LIB)/basis/integer/word.sml 31.5-31.7 *)
val MLton.Word8.ror: Word8.word * word -> Word8.word (* @ $(SML_LIB)/basis/integer/word.sml 32.5-32.7 *)
structure MLton.Word8Array: MLTON_MONO_ARRAY where type elem = Word8.word where type t = Word8Array.array (* @ $(SML_LIB)/basis/mlton/mlton.sml 130.11-130.20 *)
type MLton.Word8Array.elem = Word8.word (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array.fun 22.12-22.15 *)
type MLton.Word8Array.t = Word8Array.array (* @ $(SML_LIB)/basis/mlton/mlton.sml 132.9-132.9 *)
val MLton.Word8Array.fromPoly: Word8.word array -> Word8Array.array (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array.fun 27.11-27.18 *)
val MLton.Word8Array.toPoly: Word8Array.array -> Word8.word array (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array.fun 28.11-28.16 *)
structure MLton.Word8Vector: MLTON_MONO_VECTOR where type elem = Word8.word where type t = Word8Vector.vector (* @ $(SML_LIB)/basis/mlton/mlton.sml 134.11-134.21 *)
type MLton.Word8Vector.elem = Word8.word (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-vector.fun 35.12-35.15 *)
type MLton.Word8Vector.t = Word8Vector.vector (* @ $(SML_LIB)/basis/mlton/mlton.sml 136.9-136.9 *)
val MLton.Word8Vector.fromPoly: Word8.word vector -> Word8Vector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-vector.fun 38.11-38.18 *)
val MLton.Word8Vector.toPoly: Word8Vector.vector -> Word8.word vector (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-vector.fun 39.11-39.16 *)
structure MLton.World: MLTON_WORLD where type status = MLton.World.status (* @ $(SML_LIB)/basis/mlton/mlton.sml 104.11-104.15 *)
datatype MLton.World.status = Clone | Original (* = datatype MLton.World.status *) (* @ $(SML_LIB)/basis/mlton/world.sml 17.16-17.21 *)
con MLton.World.Clone: MLton.World.status (* @ $(SML_LIB)/basis/mlton/world.sml 17.25-17.29 *)
con MLton.World.Original: MLton.World.status (* @ $(SML_LIB)/basis/mlton/world.sml 17.33-17.40 *)
val MLton.World.load: string -> 'a (* @ $(SML_LIB)/basis/mlton/world.sml 48.11-48.14 *)
val MLton.World.save: string -> MLton.World.status (* @ $(SML_LIB)/basis/mlton/world.sml 43.11-43.14 *)
val MLton.World.saveThread: string * MLton.Thread.Runnable.t -> unit (* @ $(SML_LIB)/basis/mlton/world.sml 38.11-38.20 *)
structure Math: MATH where type real = real (* @ $(SML_LIB)/basis/real/real.sml 1002.17-1002.20 *)
type Math.real = real (* @ $(SML_LIB)/basis/primitive/prim-real.sml 205.18-205.21 *)
val Math.acos: real -> real (* @ $(SML_LIB)/basis/real/real.sml 1016.20-1016.23 *)
val Math.asin: real -> real (* @ $(SML_LIB)/basis/real/real.sml 1017.20-1017.23 *)
val Math.atan: real -> real (* @ $(SML_LIB)/basis/primitive/prim-real.sml 209.17-209.20 *)
val Math.atan2: real * real -> real (* @ $(SML_LIB)/basis/primitive/prim-real.sml 210.17-210.21 *)
val Math.cos: real -> real (* @ $(SML_LIB)/basis/primitive/prim-real.sml 211.17-211.19 *)
val Math.cosh: real -> real (* @ $(SML_LIB)/basis/real/real.sml 1099.17-1099.20 *)
val Math.e: real (* @ $(SML_LIB)/basis/primitive/prim-real.sml 213.17-213.17 *)
val Math.exp: real -> real (* @ $(SML_LIB)/basis/real/real.sml 1028.17-1028.19 *)
val Math.ln: real -> real (* @ $(SML_LIB)/basis/real/real.sml 1023.20-1023.21 *)
val Math.log10: real -> real (* @ $(SML_LIB)/basis/real/real.sml 1024.20-1024.24 *)
val Math.pi: real (* @ $(SML_LIB)/basis/primitive/prim-real.sml 217.17-217.18 *)
val Math.pow: real * real -> real (* @ $(SML_LIB)/basis/real/real.sml 1055.17-1055.19 *)
val Math.sin: real -> real (* @ $(SML_LIB)/basis/primitive/prim-real.sml 219.17-219.19 *)
val Math.sinh: real -> real (* @ $(SML_LIB)/basis/real/real.sml 1105.17-1105.20 *)
val Math.sqrt: real -> real (* @ $(SML_LIB)/basis/primitive/prim-real.sml 221.17-221.20 *)
val Math.tan: real -> real (* @ $(SML_LIB)/basis/primitive/prim-real.sml 222.17-222.19 *)
val Math.tanh: real -> real (* @ $(SML_LIB)/basis/real/real.sml 1111.17-1111.20 *)
structure NetHostDB: NET_HOST_DB where type addr_family = NetHostDB.addr_family where type entry = NetHostDB.entry where type in_addr = Word8.word vector (* @ $(SML_LIB)/basis/libs/basis-extra/top-level/basis.sml 146.17-146.25 *)
type NetHostDB.addr_family = NetHostDB.addr_family (* @ $(SML_LIB)/basis/net/net-host-db.sml 47.12-47.22 *)
type NetHostDB.entry = NetHostDB.entry (* @ $(SML_LIB)/basis/net/net-host-db.sml 49.16-49.20 *)
type NetHostDB.in_addr = Word8.word vector (* @ $(SML_LIB)/basis/net/net-host-db.sml 14.12-14.18 *)
val NetHostDB.addr: NetHostDB.entry -> Word8.word vector (* @ $(SML_LIB)/basis/net/net-host-db.sml 62.11-62.14 *)
val NetHostDB.addrType: NetHostDB.entry -> NetHostDB.addr_family (* @ $(SML_LIB)/basis/net/net-host-db.sml 59.13-59.20 *)
val NetHostDB.addrs: NetHostDB.entry -> Word8.word vector list (* @ $(SML_LIB)/basis/net/net-host-db.sml 60.13-60.17 *)
val NetHostDB.aliases: NetHostDB.entry -> string list (* @ $(SML_LIB)/basis/net/net-host-db.sml 58.13-58.19 *)
val NetHostDB.fromString: string -> Word8.word vector option (* @ $(SML_LIB)/basis/net/net-host-db.sml 218.11-218.20 *)
val NetHostDB.getByAddr: Word8.word vector -> NetHostDB.entry option (* @ $(SML_LIB)/basis/net/net-host-db.sml 102.13-102.21 *)
val NetHostDB.getByName: string -> NetHostDB.entry option (* @ $(SML_LIB)/basis/net/net-host-db.sml 104.13-104.21 *)
val NetHostDB.getHostName: unit -> string (* @ $(SML_LIB)/basis/net/net-host-db.sml 108.11-108.21 *)
val NetHostDB.name: NetHostDB.entry -> string (* @ $(SML_LIB)/basis/net/net-host-db.sml 57.13-57.16 *)
val NetHostDB.scan: ('a -> (char * 'a) option) -> 'a -> (Word8.word vector * 'a) option (* @ $(SML_LIB)/basis/net/net-host-db.sml 122.11-122.14 *)
val NetHostDB.toString: Word8.word vector -> string (* @ $(SML_LIB)/basis/net/net-host-db.sml 219.11-219.18 *)
structure NetProtDB: NET_PROT_DB where type entry = NetProtDB.entry (* @ $(SML_LIB)/basis/libs/basis-extra/top-level/basis.sml 147.17-147.25 *)
type NetProtDB.entry = NetProtDB.entry (* @ $(SML_LIB)/basis/net/net-prot-db.sml 12.16-12.20 *)
val NetProtDB.aliases: NetProtDB.entry -> string list (* @ $(SML_LIB)/basis/net/net-prot-db.sml 20.13-20.19 *)
val NetProtDB.getByName: string -> NetProtDB.entry option (* @ $(SML_LIB)/basis/net/net-prot-db.sml 47.13-47.21 *)
val NetProtDB.getByNumber: int -> NetProtDB.entry option (* @ $(SML_LIB)/basis/net/net-prot-db.sml 49.13-49.23 *)
val NetProtDB.name: NetProtDB.entry -> string (* @ $(SML_LIB)/basis/net/net-prot-db.sml 19.13-19.16 *)
val NetProtDB.protocol: NetProtDB.entry -> int (* @ $(SML_LIB)/basis/net/net-prot-db.sml 21.13-21.20 *)
structure NetServDB: NET_SERV_DB where type entry = NetServDB.entry (* @ $(SML_LIB)/basis/libs/basis-extra/top-level/basis.sml 148.17-148.25 *)
type NetServDB.entry = NetServDB.entry (* @ $(SML_LIB)/basis/net/net-serv-db.sml 12.16-12.20 *)
val NetServDB.aliases: NetServDB.entry -> string list (* @ $(SML_LIB)/basis/net/net-serv-db.sml 21.13-21.19 *)
val NetServDB.getByName: string * string option -> NetServDB.entry option (* @ $(SML_LIB)/basis/net/net-serv-db.sml 51.13-51.21 *)
val NetServDB.getByPort: int * string option -> NetServDB.entry option (* @ $(SML_LIB)/basis/net/net-serv-db.sml 56.13-56.21 *)
val NetServDB.name: NetServDB.entry -> string (* @ $(SML_LIB)/basis/net/net-serv-db.sml 20.13-20.16 *)
val NetServDB.port: NetServDB.entry -> int (* @ $(SML_LIB)/basis/net/net-serv-db.sml 22.13-22.16 *)
val NetServDB.protocol: NetServDB.entry -> string (* @ $(SML_LIB)/basis/net/net-serv-db.sml 23.13-23.20 *)
structure OS: OS where type FileSys.access_mode = OS.FileSys.access_mode where type FileSys.dirstream = OS.FileSys.dirstream where type FileSys.file_id = OS.FileSys.file_id where type IO.iodesc = OS.IO.iodesc where type IO.iodesc_kind = OS.IO.iodesc_kind where type IO.poll_desc = OS.IO.poll_desc where type IO.poll_info = OS.IO.poll_info where type Process.status = OS.Process.status where type syserror = OS.syserror (* @ $(SML_LIB)/basis/libs/basis-2002/top-level/top-level.sml 18.11-18.12 *)
type OS.syserror = OS.syserror (* @ $(SML_LIB)/basis/posix/error.sml 15.12-15.19 *)
exn OS.SysErr: string * OS.syserror option -> exn (* @ $(SML_LIB)/basis/posix/error.sml 186.17-186.22 *)
val OS.errorMsg: OS.syserror -> string (* @ $(SML_LIB)/basis/posix/error.sml 214.11-214.18 *)
val OS.errorName: OS.syserror -> string (* @ $(SML_LIB)/basis/posix/error.sml 193.11-193.19 *)
val OS.syserror: string -> OS.syserror option (* @ $(SML_LIB)/basis/posix/error.sml 209.11-209.18 *)
structure OS.FileSys: OS_FILE_SYS where type access_mode = OS.FileSys.access_mode where type dirstream = OS.FileSys.dirstream where type file_id = OS.FileSys.file_id (* @ $(SML_LIB)/basis/mlton/mlton.sml 149.17-149.23 *)
datatype OS.FileSys.access_mode = A_EXEC | A_READ | A_WRITE (* = datatype OS.FileSys.access_mode *) (* @ $(SML_LIB)/basis/system/file-sys.sml 121.16-121.26 *)
type OS.FileSys.dirstream = OS.FileSys.dirstream (* @ $(SML_LIB)/basis/system/file-sys.sml 15.12-15.20 *)
type OS.FileSys.file_id = OS.FileSys.file_id (* @ $(SML_LIB)/basis/system/file-sys.sml 132.16-132.22 *)
con OS.FileSys.A_EXEC: OS.FileSys.access_mode (* @ $(SML_LIB)/basis/posix/file-sys.sml 376.49-376.54 *)
con OS.FileSys.A_READ: OS.FileSys.access_mode (* @ $(SML_LIB)/basis/posix/file-sys.sml 376.30-376.35 *)
con OS.FileSys.A_WRITE: OS.FileSys.access_mode (* @ $(SML_LIB)/basis/posix/file-sys.sml 376.39-376.45 *)
val OS.FileSys.access: string * OS.FileSys.access_mode list -> bool (* @ $(SML_LIB)/basis/system/file-sys.sml 123.11-123.16 *)
val OS.FileSys.chDir: string -> unit (* @ $(SML_LIB)/basis/system/file-sys.sml 22.11-22.15 *)
val OS.FileSys.closeDir: OS.FileSys.dirstream -> unit (* @ $(SML_LIB)/basis/system/file-sys.sml 20.11-20.18 *)
val OS.FileSys.compare: OS.FileSys.file_id * OS.FileSys.file_id -> order (* @ $(SML_LIB)/basis/system/file-sys.sml 145.11-145.17 *)
val OS.FileSys.fileId: string -> OS.FileSys.file_id (* @ $(SML_LIB)/basis/system/file-sys.sml 134.11-134.16 *)
val OS.FileSys.fileSize: string -> Int64.int (* @ $(SML_LIB)/basis/system/file-sys.sml 110.11-110.18 *)
val OS.FileSys.fullPath: string -> string (* @ $(SML_LIB)/basis/system/file-sys.sml 44.11-44.18 *)
val OS.FileSys.getDir: unit -> string (* @ $(SML_LIB)/basis/system/file-sys.sml 23.11-23.16 *)
val OS.FileSys.hash: OS.FileSys.file_id -> word (* @ $(SML_LIB)/basis/system/file-sys.sml 143.11-143.14 *)
val OS.FileSys.isDir: string -> bool (* @ $(SML_LIB)/basis/system/file-sys.sml 31.11-31.15 *)
val OS.FileSys.isLink: string -> bool (* @ $(SML_LIB)/basis/system/file-sys.sml 33.11-33.16 *)
val OS.FileSys.mkDir: string -> unit (* @ $(SML_LIB)/basis/system/file-sys.sml 28.14-28.18 *)
val OS.FileSys.modTime: string -> Time.time (* @ $(SML_LIB)/basis/system/file-sys.sml 112.11-112.17 *)
val OS.FileSys.openDir: string -> OS.FileSys.dirstream (* @ $(SML_LIB)/basis/system/file-sys.sml 17.11-17.17 *)
val OS.FileSys.readDir: OS.FileSys.dirstream -> string option (* @ $(SML_LIB)/basis/system/file-sys.sml 18.11-18.17 *)
val OS.FileSys.readLink: string -> string (* @ $(SML_LIB)/basis/system/file-sys.sml 34.11-34.18 *)
val OS.FileSys.realPath: string -> string (* @ $(SML_LIB)/basis/system/file-sys.sml 104.11-104.18 *)
val OS.FileSys.remove: string -> unit (* @ $(SML_LIB)/basis/system/file-sys.sml 117.11-117.16 *)
val OS.FileSys.rename: {new: string, old: string} -> unit (* @ $(SML_LIB)/basis/system/file-sys.sml 119.11-119.16 *)
val OS.FileSys.rewindDir: OS.FileSys.dirstream -> unit (* @ $(SML_LIB)/basis/system/file-sys.sml 19.11-19.19 *)
val OS.FileSys.rmDir: string -> unit (* @ $(SML_LIB)/basis/system/file-sys.sml 30.11-30.15 *)
val OS.FileSys.setTime: string * Time.time option -> unit (* @ $(SML_LIB)/basis/system/file-sys.sml 114.11-114.17 *)
val OS.FileSys.tmpName: unit -> string (* @ $(SML_LIB)/basis/mlton/mlton.sml 153.17-153.23 *)
structure OS.IO: OS_IO where type iodesc = OS.IO.iodesc where type iodesc_kind = OS.IO.iodesc_kind where type poll_desc = OS.IO.poll_desc where type poll_info = OS.IO.poll_info (* @ $(SML_LIB)/basis/system/os.sml 14.17-14.18 *)
type OS.IO.iodesc = OS.IO.iodesc (* @ $(SML_LIB)/basis/system/io.sml 24.11-24.16 *)
type OS.IO.iodesc_kind = OS.IO.iodesc_kind (* @ $(SML_LIB)/basis/system/io.sml 26.14-26.24 *)
type OS.IO.poll_desc = OS.IO.poll_desc (* @ $(SML_LIB)/basis/system/io.sml 65.14-65.22 *)
type OS.IO.poll_info = OS.IO.poll_info (* @ $(SML_LIB)/basis/system/io.sml 66.14-66.22 *)
exn OS.IO.Poll: exn (* @ $(SML_LIB)/basis/system/io.sml 77.15-77.18 *)
val OS.IO.compare: OS.IO.iodesc * OS.IO.iodesc -> order (* @ $(SML_LIB)/basis/system/io.sml 37.9-37.15 *)
val OS.IO.hash: OS.IO.iodesc -> word (* @ $(SML_LIB)/basis/system/io.sml 34.9-34.12 *)
val OS.IO.infoToPollDesc: OS.IO.poll_info -> OS.IO.poll_desc (* @ $(SML_LIB)/basis/system/io.sml 146.9-146.22 *)
val OS.IO.isIn: OS.IO.poll_info -> bool (* @ $(SML_LIB)/basis/system/io.sml 143.9-143.12 *)
val OS.IO.isOut: OS.IO.poll_info -> bool (* @ $(SML_LIB)/basis/system/io.sml 144.9-144.13 *)
val OS.IO.isPri: OS.IO.poll_info -> bool (* @ $(SML_LIB)/basis/system/io.sml 145.9-145.13 *)
val OS.IO.kind: OS.IO.iodesc -> OS.IO.iodesc_kind (* @ $(SML_LIB)/basis/system/io.sml 51.9-51.12 *)
val OS.IO.poll: OS.IO.poll_desc list * Time.time option -> OS.IO.poll_info list (* @ $(SML_LIB)/basis/system/io.sml 111.9-111.12 *)
val OS.IO.pollDesc: OS.IO.iodesc -> OS.IO.poll_desc option (* @ $(SML_LIB)/basis/system/io.sml 72.9-72.16 *)
val OS.IO.pollIn: OS.IO.poll_desc -> OS.IO.poll_desc (* @ $(SML_LIB)/basis/system/io.sml 82.9-82.14 *)
val OS.IO.pollOut: OS.IO.poll_desc -> OS.IO.poll_desc (* @ $(SML_LIB)/basis/system/io.sml 84.9-84.15 *)
val OS.IO.pollPri: OS.IO.poll_desc -> OS.IO.poll_desc (* @ $(SML_LIB)/basis/system/io.sml 86.9-86.15 *)
val OS.IO.pollToIODesc: OS.IO.poll_desc -> OS.IO.iodesc (* @ $(SML_LIB)/basis/system/io.sml 75.9-75.20 *)
structure OS.IO.Kind:
   sig
      val device: OS.IO.iodesc_kind
      val dir: OS.IO.iodesc_kind
      val file: OS.IO.iodesc_kind
      val pipe: OS.IO.iodesc_kind
      val socket: OS.IO.iodesc_kind
      val symlink: OS.IO.iodesc_kind
      val tty: OS.IO.iodesc_kind
   end
   (* @ $(SML_LIB)/basis/system/io.sml 39.15-39.18 *)
val OS.IO.Kind.device: OS.IO.iodesc_kind (* @ $(SML_LIB)/basis/system/io.sml 47.13-47.18 *)
val OS.IO.Kind.dir: OS.IO.iodesc_kind (* @ $(SML_LIB)/basis/system/io.sml 42.13-42.15 *)
val OS.IO.Kind.file: OS.IO.iodesc_kind (* @ $(SML_LIB)/basis/system/io.sml 41.13-41.16 *)
val OS.IO.Kind.pipe: OS.IO.iodesc_kind (* @ $(SML_LIB)/basis/system/io.sml 45.13-45.16 *)
val OS.IO.Kind.socket: OS.IO.iodesc_kind (* @ $(SML_LIB)/basis/system/io.sml 46.13-46.18 *)
val OS.IO.Kind.symlink: OS.IO.iodesc_kind (* @ $(SML_LIB)/basis/system/io.sml 43.13-43.19 *)
val OS.IO.Kind.tty: OS.IO.iodesc_kind (* @ $(SML_LIB)/basis/system/io.sml 44.13-44.15 *)
structure OS.Path: OS_PATH (* @ $(SML_LIB)/basis/system/os.sml 12.17-12.20 *)
exn OS.Path.InvalidArc: exn (* @ $(SML_LIB)/basis/system/path.sml 11.11-11.20 *)
exn OS.Path.Path: exn (* @ $(SML_LIB)/basis/system/path.sml 10.11-10.14 *)
val OS.Path.base: string -> string (* @ $(SML_LIB)/basis/system/path.sml 271.5-271.8 *)
val OS.Path.concat: string * string -> string (* @ $(SML_LIB)/basis/system/path.sml 123.5-123.10 *)
val OS.Path.currentArc: string (* @ $(SML_LIB)/basis/system/path.sml 64.5-64.14 *)
val OS.Path.dir: string -> string (* @ $(SML_LIB)/basis/system/path.sml 244.5-244.7 *)
val OS.Path.ext: string -> string option (* @ $(SML_LIB)/basis/system/path.sml 270.5-270.7 *)
val OS.Path.file: string -> string (* @ $(SML_LIB)/basis/system/path.sml 246.5-246.8 *)
val OS.Path.fromString: string -> {arcs: string list, isAbs: bool, vol: string} (* @ $(SML_LIB)/basis/system/path.sml 77.5-77.14 *)
val OS.Path.fromUnixPath: string -> string (* @ $(SML_LIB)/basis/system/path.sml 278.5-278.16 *)
val OS.Path.getParent: string -> string (* @ $(SML_LIB)/basis/system/path.sml 133.5-133.13 *)
val OS.Path.getVolume: string -> string (* @ $(SML_LIB)/basis/system/path.sml 92.5-92.13 *)
val OS.Path.isAbsolute: string -> bool (* @ $(SML_LIB)/basis/system/path.sml 93.5-93.14 *)
val OS.Path.isCanonical: string -> bool (* @ $(SML_LIB)/basis/system/path.sml 216.5-216.15 *)
val OS.Path.isRelative: string -> bool (* @ $(SML_LIB)/basis/system/path.sml 94.5-94.14 *)
val OS.Path.isRoot: string -> bool (* @ $(SML_LIB)/basis/system/path.sml 273.5-273.10 *)
val OS.Path.joinBaseExt: {base: string, ext: string option} -> string (* @ $(SML_LIB)/basis/system/path.sml 248.5-248.15 *)
val OS.Path.joinDirFile: {dir: string, file: string} -> string (* @ $(SML_LIB)/basis/system/path.sml 218.5-218.15 *)
val OS.Path.mkAbsolute: {path: string, relativeTo: string} -> string (* @ $(SML_LIB)/basis/system/path.sml 211.5-211.14 *)
val OS.Path.mkCanonical: string -> string (* @ $(SML_LIB)/basis/system/path.sml 148.5-148.15 *)
val OS.Path.mkRelative: {path: string, relativeTo: string} -> string (* @ $(SML_LIB)/basis/system/path.sml 184.5-184.14 *)
val OS.Path.parentArc: string (* @ $(SML_LIB)/basis/system/path.sml 63.5-63.13 *)
val OS.Path.splitBaseExt: string -> {base: string, ext: string option} (* @ $(SML_LIB)/basis/system/path.sml 255.5-255.16 *)
val OS.Path.splitDirFile: string -> {dir: string, file: string} (* @ $(SML_LIB)/basis/system/path.sml 231.5-231.16 *)
val OS.Path.toString: {arcs: string list, isAbs: bool, vol: string} -> string (* @ $(SML_LIB)/basis/system/path.sml 102.5-102.12 *)
val OS.Path.toUnixPath: string -> string (* @ $(SML_LIB)/basis/system/path.sml 283.5-283.14 *)
val OS.Path.validVolume: {isAbs: bool, vol: string} -> bool (* @ $(SML_LIB)/basis/system/path.sml 72.5-72.15 *)
structure OS.Process: OS_PROCESS where type status = OS.Process.status (* @ $(SML_LIB)/basis/system/os.sml 13.17-13.23 *)
type OS.Process.status = OS.Process.status (* @ $(SML_LIB)/basis/system/process.sml 41.12-41.17 *)
val OS.Process.atExit: (unit -> unit) -> unit (* @ $(SML_LIB)/basis/system/process.sml 52.11-52.16 *)
val OS.Process.exit: OS.Process.status -> 'a (* @ $(SML_LIB)/basis/system/process.sml 54.11-54.14 *)
val OS.Process.failure: OS.Process.status (* @ $(SML_LIB)/basis/system/process.sml 43.11-43.17 *)
val OS.Process.getEnv: string -> string option (* @ $(SML_LIB)/basis/system/process.sml 58.11-58.16 *)
val OS.Process.isSuccess: OS.Process.status -> bool (* @ $(SML_LIB)/basis/system/process.sml 45.11-45.19 *)
val OS.Process.sleep: Time.time -> unit (* @ $(SML_LIB)/basis/system/process.sml 60.11-60.15 *)
val OS.Process.success: OS.Process.status (* @ $(SML_LIB)/basis/system/process.sml 44.11-44.17 *)
val OS.Process.system: string -> OS.Process.status (* @ $(SML_LIB)/basis/system/process.sml 47.11-47.16 *)
val OS.Process.terminate: OS.Process.status -> 'a (* @ $(SML_LIB)/basis/system/process.sml 56.11-56.19 *)
structure Option: OPTION where type 'a option = 'a option (* @ $(SML_LIB)/basis/libs/basis-extra/top-level/basis.sml 34.17-34.22 *)
datatype 'a Option.option = NONE | SOME of 'a (* = datatype 'a option *) (* @ $(SML_LIB)/basis/general/option.sml 12.10-12.15 *)
con Option.NONE: 'a option (* @ $(SML_LIB)/basis/primitive/prim1.sml 67.23-67.26 *)
exn Option.Option: exn (* @ $(SML_LIB)/basis/general/option.sml 14.11-14.16 *)
con Option.SOME: 'a -> 'a option (* @ $(SML_LIB)/basis/primitive/prim1.sml 67.30-67.33 *)
val Option.app: ('a -> unit) -> 'a option -> unit (* @ $(SML_LIB)/basis/general/option.sml 20.5-20.7 *)
val Option.compose: ('a -> 'b) * ('c -> 'a option) -> 'c -> 'b option (* @ $(SML_LIB)/basis/general/option.sml 22.5-22.11 *)
val Option.composePartial: ('a -> 'b option) * ('c -> 'a option) -> 'c -> 'b option (* @ $(SML_LIB)/basis/general/option.sml 30.5-30.18 *)
val Option.filter: ('a -> bool) -> 'a -> 'a option (* @ $(SML_LIB)/basis/general/option.sml 32.5-32.10 *)
val Option.getOpt: 'a option * 'a -> 'a (* @ $(SML_LIB)/basis/general/option.sml 34.5-34.10 *)
val Option.isSome: 'a option -> bool (* @ $(SML_LIB)/basis/general/option.sml 39.5-39.10 *)
val Option.join: 'a option option -> 'a option (* @ $(SML_LIB)/basis/general/option.sml 24.5-24.8 *)
val Option.map: ('a -> 'b) -> 'a option -> 'b option (* @ $(SML_LIB)/basis/general/option.sml 16.5-16.7 *)
val Option.mapPartial: ('a -> 'b option) -> 'a option -> 'b option (* @ $(SML_LIB)/basis/general/option.sml 28.5-28.14 *)
val Option.valOf: 'a option -> 'a (* @ $(SML_LIB)/basis/general/option.sml 43.5-43.9 *)
structure PackReal32Big: PACK_REAL where type real = Real32.real (* @ $(SML_LIB)/basis/libs/basis-extra/top-level/basis.sml 149.17-149.29 *)
type PackReal32Big.real = Real32.real (* @ $(SML_LIB)/basis/primitive/prim-pack-real.sml 17.12-17.15 *)
val PackReal32Big.bytesPerElem: int (* @ $(SML_LIB)/basis/real/pack-real.sml 192.5-192.16 *)
val PackReal32Big.fromBytes: Word8Vector.vector -> Real32.real (* @ $(SML_LIB)/basis/real/pack-real.sml 261.5-261.13 *)
val PackReal32Big.isBigEndian: bool (* @ $(SML_LIB)/basis/real/pack-real.sml 268.18-268.28 *)
val PackReal32Big.subArr: Word8Array.array * int -> Real32.real (* @ $(SML_LIB)/basis/real/pack-real.sml 237.8-237.13 *)
val PackReal32Big.subVec: Word8Vector.vector * int -> Real32.real (* @ $(SML_LIB)/basis/real/pack-real.sml 238.8-238.13 *)
val PackReal32Big.toBytes: Real32.real -> Word8Vector.vector (* @ $(SML_LIB)/basis/real/pack-real.sml 253.5-253.11 *)
val PackReal32Big.update: Word8Array.array * int * Real32.real -> unit (* @ $(SML_LIB)/basis/real/pack-real.sml 213.5-213.10 *)
structure PackReal32Little: PACK_REAL where type real = Real32.real (* @ $(SML_LIB)/basis/libs/basis-extra/top-level/basis.sml 150.17-150.32 *)
type PackReal32Little.real = Real32.real (* @ $(SML_LIB)/basis/primitive/prim-pack-real.sml 17.12-17.15 *)
val PackReal32Little.bytesPerElem: int (* @ $(SML_LIB)/basis/real/pack-real.sml 192.5-192.16 *)
val PackReal32Little.fromBytes: Word8Vector.vector -> Real32.real (* @ $(SML_LIB)/basis/real/pack-real.sml 261.5-261.13 *)
val PackReal32Little.isBigEndian: bool (* @ $(SML_LIB)/basis/real/pack-real.sml 272.18-272.28 *)
val PackReal32Little.subArr: Word8Array.array * int -> Real32.real (* @ $(SML_LIB)/basis/real/pack-real.sml 237.8-237.13 *)
val PackReal32Little.subVec: Word8Vector.vector * int -> Real32.real (* @ $(SML_LIB)/basis/real/pack-real.sml 238.8-238.13 *)
val PackReal32Little.toBytes: Real32.real -> Word8Vector.vector (* @ $(SML_LIB)/basis/real/pack-real.sml 253.5-253.11 *)
val PackReal32Little.update: Word8Array.array * int * Real32.real -> unit (* @ $(SML_LIB)/basis/real/pack-real.sml 213.5-213.10 *)
structure PackReal64Big: PACK_REAL where type real = real (* @ $(SML_LIB)/basis/libs/basis-extra/top-level/basis.sml 151.17-151.29 *)
type PackReal64Big.real = real (* @ $(SML_LIB)/basis/primitive/prim-pack-real.sml 26.12-26.15 *)
val PackReal64Big.bytesPerElem: int (* @ $(SML_LIB)/basis/real/pack-real.sml 192.5-192.16 *)
val PackReal64Big.fromBytes: Word8Vector.vector -> real (* @ $(SML_LIB)/basis/real/pack-real.sml 261.5-261.13 *)
val PackReal64Big.isBigEndian: bool (* @ $(SML_LIB)/basis/real/pack-real.sml 280.18-280.28 *)
val PackReal64Big.subArr: Word8Array.array * int -> real (* @ $(SML_LIB)/basis/real/pack-real.sml 237.8-237.13 *)
val PackReal64Big.subVec: Word8Vector.vector * int -> real (* @ $(SML_LIB)/basis/real/pack-real.sml 238.8-238.13 *)
val PackReal64Big.toBytes: real -> Word8Vector.vector (* @ $(SML_LIB)/basis/real/pack-real.sml 253.5-253.11 *)
val PackReal64Big.update: Word8Array.array * int * real -> unit (* @ $(SML_LIB)/basis/real/pack-real.sml 213.5-213.10 *)
structure PackReal64Little: PACK_REAL where type real = real (* @ $(SML_LIB)/basis/libs/basis-extra/top-level/basis.sml 152.17-152.32 *)
type PackReal64Little.real = real (* @ $(SML_LIB)/basis/primitive/prim-pack-real.sml 26.12-26.15 *)
val PackReal64Little.bytesPerElem: int (* @ $(SML_LIB)/basis/real/pack-real.sml 192.5-192.16 *)
val PackReal64Little.fromBytes: Word8Vector.vector -> real (* @ $(SML_LIB)/basis/real/pack-real.sml 261.5-261.13 *)
val PackReal64Little.isBigEndian: bool (* @ $(SML_LIB)/basis/real/pack-real.sml 284.18-284.28 *)
val PackReal64Little.subArr: Word8Array.array * int -> real (* @ $(SML_LIB)/basis/real/pack-real.sml 237.8-237.13 *)
val PackReal64Little.subVec: Word8Vector.vector * int -> real (* @ $(SML_LIB)/basis/real/pack-real.sml 238.8-238.13 *)
val PackReal64Little.toBytes: real -> Word8Vector.vector (* @ $(SML_LIB)/basis/real/pack-real.sml 253.5-253.11 *)
val PackReal64Little.update: Word8Array.array * int * real -> unit (* @ $(SML_LIB)/basis/real/pack-real.sml 213.5-213.10 *)
structure PackRealBig: PACK_REAL where type real = real (* @ $(SML_LIB)/basis/libs/basis-extra/top-level/basis.sml 153.17-153.27 *)
type PackRealBig.real = real (* @ $(SML_LIB)/basis/real/pack-real.sml 44.12-44.15 *)
val PackRealBig.bytesPerElem: int (* @ $(SML_LIB)/basis/real/pack-real.sml 192.5-192.16 *)
val PackRealBig.fromBytes: Word8Vector.vector -> real (* @ $(SML_LIB)/basis/real/pack-real.sml 261.5-261.13 *)
val PackRealBig.isBigEndian: bool (* @ $(SML_LIB)/basis/real/pack-real.sml 292.18-292.28 *)
val PackRealBig.subArr: Word8Array.array * int -> real (* @ $(SML_LIB)/basis/real/pack-real.sml 237.8-237.13 *)
val PackRealBig.subVec: Word8Vector.vector * int -> real (* @ $(SML_LIB)/basis/real/pack-real.sml 238.8-238.13 *)
val PackRealBig.toBytes: real -> Word8Vector.vector (* @ $(SML_LIB)/basis/real/pack-real.sml 253.5-253.11 *)
val PackRealBig.update: Word8Array.array * int * real -> unit (* @ $(SML_LIB)/basis/real/pack-real.sml 213.5-213.10 *)
structure PackRealLittle: PACK_REAL where type real = real (* @ $(SML_LIB)/basis/libs/basis-extra/top-level/basis.sml 154.17-154.30 *)
type PackRealLittle.real = real (* @ $(SML_LIB)/basis/real/pack-real.sml 44.12-44.15 *)
val PackRealLittle.bytesPerElem: int (* @ $(SML_LIB)/basis/real/pack-real.sml 192.5-192.16 *)
val PackRealLittle.fromBytes: Word8Vector.vector -> real (* @ $(SML_LIB)/basis/real/pack-real.sml 261.5-261.13 *)
val PackRealLittle.isBigEndian: bool (* @ $(SML_LIB)/basis/real/pack-real.sml 296.18-296.28 *)
val PackRealLittle.subArr: Word8Array.array * int -> real (* @ $(SML_LIB)/basis/real/pack-real.sml 237.8-237.13 *)
val PackRealLittle.subVec: Word8Vector.vector * int -> real (* @ $(SML_LIB)/basis/real/pack-real.sml 238.8-238.13 *)
val PackRealLittle.toBytes: real -> Word8Vector.vector (* @ $(SML_LIB)/basis/real/pack-real.sml 253.5-253.11 *)
val PackRealLittle.update: Word8Array.array * int * real -> unit (* @ $(SML_LIB)/basis/real/pack-real.sml 213.5-213.10 *)
structure PackWord16Big: PACK_WORD (* @ $(SML_LIB)/basis/libs/basis-extra/top-level/basis.sml 155.17-155.29 *)
val PackWord16Big.bytesPerElem: int (* @ $(SML_LIB)/basis/integer/pack-word.sml 25.5-25.16 *)
val PackWord16Big.isBigEndian: bool (* @ $(SML_LIB)/basis/integer/pack-word.sml 108.18-108.28 *)
val PackWord16Big.subArr: Word8Array.array * int -> LargeWord.word (* @ $(SML_LIB)/basis/integer/pack-word.sml 73.8-73.13 *)
val PackWord16Big.subArrX: Word8Array.array * int -> LargeWord.word (* @ $(SML_LIB)/basis/integer/pack-word.sml 74.8-74.14 *)
val PackWord16Big.subVec: Word8Vector.vector * int -> LargeWord.word (* @ $(SML_LIB)/basis/integer/pack-word.sml 75.8-75.13 *)
val PackWord16Big.subVecX: Word8Vector.vector * int -> LargeWord.word (* @ $(SML_LIB)/basis/integer/pack-word.sml 76.8-76.14 *)
val PackWord16Big.update: Word8Array.array * int * LargeWord.word -> unit (* @ $(SML_LIB)/basis/integer/pack-word.sml 57.5-57.10 *)
structure PackWord16Little: PACK_WORD (* @ $(SML_LIB)/basis/libs/basis-extra/top-level/basis.sml 156.17-156.32 *)
val PackWord16Little.bytesPerElem: int (* @ $(SML_LIB)/basis/integer/pack-word.sml 25.5-25.16 *)
val PackWord16Little.isBigEndian: bool (* @ $(SML_LIB)/basis/integer/pack-word.sml 112.18-112.28 *)
val PackWord16Little.subArr: Word8Array.array * int -> LargeWord.word (* @ $(SML_LIB)/basis/integer/pack-word.sml 73.8-73.13 *)
val PackWord16Little.subArrX: Word8Array.array * int -> LargeWord.word (* @ $(SML_LIB)/basis/integer/pack-word.sml 74.8-74.14 *)
val PackWord16Little.subVec: Word8Vector.vector * int -> LargeWord.word (* @ $(SML_LIB)/basis/integer/pack-word.sml 75.8-75.13 *)
val PackWord16Little.subVecX: Word8Vector.vector * int -> LargeWord.word (* @ $(SML_LIB)/basis/integer/pack-word.sml 76.8-76.14 *)
val PackWord16Little.update: Word8Array.array * int * LargeWord.word -> unit (* @ $(SML_LIB)/basis/integer/pack-word.sml 57.5-57.10 *)
structure PackWord32Big: PACK_WORD (* @ $(SML_LIB)/basis/libs/basis-extra/top-level/basis.sml 157.17-157.29 *)
val PackWord32Big.bytesPerElem: int (* @ $(SML_LIB)/basis/integer/pack-word.sml 25.5-25.16 *)
val PackWord32Big.isBigEndian: bool (* @ $(SML_LIB)/basis/integer/pack-word.sml 120.18-120.28 *)
val PackWord32Big.subArr: Word8Array.array * int -> LargeWord.word (* @ $(SML_LIB)/basis/integer/pack-word.sml 73.8-73.13 *)
val PackWord32Big.subArrX: Word8Array.array * int -> LargeWord.word (* @ $(SML_LIB)/basis/integer/pack-word.sml 74.8-74.14 *)
val PackWord32Big.subVec: Word8Vector.vector * int -> LargeWord.word (* @ $(SML_LIB)/basis/integer/pack-word.sml 75.8-75.13 *)
val PackWord32Big.subVecX: Word8Vector.vector * int -> LargeWord.word (* @ $(SML_LIB)/basis/integer/pack-word.sml 76.8-76.14 *)
val PackWord32Big.update: Word8Array.array * int * LargeWord.word -> unit (* @ $(SML_LIB)/basis/integer/pack-word.sml 57.5-57.10 *)
structure PackWord32Little: PACK_WORD (* @ $(SML_LIB)/basis/libs/basis-extra/top-level/basis.sml 158.17-158.32 *)
val PackWord32Little.bytesPerElem: int (* @ $(SML_LIB)/basis/integer/pack-word.sml 25.5-25.16 *)
val PackWord32Little.isBigEndian: bool (* @ $(SML_LIB)/basis/integer/pack-word.sml 124.18-124.28 *)
val PackWord32Little.subArr: Word8Array.array * int -> LargeWord.word (* @ $(SML_LIB)/basis/integer/pack-word.sml 73.8-73.13 *)
val PackWord32Little.subArrX: Word8Array.array * int -> LargeWord.word (* @ $(SML_LIB)/basis/integer/pack-word.sml 74.8-74.14 *)
val PackWord32Little.subVec: Word8Vector.vector * int -> LargeWord.word (* @ $(SML_LIB)/basis/integer/pack-word.sml 75.8-75.13 *)
val PackWord32Little.subVecX: Word8Vector.vector * int -> LargeWord.word (* @ $(SML_LIB)/basis/integer/pack-word.sml 76.8-76.14 *)
val PackWord32Little.update: Word8Array.array * int * LargeWord.word -> unit (* @ $(SML_LIB)/basis/integer/pack-word.sml 57.5-57.10 *)
structure PackWord64Big: PACK_WORD (* @ $(SML_LIB)/basis/libs/basis-extra/top-level/basis.sml 159.17-159.29 *)
val PackWord64Big.bytesPerElem: int (* @ $(SML_LIB)/basis/integer/pack-word.sml 25.5-25.16 *)
val PackWord64Big.isBigEndian: bool (* @ $(SML_LIB)/basis/integer/pack-word.sml 132.18-132.28 *)
val PackWord64Big.subArr: Word8Array.array * int -> LargeWord.word (* @ $(SML_LIB)/basis/integer/pack-word.sml 73.8-73.13 *)
val PackWord64Big.subArrX: Word8Array.array * int -> LargeWord.word (* @ $(SML_LIB)/basis/integer/pack-word.sml 74.8-74.14 *)
val PackWord64Big.subVec: Word8Vector.vector * int -> LargeWord.word (* @ $(SML_LIB)/basis/integer/pack-word.sml 75.8-75.13 *)
val PackWord64Big.subVecX: Word8Vector.vector * int -> LargeWord.word (* @ $(SML_LIB)/basis/integer/pack-word.sml 76.8-76.14 *)
val PackWord64Big.update: Word8Array.array * int * LargeWord.word -> unit (* @ $(SML_LIB)/basis/integer/pack-word.sml 57.5-57.10 *)
structure PackWord64Little: PACK_WORD (* @ $(SML_LIB)/basis/libs/basis-extra/top-level/basis.sml 160.17-160.32 *)
val PackWord64Little.bytesPerElem: int (* @ $(SML_LIB)/basis/integer/pack-word.sml 25.5-25.16 *)
val PackWord64Little.isBigEndian: bool (* @ $(SML_LIB)/basis/integer/pack-word.sml 136.18-136.28 *)
val PackWord64Little.subArr: Word8Array.array * int -> LargeWord.word (* @ $(SML_LIB)/basis/integer/pack-word.sml 73.8-73.13 *)
val PackWord64Little.subArrX: Word8Array.array * int -> LargeWord.word (* @ $(SML_LIB)/basis/integer/pack-word.sml 74.8-74.14 *)
val PackWord64Little.subVec: Word8Vector.vector * int -> LargeWord.word (* @ $(SML_LIB)/basis/integer/pack-word.sml 75.8-75.13 *)
val PackWord64Little.subVecX: Word8Vector.vector * int -> LargeWord.word (* @ $(SML_LIB)/basis/integer/pack-word.sml 76.8-76.14 *)
val PackWord64Little.update: Word8Array.array * int * LargeWord.word -> unit (* @ $(SML_LIB)/basis/integer/pack-word.sml 57.5-57.10 *)
structure Position: INTEGER where type int = Int64.int (* @ $(SML_LIB)/basis/libs/basis-extra/top-level/basis.sml 35.17-35.24 *)
type Position.int = Int64.int (* @ $(SML_LIB)/basis/primitive/prim-basis.sml 233.12-233.14 *)
val Position.* : Int64.int * Int64.int -> Int64.int (* @ $(SML_LIB)/basis/primitive/prim-int.sml 438.11-438.11 *)
val Position.+ : Int64.int * Int64.int -> Int64.int (* @ $(SML_LIB)/basis/primitive/prim-int.sml 432.11-432.11 *)
val Position.- : Int64.int * Int64.int -> Int64.int (* @ $(SML_LIB)/basis/primitive/prim-int.sml 451.11-451.11 *)
val Position.< : Int64.int * Int64.int -> bool (* @ $(SML_LIB)/basis/util/integral-comparisons.sml 11.11-11.11 *)
val Position.<= : Int64.int * Int64.int -> bool (* @ $(SML_LIB)/basis/util/integral-comparisons.sml 12.11-12.12 *)
val Position.> : Int64.int * Int64.int -> bool (* @ $(SML_LIB)/basis/util/integral-comparisons.sml 13.11-13.11 *)
val Position.>= : Int64.int * Int64.int -> bool (* @ $(SML_LIB)/basis/util/integral-comparisons.sml 14.11-14.12 *)
val Position.abs: Int64.int -> Int64.int (* @ $(SML_LIB)/basis/integer/num0.sml 161.17-161.19 *)
val Position.compare: Int64.int * Int64.int -> order (* @ $(SML_LIB)/basis/util/integral-comparisons.sml 16.11-16.17 *)
val Position.div: Int64.int * Int64.int -> Int64.int (* @ $(SML_LIB)/basis/integer/num0.sml 183.19-183.21 *)
val Position.fmt: StringCvt.radix -> Int64.int -> string (* @ $(SML_LIB)/basis/integer/int.sml 74.8-74.10 *)
val Position.fromInt: int -> Int64.int (* @ $(SML_LIB)/basis/integer/int.sml 46.5-46.11 *)
val Position.fromLarge: LargeInt.int -> Int64.int (* @ $(SML_LIB)/basis/integer/int.sml 51.5-51.13 *)
val Position.fromString: string -> Int64.int option (* @ $(SML_LIB)/basis/integer/int.sml 165.5-165.14 *)
val Position.max: Int64.int * Int64.int -> Int64.int (* @ $(SML_LIB)/basis/util/integral-comparisons.sml 21.11-21.13 *)
val Position.maxInt: Int64.int option (* @ $(SML_LIB)/basis/integer/int.sml 19.5-19.10 *)
val Position.min: Int64.int * Int64.int -> Int64.int (* @ $(SML_LIB)/basis/util/integral-comparisons.sml 20.11-20.13 *)
val Position.minInt: Int64.int option (* @ $(SML_LIB)/basis/integer/int.sml 20.5-20.10 *)
val Position.mod: Int64.int * Int64.int -> Int64.int (* @ $(SML_LIB)/basis/integer/num0.sml 204.19-204.21 *)
val Position.precision: int option (* @ $(SML_LIB)/basis/integer/int.sml 16.5-16.13 *)
val Position.quot: Int64.int * Int64.int -> Int64.int (* @ $(SML_LIB)/basis/integer/num0.sml 163.17-163.20 *)
val Position.rem: Int64.int * Int64.int -> Int64.int (* @ $(SML_LIB)/basis/integer/num0.sml 175.17-175.19 *)
val Position.sameSign: Int64.int * Int64.int -> bool (* @ $(SML_LIB)/basis/integer/int.sml 29.5-29.12 *)
val Position.scan: StringCvt.radix -> ('a -> (char * 'a) option) -> 'a -> (Int64.int * 'a) option (* @ $(SML_LIB)/basis/integer/int.sml 112.5-112.8 *)
val Position.sign: Int64.int -> int (* @ $(SML_LIB)/basis/integer/int.sml 22.5-22.8 *)
val Position.toInt: Int64.int -> int (* @ $(SML_LIB)/basis/integer/int.sml 47.5-47.9 *)
val Position.toLarge: Int64.int -> LargeInt.int (* @ $(SML_LIB)/basis/integer/int.sml 52.5-52.11 *)
val Position.toString: Int64.int -> string (* @ $(SML_LIB)/basis/integer/int.sml 110.5-110.12 *)
val Position.~ : Int64.int -> Int64.int (* @ $(SML_LIB)/basis/primitive/prim-int.sml 444.11-444.11 *)
structure Posix: POSIX where type Error.syserror = OS.syserror where type FileSys.O.flags = Posix.FileSys.O.flags where type FileSys.S.mode = Posix.FileSys.S.mode where type FileSys.ST.stat = Posix.FileSys.ST.stat where type FileSys.access_mode = OS.FileSys.access_mode where type FileSys.dev = Posix.FileSys.dev where type FileSys.dirstream = OS.FileSys.dirstream where type FileSys.file_desc = Posix.TTY.file_desc where type FileSys.gid = Posix.SysDB.gid where type FileSys.ino = Posix.FileSys.ino where type FileSys.open_mode = Posix.IO.open_mode where type FileSys.uid = Posix.SysDB.uid where type IO.FD.flags = Posix.IO.FD.flags where type IO.FLock.flock = Posix.IO.FLock.flock where type IO.O.flags = Posix.IO.O.flags where type IO.lock_type = Posix.IO.lock_type where type IO.pid = Posix.TTY.pid where type IO.whence = Posix.IO.whence where type Process.W.flags = Posix.Process.W.flags where type Process.exit_status = Unix.exit_status where type Process.killpid_arg = Posix.Process.killpid_arg where type Process.signal = Unix.signal where type Process.waitpid_arg = Posix.Process.waitpid_arg where type SysDB.Group.group = Posix.SysDB.Group.group where type SysDB.Passwd.passwd = Posix.SysDB.Passwd.passwd where type TTY.C.flags = Posix.TTY.C.flags where type TTY.I.flags = Posix.TTY.I.flags where type TTY.L.flags = Posix.TTY.L.flags where type TTY.O.flags = Posix.TTY.O.flags where type TTY.TC.flow_action = Posix.TTY.TC.flow_action where type TTY.TC.queue_sel = Posix.TTY.TC.queue_sel where type TTY.TC.set_action = Posix.TTY.TC.set_action where type TTY.V.cc = Posix.TTY.V.cc where type TTY.speed = Posix.TTY.speed where type TTY.termios = Posix.TTY.termios (* @ $(SML_LIB)/basis/libs/basis-2002/top-level/top-level.sml 17.11-17.15 *)
structure Posix.Error: POSIX_ERROR where type syserror = OS.syserror (* @ $(SML_LIB)/basis/posix/posix.sml 11.17-11.21 *)
type Posix.Error.syserror = OS.syserror (* @ $(SML_LIB)/basis/posix/error.sml 15.12-15.19 *)
val Posix.Error.acces: OS.syserror (* @ $(SML_LIB)/basis/posix/error.sml 17.11-17.15 *)
val Posix.Error.again: OS.syserror (* @ $(SML_LIB)/basis/posix/error.sml 21.11-21.15 *)
val Posix.Error.badf: OS.syserror (* @ $(SML_LIB)/basis/posix/error.sml 23.11-23.14 *)
val Posix.Error.badmsg: OS.syserror (* @ $(SML_LIB)/basis/posix/error.sml 24.11-24.16 *)
val Posix.Error.busy: OS.syserror (* @ $(SML_LIB)/basis/posix/error.sml 25.11-25.14 *)
val Posix.Error.canceled: OS.syserror (* @ $(SML_LIB)/basis/posix/error.sml 26.11-26.18 *)
val Posix.Error.child: OS.syserror (* @ $(SML_LIB)/basis/posix/error.sml 27.11-27.15 *)
val Posix.Error.deadlk: OS.syserror (* @ $(SML_LIB)/basis/posix/error.sml 31.11-31.16 *)
val Posix.Error.dom: OS.syserror (* @ $(SML_LIB)/basis/posix/error.sml 33.11-33.13 *)
val Posix.Error.errorMsg: OS.syserror -> string (* @ $(SML_LIB)/basis/posix/error.sml 214.11-214.18 *)
val Posix.Error.errorName: OS.syserror -> string (* @ $(SML_LIB)/basis/posix/error.sml 193.11-193.19 *)
val Posix.Error.exist: OS.syserror (* @ $(SML_LIB)/basis/posix/error.sml 35.11-35.15 *)
val Posix.Error.fault: OS.syserror (* @ $(SML_LIB)/basis/posix/error.sml 36.11-36.15 *)
val Posix.Error.fbig: OS.syserror (* @ $(SML_LIB)/basis/posix/error.sml 37.11-37.14 *)
val Posix.Error.fromWord: LargeWord.word -> OS.syserror (* @ $(SML_LIB)/basis/posix/error.sml 189.11-189.18 *)
val Posix.Error.inprogress: OS.syserror (* @ $(SML_LIB)/basis/posix/error.sml 41.11-41.20 *)
val Posix.Error.intr: OS.syserror (* @ $(SML_LIB)/basis/posix/error.sml 42.11-42.14 *)
val Posix.Error.inval: OS.syserror (* @ $(SML_LIB)/basis/posix/error.sml 43.11-43.15 *)
val Posix.Error.io: OS.syserror (* @ $(SML_LIB)/basis/posix/error.sml 44.11-44.12 *)
val Posix.Error.isdir: OS.syserror (* @ $(SML_LIB)/basis/posix/error.sml 46.11-46.15 *)
val Posix.Error.loop: OS.syserror (* @ $(SML_LIB)/basis/posix/error.sml 47.11-47.14 *)
val Posix.Error.mfile: OS.syserror (* @ $(SML_LIB)/basis/posix/error.sml 48.11-48.15 *)
val Posix.Error.mlink: OS.syserror (* @ $(SML_LIB)/basis/posix/error.sml 49.11-49.15 *)
val Posix.Error.msgsize: OS.syserror (* @ $(SML_LIB)/basis/posix/error.sml 50.11-50.17 *)
val Posix.Error.nametoolong: OS.syserror (* @ $(SML_LIB)/basis/posix/error.sml 52.11-52.21 *)
val Posix.Error.nfile: OS.syserror (* @ $(SML_LIB)/basis/posix/error.sml 56.11-56.15 *)
val Posix.Error.nodev: OS.syserror (* @ $(SML_LIB)/basis/posix/error.sml 59.11-59.15 *)
val Posix.Error.noent: OS.syserror (* @ $(SML_LIB)/basis/posix/error.sml 60.11-60.15 *)
val Posix.Error.noexec: OS.syserror (* @ $(SML_LIB)/basis/posix/error.sml 61.11-61.16 *)
val Posix.Error.nolck: OS.syserror (* @ $(SML_LIB)/basis/posix/error.sml 62.11-62.15 *)
val Posix.Error.nomem: OS.syserror (* @ $(SML_LIB)/basis/posix/error.sml 64.11-64.15 *)
val Posix.Error.nospc: OS.syserror (* @ $(SML_LIB)/basis/posix/error.sml 67.11-67.15 *)
val Posix.Error.nosys: OS.syserror (* @ $(SML_LIB)/basis/posix/error.sml 70.11-70.15 *)
val Posix.Error.notdir: OS.syserror (* @ $(SML_LIB)/basis/posix/error.sml 72.11-72.16 *)
val Posix.Error.notempty: OS.syserror (* @ $(SML_LIB)/basis/posix/error.sml 73.11-73.18 *)
val Posix.Error.notsup: OS.syserror (* @ $(SML_LIB)/basis/posix/error.sml 75.11-75.16 *)
val Posix.Error.notty: OS.syserror (* @ $(SML_LIB)/basis/posix/error.sml 76.11-76.15 *)
val Posix.Error.nxio: OS.syserror (* @ $(SML_LIB)/basis/posix/error.sml 77.11-77.14 *)
val Posix.Error.perm: OS.syserror (* @ $(SML_LIB)/basis/posix/error.sml 80.11-80.14 *)
val Posix.Error.pipe: OS.syserror (* @ $(SML_LIB)/basis/posix/error.sml 81.11-81.14 *)
val Posix.Error.range: OS.syserror (* @ $(SML_LIB)/basis/posix/error.sml 85.11-85.15 *)
val Posix.Error.rofs: OS.syserror (* @ $(SML_LIB)/basis/posix/error.sml 86.11-86.14 *)
val Posix.Error.spipe: OS.syserror (* @ $(SML_LIB)/basis/posix/error.sml 87.11-87.15 *)
val Posix.Error.srch: OS.syserror (* @ $(SML_LIB)/basis/posix/error.sml 88.11-88.14 *)
val Posix.Error.syserror: string -> OS.syserror option (* @ $(SML_LIB)/basis/posix/error.sml 209.11-209.18 *)
val Posix.Error.toWord: OS.syserror -> LargeWord.word (* @ $(SML_LIB)/basis/posix/error.sml 188.11-188.16 *)
val Posix.Error.toobig: OS.syserror (* @ $(SML_LIB)/basis/posix/error.sml 92.11-92.16 *)
val Posix.Error.xdev: OS.syserror (* @ $(SML_LIB)/basis/posix/error.sml 95.11-95.14 *)
structure Posix.FileSys: POSIX_FILE_SYS where type O.flags = Posix.FileSys.O.flags where type S.mode = Posix.FileSys.S.mode where type ST.stat = Posix.FileSys.ST.stat where type access_mode = OS.FileSys.access_mode where type dev = Posix.FileSys.dev where type dirstream = OS.FileSys.dirstream where type file_desc = Posix.TTY.file_desc where type gid = Posix.SysDB.gid where type ino = Posix.FileSys.ino where type open_mode = Posix.IO.open_mode where type uid = Posix.SysDB.uid (* @ $(SML_LIB)/basis/posix/posix.sml 19.17-19.23 *)
datatype Posix.FileSys.access_mode = A_EXEC | A_READ | A_WRITE (* = datatype OS.FileSys.access_mode *) (* @ $(SML_LIB)/basis/posix/file-sys.sml 376.16-376.26 *)
type Posix.FileSys.dev = Posix.FileSys.dev (* @ $(SML_LIB)/basis/posix/file-sys.sml 305.12-305.14 *)
type Posix.FileSys.dirstream = OS.FileSys.dirstream (* @ $(SML_LIB)/basis/posix/file-sys.sml 60.15-60.23 *)
type Posix.FileSys.file_desc = Posix.TTY.file_desc (* @ $(SML_LIB)/basis/posix/file-sys.sml 37.12-37.20 *)
type Posix.FileSys.gid = Posix.SysDB.gid (* @ $(SML_LIB)/basis/posix/file-sys.sml 38.12-38.14 *)
type Posix.FileSys.ino = Posix.FileSys.ino (* @ $(SML_LIB)/basis/posix/file-sys.sml 309.12-309.14 *)
datatype Posix.FileSys.open_mode = O_RDONLY | O_RDWR | O_WRONLY (* = datatype Posix.IO.open_mode *) (* @ $(SML_LIB)/basis/posix/file-sys.sml 210.16-210.24 *)
type Posix.FileSys.uid = Posix.SysDB.uid (* @ $(SML_LIB)/basis/posix/file-sys.sml 39.12-39.14 *)
con Posix.FileSys.A_EXEC: OS.FileSys.access_mode (* @ $(SML_LIB)/basis/posix/file-sys.sml 376.49-376.54 *)
con Posix.FileSys.A_READ: OS.FileSys.access_mode (* @ $(SML_LIB)/basis/posix/file-sys.sml 376.30-376.35 *)
con Posix.FileSys.A_WRITE: OS.FileSys.access_mode (* @ $(SML_LIB)/basis/posix/file-sys.sml 376.39-376.45 *)
con Posix.FileSys.O_RDONLY: Posix.IO.open_mode (* @ $(SML_LIB)/basis/posix/file-sys.sml 210.28-210.35 *)
con Posix.FileSys.O_RDWR: Posix.IO.open_mode (* @ $(SML_LIB)/basis/posix/file-sys.sml 210.50-210.55 *)
con Posix.FileSys.O_WRONLY: Posix.IO.open_mode (* @ $(SML_LIB)/basis/posix/file-sys.sml 210.39-210.46 *)
val Posix.FileSys.access: string * OS.FileSys.access_mode list -> bool (* @ $(SML_LIB)/basis/posix/file-sys.sml 383.11-383.16 *)
val Posix.FileSys.chdir: string -> unit (* @ $(SML_LIB)/basis/posix/file-sys.sml 114.11-114.15 *)
val Posix.FileSys.chmod: string * Posix.FileSys.S.mode -> unit (* @ $(SML_LIB)/basis/posix/file-sys.sml 268.14-268.18 *)
val Posix.FileSys.chown: string * Posix.SysDB.uid * Posix.SysDB.gid -> unit (* @ $(SML_LIB)/basis/posix/file-sys.sml 276.14-276.18 *)
val Posix.FileSys.closedir: OS.FileSys.dirstream -> unit (* @ $(SML_LIB)/basis/posix/file-sys.sml 108.14-108.21 *)
val Posix.FileSys.creat: string * Posix.FileSys.S.mode -> Posix.TTY.file_desc (* @ $(SML_LIB)/basis/posix/file-sys.sml 249.11-249.15 *)
val Posix.FileSys.createf: string * Posix.IO.open_mode * Posix.FileSys.O.flags * Posix.FileSys.S.mode -> Posix.TTY.file_desc (* @ $(SML_LIB)/basis/posix/file-sys.sml 223.11-223.17 *)
val Posix.FileSys.devToWord: Posix.FileSys.dev -> LargeWord.word (* @ $(SML_LIB)/basis/posix/file-sys.sml 307.11-307.19 *)
val Posix.FileSys.fchmod: Posix.TTY.file_desc * Posix.FileSys.S.mode -> unit (* @ $(SML_LIB)/basis/posix/file-sys.sml 272.14-272.19 *)
val Posix.FileSys.fchown: Posix.TTY.file_desc * Posix.SysDB.uid * Posix.SysDB.gid -> unit (* @ $(SML_LIB)/basis/posix/file-sys.sml 280.14-280.19 *)
val Posix.FileSys.fdToIOD: Posix.TTY.file_desc -> OS.IO.iodesc (* @ $(SML_LIB)/basis/posix/file-sys.sml 44.11-44.17 *)
val Posix.FileSys.fdToWord: Posix.TTY.file_desc -> LargeWord.word (* @ $(SML_LIB)/basis/posix/file-sys.sml 41.11-41.18 *)
val Posix.FileSys.fpathconf: Posix.TTY.file_desc * string -> LargeWord.word option (* @ $(SML_LIB)/basis/posix/file-sys.sml 471.14-471.22 *)
val Posix.FileSys.fstat: Posix.TTY.file_desc -> Posix.FileSys.ST.stat (* @ $(SML_LIB)/basis/posix/file-sys.sml 373.14-373.18 *)
val Posix.FileSys.ftruncate: Posix.TTY.file_desc * Int64.int -> unit (* @ $(SML_LIB)/basis/posix/file-sys.sml 284.14-284.22 *)
val Posix.FileSys.getcwd: unit -> string (* @ $(SML_LIB)/basis/posix/file-sys.sml 138.14-138.19 *)
val Posix.FileSys.inoToWord: Posix.FileSys.ino -> LargeWord.word (* @ $(SML_LIB)/basis/posix/file-sys.sml 311.11-311.19 *)
val Posix.FileSys.iodToFD: OS.IO.iodesc -> Posix.TTY.file_desc option (* @ $(SML_LIB)/basis/posix/file-sys.sml 45.11-45.17 *)
val Posix.FileSys.link: {new: string, old: string} -> unit (* @ $(SML_LIB)/basis/posix/file-sys.sml 261.14-261.17 *)
val Posix.FileSys.lstat: string -> Posix.FileSys.ST.stat (* @ $(SML_LIB)/basis/posix/file-sys.sml 372.14-372.18 *)
val Posix.FileSys.mkdir: string * Posix.FileSys.S.mode -> unit (* @ $(SML_LIB)/basis/posix/file-sys.sml 262.14-262.18 *)
val Posix.FileSys.mkfifo: string * Posix.FileSys.S.mode -> unit (* @ $(SML_LIB)/basis/posix/file-sys.sml 263.14-263.19 *)
val Posix.FileSys.opendir: string -> OS.FileSys.dirstream (* @ $(SML_LIB)/basis/posix/file-sys.sml 62.14-62.20 *)
val Posix.FileSys.openf: string * Posix.IO.open_mode * Posix.FileSys.O.flags -> Posix.TTY.file_desc (* @ $(SML_LIB)/basis/posix/file-sys.sml 237.11-237.15 *)
val Posix.FileSys.pathconf: string * string -> LargeWord.word option (* @ $(SML_LIB)/basis/posix/file-sys.sml 470.14-470.21 *)
val Posix.FileSys.readdir: OS.FileSys.dirstream -> string option (* @ $(SML_LIB)/basis/posix/file-sys.sml 72.14-72.20 *)
val Posix.FileSys.readlink: string -> string (* @ $(SML_LIB)/basis/posix/file-sys.sml 294.14-294.21 *)
val Posix.FileSys.rename: {new: string, old: string} -> unit (* @ $(SML_LIB)/basis/posix/file-sys.sml 266.14-266.19 *)
val Posix.FileSys.rewinddir: OS.FileSys.dirstream -> unit (* @ $(SML_LIB)/basis/posix/file-sys.sml 103.14-103.22 *)
val Posix.FileSys.rmdir: string -> unit (* @ $(SML_LIB)/basis/posix/file-sys.sml 265.14-265.18 *)
val Posix.FileSys.stat: string -> Posix.FileSys.ST.stat (* @ $(SML_LIB)/basis/posix/file-sys.sml 371.14-371.17 *)
val Posix.FileSys.stderr: Posix.TTY.file_desc (* @ $(SML_LIB)/basis/posix/file-sys.sml 158.11-158.16 *)
val Posix.FileSys.stdin: Posix.TTY.file_desc (* @ $(SML_LIB)/basis/posix/file-sys.sml 156.11-156.15 *)
val Posix.FileSys.stdout: Posix.TTY.file_desc (* @ $(SML_LIB)/basis/posix/file-sys.sml 157.11-157.16 *)
val Posix.FileSys.symlink: {new: string, old: string} -> unit (* @ $(SML_LIB)/basis/posix/file-sys.sml 267.14-267.20 *)
val Posix.FileSys.umask: Posix.FileSys.S.mode -> Posix.FileSys.S.mode (* @ $(SML_LIB)/basis/posix/file-sys.sml 251.11-251.15 *)
val Posix.FileSys.unlink: string -> unit (* @ $(SML_LIB)/basis/posix/file-sys.sml 264.14-264.19 *)
val Posix.FileSys.utime: string * {actime: Time.time, modtime: Time.time} option -> unit (* @ $(SML_LIB)/basis/posix/file-sys.sml 403.14-403.18 *)
val Posix.FileSys.wordToDev: LargeWord.word -> Posix.FileSys.dev (* @ $(SML_LIB)/basis/posix/file-sys.sml 306.11-306.19 *)
val Posix.FileSys.wordToFD: LargeWord.word -> Posix.TTY.file_desc (* @ $(SML_LIB)/basis/posix/file-sys.sml 42.11-42.18 *)
val Posix.FileSys.wordToIno: LargeWord.word -> Posix.FileSys.ino (* @ $(SML_LIB)/basis/posix/file-sys.sml 310.11-310.19 *)
structure Posix.FileSys.O:
   sig
      type flags = Posix.FileSys.O.flags
      val all: Posix.FileSys.O.flags
      val allSet: Posix.FileSys.O.flags * Posix.FileSys.O.flags -> bool
      val anySet: Posix.FileSys.O.flags * Posix.FileSys.O.flags -> bool
      val append: Posix.FileSys.O.flags
      val clear: Posix.FileSys.O.flags * Posix.FileSys.O.flags -> Posix.FileSys.O.flags
      val excl: Posix.FileSys.O.flags
      val flags: Posix.FileSys.O.flags list -> Posix.FileSys.O.flags
      val fromWord: LargeWord.word -> Posix.FileSys.O.flags
      val intersect: Posix.FileSys.O.flags list -> Posix.FileSys.O.flags
      val noctty: Posix.FileSys.O.flags
      val nonblock: Posix.FileSys.O.flags
      val sync: Posix.FileSys.O.flags
      val toWord: Posix.FileSys.O.flags -> LargeWord.word
      val trunc: Posix.FileSys.O.flags
   end
   (* @ $(SML_LIB)/basis/posix/file-sys.sml 190.17-190.17 *)
type Posix.FileSys.O.flags = Posix.FileSys.O.flags (* @ $(SML_LIB)/basis/posix/flags.sml 18.12-18.16 *)
val Posix.FileSys.O.all: Posix.FileSys.O.flags (* @ $(SML_LIB)/basis/posix/flags.sml 20.11-20.13 *)
val Posix.FileSys.O.allSet: Posix.FileSys.O.flags * Posix.FileSys.O.flags -> bool (* @ $(SML_LIB)/basis/posix/flags.sml 32.11-32.16 *)
val Posix.FileSys.O.anySet: Posix.FileSys.O.flags * Posix.FileSys.O.flags -> bool (* @ $(SML_LIB)/basis/posix/flags.sml 34.11-34.16 *)
val Posix.FileSys.O.append: Posix.FileSys.O.flags (* @ $(SML_LIB)/basis/posix/file-sys.sml 194.17-194.22 *)
val Posix.FileSys.O.clear: Posix.FileSys.O.flags * Posix.FileSys.O.flags -> Posix.FileSys.O.flags (* @ $(SML_LIB)/basis/posix/flags.sml 30.11-30.15 *)
val Posix.FileSys.O.excl: Posix.FileSys.O.flags (* @ $(SML_LIB)/basis/posix/file-sys.sml 198.17-198.20 *)
val Posix.FileSys.O.flags: Posix.FileSys.O.flags list -> Posix.FileSys.O.flags (* @ $(SML_LIB)/basis/posix/flags.sml 26.11-26.15 *)
val Posix.FileSys.O.fromWord: LargeWord.word -> Posix.FileSys.O.flags (* @ $(SML_LIB)/basis/posix/flags.sml 24.11-24.18 *)
val Posix.FileSys.O.intersect: Posix.FileSys.O.flags list -> Posix.FileSys.O.flags (* @ $(SML_LIB)/basis/posix/flags.sml 28.11-28.19 *)
val Posix.FileSys.O.noctty: Posix.FileSys.O.flags (* @ $(SML_LIB)/basis/posix/file-sys.sml 199.17-199.22 *)
val Posix.FileSys.O.nonblock: Posix.FileSys.O.flags (* @ $(SML_LIB)/basis/posix/file-sys.sml 200.17-200.24 *)
val Posix.FileSys.O.sync: Posix.FileSys.O.flags (* @ $(SML_LIB)/basis/posix/file-sys.sml 204.17-204.20 *)
val Posix.FileSys.O.toWord: Posix.FileSys.O.flags -> LargeWord.word (* @ $(SML_LIB)/basis/posix/flags.sml 23.11-23.16 *)
val Posix.FileSys.O.trunc: Posix.FileSys.O.flags (* @ $(SML_LIB)/basis/posix/file-sys.sml 206.17-206.21 *)
structure Posix.FileSys.S:
   sig
      type flags = Posix.FileSys.S.mode
      type mode = Posix.FileSys.S.mode
      val all: Posix.FileSys.S.mode
      val allSet: Posix.FileSys.S.mode * Posix.FileSys.S.mode -> bool
      val anySet: Posix.FileSys.S.mode * Posix.FileSys.S.mode -> bool
      val clear: Posix.FileSys.S.mode * Posix.FileSys.S.mode -> Posix.FileSys.S.mode
      val flags: Posix.FileSys.S.mode list -> Posix.FileSys.S.mode
      val fromWord: LargeWord.word -> Posix.FileSys.S.mode
      val intersect: Posix.FileSys.S.mode list -> Posix.FileSys.S.mode
      val irgrp: Posix.FileSys.S.mode
      val iroth: Posix.FileSys.S.mode
      val irusr: Posix.FileSys.S.mode
      val irwxg: Posix.FileSys.S.mode
      val irwxo: Posix.FileSys.S.mode
      val irwxu: Posix.FileSys.S.mode
      val isgid: Posix.FileSys.S.mode
      val isuid: Posix.FileSys.S.mode
      val iwgrp: Posix.FileSys.S.mode
      val iwoth: Posix.FileSys.S.mode
      val iwusr: Posix.FileSys.S.mode
      val ixgrp: Posix.FileSys.S.mode
      val ixoth: Posix.FileSys.S.mode
      val ixusr: Posix.FileSys.S.mode
      val toWord: Posix.FileSys.S.mode -> LargeWord.word
   end
   (* @ $(SML_LIB)/basis/posix/file-sys.sml 160.17-160.17 *)
type Posix.FileSys.S.flags = Posix.FileSys.S.mode (* @ $(SML_LIB)/basis/posix/flags.sml 18.12-18.16 *)
type Posix.FileSys.S.mode = Posix.FileSys.S.mode (* @ $(SML_LIB)/basis/posix/file-sys.sml 164.18-164.21 *)
val Posix.FileSys.S.all: Posix.FileSys.S.mode (* @ $(SML_LIB)/basis/posix/flags.sml 20.11-20.13 *)
val Posix.FileSys.S.allSet: Posix.FileSys.S.mode * Posix.FileSys.S.mode -> bool (* @ $(SML_LIB)/basis/posix/flags.sml 32.11-32.16 *)
val Posix.FileSys.S.anySet: Posix.FileSys.S.mode * Posix.FileSys.S.mode -> bool (* @ $(SML_LIB)/basis/posix/flags.sml 34.11-34.16 *)
val Posix.FileSys.S.clear: Posix.FileSys.S.mode * Posix.FileSys.S.mode -> Posix.FileSys.S.mode (* @ $(SML_LIB)/basis/posix/flags.sml 30.11-30.15 *)
val Posix.FileSys.S.flags: Posix.FileSys.S.mode list -> Posix.FileSys.S.mode (* @ $(SML_LIB)/basis/posix/flags.sml 26.11-26.15 *)
val Posix.FileSys.S.fromWord: LargeWord.word -> Posix.FileSys.S.mode (* @ $(SML_LIB)/basis/posix/flags.sml 24.11-24.18 *)
val Posix.FileSys.S.intersect: Posix.FileSys.S.mode list -> Posix.FileSys.S.mode (* @ $(SML_LIB)/basis/posix/flags.sml 28.11-28.19 *)
val Posix.FileSys.S.irgrp: Posix.FileSys.S.mode (* @ $(SML_LIB)/basis/posix/file-sys.sml 173.17-173.21 *)
val Posix.FileSys.S.iroth: Posix.FileSys.S.mode (* @ $(SML_LIB)/basis/posix/file-sys.sml 174.17-174.21 *)
val Posix.FileSys.S.irusr: Posix.FileSys.S.mode (* @ $(SML_LIB)/basis/posix/file-sys.sml 175.17-175.21 *)
val Posix.FileSys.S.irwxg: Posix.FileSys.S.mode (* @ $(SML_LIB)/basis/posix/file-sys.sml 176.17-176.21 *)
val Posix.FileSys.S.irwxo: Posix.FileSys.S.mode (* @ $(SML_LIB)/basis/posix/file-sys.sml 177.17-177.21 *)
val Posix.FileSys.S.irwxu: Posix.FileSys.S.mode (* @ $(SML_LIB)/basis/posix/file-sys.sml 178.17-178.21 *)
val Posix.FileSys.S.isgid: Posix.FileSys.S.mode (* @ $(SML_LIB)/basis/posix/file-sys.sml 179.17-179.21 *)
val Posix.FileSys.S.isuid: Posix.FileSys.S.mode (* @ $(SML_LIB)/basis/posix/file-sys.sml 180.17-180.21 *)
val Posix.FileSys.S.iwgrp: Posix.FileSys.S.mode (* @ $(SML_LIB)/basis/posix/file-sys.sml 182.17-182.21 *)
val Posix.FileSys.S.iwoth: Posix.FileSys.S.mode (* @ $(SML_LIB)/basis/posix/file-sys.sml 183.17-183.21 *)
val Posix.FileSys.S.iwusr: Posix.FileSys.S.mode (* @ $(SML_LIB)/basis/posix/file-sys.sml 184.17-184.21 *)
val Posix.FileSys.S.ixgrp: Posix.FileSys.S.mode (* @ $(SML_LIB)/basis/posix/file-sys.sml 185.17-185.21 *)
val Posix.FileSys.S.ixoth: Posix.FileSys.S.mode (* @ $(SML_LIB)/basis/posix/file-sys.sml 186.17-186.21 *)
val Posix.FileSys.S.ixusr: Posix.FileSys.S.mode (* @ $(SML_LIB)/basis/posix/file-sys.sml 187.17-187.21 *)
val Posix.FileSys.S.toWord: Posix.FileSys.S.mode -> LargeWord.word (* @ $(SML_LIB)/basis/posix/flags.sml 23.11-23.16 *)
structure Posix.FileSys.ST:
   sig
      type stat = Posix.FileSys.ST.stat
      val atime: Posix.FileSys.ST.stat -> Time.time
      val ctime: Posix.FileSys.ST.stat -> Time.time
      val dev: Posix.FileSys.ST.stat -> Posix.FileSys.dev
      val gid: Posix.FileSys.ST.stat -> Posix.SysDB.gid
      val ino: Posix.FileSys.ST.stat -> Posix.FileSys.ino
      val isBlk: Posix.FileSys.ST.stat -> bool
      val isChr: Posix.FileSys.ST.stat -> bool
      val isDir: Posix.FileSys.ST.stat -> bool
      val isFIFO: Posix.FileSys.ST.stat -> bool
      val isLink: Posix.FileSys.ST.stat -> bool
      val isReg: Posix.FileSys.ST.stat -> bool
      val isSock: Posix.FileSys.ST.stat -> bool
      val mode: Posix.FileSys.ST.stat -> Posix.FileSys.S.mode
      val mtime: Posix.FileSys.ST.stat -> Time.time
      val nlink: Posix.FileSys.ST.stat -> int
      val size: Posix.FileSys.ST.stat -> Int64.int
      val uid: Posix.FileSys.ST.stat -> Posix.SysDB.uid
   end
   (* @ $(SML_LIB)/basis/posix/file-sys.sml 313.17-313.18 *)
type Posix.FileSys.ST.stat = Posix.FileSys.ST.stat (* @ $(SML_LIB)/basis/posix/file-sys.sml 315.22-315.25 *)
val Posix.FileSys.ST.atime: Posix.FileSys.ST.stat -> Time.time (* @ $(SML_LIB)/basis/posix/file-sys.sml 349.20-349.24 *)
val Posix.FileSys.ST.ctime: Posix.FileSys.ST.stat -> Time.time (* @ $(SML_LIB)/basis/posix/file-sys.sml 351.20-351.24 *)
val Posix.FileSys.ST.dev: Posix.FileSys.ST.stat -> Posix.FileSys.dev (* @ $(SML_LIB)/basis/posix/file-sys.sml 344.20-344.22 *)
val Posix.FileSys.ST.gid: Posix.FileSys.ST.stat -> Posix.SysDB.gid (* @ $(SML_LIB)/basis/posix/file-sys.sml 347.20-347.22 *)
val Posix.FileSys.ST.ino: Posix.FileSys.ST.stat -> Posix.FileSys.ino (* @ $(SML_LIB)/basis/posix/file-sys.sml 343.20-343.22 *)
val Posix.FileSys.ST.isBlk: Posix.FileSys.ST.stat -> bool (* @ $(SML_LIB)/basis/posix/file-sys.sml 359.20-359.24 *)
val Posix.FileSys.ST.isChr: Posix.FileSys.ST.stat -> bool (* @ $(SML_LIB)/basis/posix/file-sys.sml 358.20-358.24 *)
val Posix.FileSys.ST.isDir: Posix.FileSys.ST.stat -> bool (* @ $(SML_LIB)/basis/posix/file-sys.sml 357.20-357.24 *)
val Posix.FileSys.ST.isFIFO: Posix.FileSys.ST.stat -> bool (* @ $(SML_LIB)/basis/posix/file-sys.sml 361.20-361.25 *)
val Posix.FileSys.ST.isLink: Posix.FileSys.ST.stat -> bool (* @ $(SML_LIB)/basis/posix/file-sys.sml 362.20-362.25 *)
val Posix.FileSys.ST.isReg: Posix.FileSys.ST.stat -> bool (* @ $(SML_LIB)/basis/posix/file-sys.sml 360.20-360.24 *)
val Posix.FileSys.ST.isSock: Posix.FileSys.ST.stat -> bool (* @ $(SML_LIB)/basis/posix/file-sys.sml 363.20-363.25 *)
val Posix.FileSys.ST.mode: Posix.FileSys.ST.stat -> Posix.FileSys.S.mode (* @ $(SML_LIB)/basis/posix/file-sys.sml 342.20-342.23 *)
val Posix.FileSys.ST.mtime: Posix.FileSys.ST.stat -> Time.time (* @ $(SML_LIB)/basis/posix/file-sys.sml 350.20-350.24 *)
val Posix.FileSys.ST.nlink: Posix.FileSys.ST.stat -> int (* @ $(SML_LIB)/basis/posix/file-sys.sml 345.20-345.24 *)
val Posix.FileSys.ST.size: Posix.FileSys.ST.stat -> Int64.int (* @ $(SML_LIB)/basis/posix/file-sys.sml 348.20-348.23 *)
val Posix.FileSys.ST.uid: Posix.FileSys.ST.stat -> Posix.SysDB.uid (* @ $(SML_LIB)/basis/posix/file-sys.sml 346.20-346.22 *)
structure Posix.IO: POSIX_IO where type FD.flags = Posix.IO.FD.flags where type FLock.flock = Posix.IO.FLock.flock where type O.flags = Posix.IO.O.flags where type file_desc = Posix.TTY.file_desc where type lock_type = Posix.IO.lock_type where type open_mode = Posix.IO.open_mode where type pid = Posix.TTY.pid where type whence = Posix.IO.whence (* @ $(SML_LIB)/basis/posix/posix.sml 21.17-21.18 *)
type Posix.IO.file_desc = Posix.TTY.file_desc (* @ $(SML_LIB)/basis/posix/io.sml 22.6-22.14 *)
datatype Posix.IO.lock_type = F_RDLCK | F_UNLCK | F_WRLCK (* = datatype Posix.IO.lock_type *) (* @ $(SML_LIB)/basis/posix/io.sml 115.10-115.18 *)
datatype Posix.IO.open_mode = O_RDONLY | O_RDWR | O_WRONLY (* = datatype Posix.IO.open_mode *) (* @ $(SML_LIB)/basis/posix/io.sml 58.10-58.18 *)
type Posix.IO.pid = Posix.TTY.pid (* @ $(SML_LIB)/basis/posix/io.sml 23.6-23.8 *)
datatype Posix.IO.whence = SEEK_CUR | SEEK_END | SEEK_SET (* = datatype Posix.IO.whence *) (* @ $(SML_LIB)/basis/posix/io.sml 85.10-85.15 *)
con Posix.IO.F_RDLCK: Posix.IO.lock_type (* @ $(SML_LIB)/basis/posix/io.sml 115.22-115.28 *)
con Posix.IO.F_UNLCK: Posix.IO.lock_type (* @ $(SML_LIB)/basis/posix/io.sml 115.42-115.48 *)
con Posix.IO.F_WRLCK: Posix.IO.lock_type (* @ $(SML_LIB)/basis/posix/io.sml 115.32-115.38 *)
con Posix.IO.O_RDONLY: Posix.IO.open_mode (* @ $(SML_LIB)/basis/posix/file-sys.sml 210.28-210.35 *)
con Posix.IO.O_RDWR: Posix.IO.open_mode (* @ $(SML_LIB)/basis/posix/file-sys.sml 210.50-210.55 *)
con Posix.IO.O_WRONLY: Posix.IO.open_mode (* @ $(SML_LIB)/basis/posix/file-sys.sml 210.39-210.46 *)
con Posix.IO.SEEK_CUR: Posix.IO.whence (* @ $(SML_LIB)/basis/posix/io.sml 85.30-85.37 *)
con Posix.IO.SEEK_END: Posix.IO.whence (* @ $(SML_LIB)/basis/posix/io.sml 85.41-85.48 *)
con Posix.IO.SEEK_SET: Posix.IO.whence (* @ $(SML_LIB)/basis/posix/io.sml 85.19-85.26 *)
val Posix.IO.close: Posix.TTY.file_desc -> unit (* @ $(SML_LIB)/basis/posix/io.sml 45.5-45.9 *)
val Posix.IO.dup: Posix.TTY.file_desc -> Posix.TTY.file_desc (* @ $(SML_LIB)/basis/posix/io.sml 37.5-37.7 *)
val Posix.IO.dup2: {new: Posix.TTY.file_desc, old: Posix.TTY.file_desc} -> unit (* @ $(SML_LIB)/basis/posix/io.sml 41.5-41.8 *)
val Posix.IO.dupfd: {base: Posix.TTY.file_desc, old: Posix.TTY.file_desc} -> Posix.TTY.file_desc (* @ $(SML_LIB)/basis/posix/io.sml 60.5-60.9 *)
val Posix.IO.fsync: Posix.TTY.file_desc -> unit (* @ $(SML_LIB)/basis/posix/io.sml 97.5-97.9 *)
val Posix.IO.getfd: Posix.TTY.file_desc -> Posix.IO.FD.flags (* @ $(SML_LIB)/basis/posix/io.sml 64.5-64.9 *)
val Posix.IO.getfl: Posix.TTY.file_desc -> Posix.IO.O.flags * Posix.IO.open_mode (* @ $(SML_LIB)/basis/posix/io.sml 72.5-72.9 *)
val Posix.IO.getlk: Posix.TTY.file_desc * Posix.IO.FLock.flock -> Posix.IO.FLock.flock (* @ $(SML_LIB)/basis/posix/io.sml 169.8-169.12 *)
val Posix.IO.lseek: Posix.TTY.file_desc * Int64.int * Posix.IO.whence -> Int64.int (* @ $(SML_LIB)/basis/posix/io.sml 92.5-92.9 *)
val Posix.IO.mkBinReader: {fd: Posix.TTY.file_desc, initBlkMode: bool, name: string} -> BinPrimIO.reader (* @ $(SML_LIB)/basis/posix/io.sml 402.20-402.30 *)
val Posix.IO.mkBinWriter: {appendMode: bool, chunkSize: int, fd: Posix.TTY.file_desc, initBlkMode: bool, name: string} -> BinPrimIO.writer (* @ $(SML_LIB)/basis/posix/io.sml 402.44-402.54 *)
val Posix.IO.mkTextReader: {fd: Posix.TTY.file_desc, initBlkMode: bool, name: string} -> TextPrimIO.reader (* @ $(SML_LIB)/basis/posix/io.sml 414.20-414.31 *)
val Posix.IO.mkTextWriter: {appendMode: bool, chunkSize: int, fd: Posix.TTY.file_desc, initBlkMode: bool, name: string} -> TextPrimIO.writer (* @ $(SML_LIB)/basis/posix/io.sml 414.45-414.56 *)
val Posix.IO.pipe: unit -> {infd: Posix.TTY.file_desc, outfd: Posix.TTY.file_desc} (* @ $(SML_LIB)/basis/posix/io.sml 29.8-29.11 *)
val Posix.IO.readArr: Posix.TTY.file_desc * Word8ArraySlice.slice -> int (* @ $(SML_LIB)/basis/posix/io.sml 403.9-403.15 *)
val Posix.IO.readVec: Posix.TTY.file_desc * int -> Word8Vector.vector (* @ $(SML_LIB)/basis/posix/io.sml 403.18-403.24 *)
val Posix.IO.setfd: Posix.TTY.file_desc * Posix.IO.FD.flags -> unit (* @ $(SML_LIB)/basis/posix/io.sml 68.5-68.9 *)
val Posix.IO.setfl: Posix.TTY.file_desc * Posix.IO.O.flags -> unit (* @ $(SML_LIB)/basis/posix/io.sml 81.5-81.9 *)
val Posix.IO.setlk: Posix.TTY.file_desc * Posix.IO.FLock.flock -> Posix.IO.FLock.flock (* @ $(SML_LIB)/basis/posix/io.sml 170.8-170.12 *)
val Posix.IO.setlkw: Posix.TTY.file_desc * Posix.IO.FLock.flock -> Posix.IO.FLock.flock (* @ $(SML_LIB)/basis/posix/io.sml 171.8-171.13 *)
val Posix.IO.writeArr: Posix.TTY.file_desc * Word8ArraySlice.slice -> int (* @ $(SML_LIB)/basis/posix/io.sml 403.27-403.34 *)
val Posix.IO.writeVec: Posix.TTY.file_desc * Word8VectorSlice.slice -> int (* @ $(SML_LIB)/basis/posix/io.sml 403.37-403.44 *)
structure Posix.IO.FD:
   sig
      type flags = Posix.IO.FD.flags
      val all: Posix.IO.FD.flags
      val allSet: Posix.IO.FD.flags * Posix.IO.FD.flags -> bool
      val anySet: Posix.IO.FD.flags * Posix.IO.FD.flags -> bool
      val clear: Posix.IO.FD.flags * Posix.IO.FD.flags -> Posix.IO.FD.flags
      val cloexec: Posix.IO.FD.flags
      val flags: Posix.IO.FD.flags list -> Posix.IO.FD.flags
      val fromWord: LargeWord.word -> Posix.IO.FD.flags
      val intersect: Posix.IO.FD.flags list -> Posix.IO.FD.flags
      val toWord: Posix.IO.FD.flags -> LargeWord.word
   end
   (* @ $(SML_LIB)/basis/posix/io.sml 49.11-49.12 *)
type Posix.IO.FD.flags = Posix.IO.FD.flags (* @ $(SML_LIB)/basis/posix/flags.sml 18.12-18.16 *)
val Posix.IO.FD.all: Posix.IO.FD.flags (* @ $(SML_LIB)/basis/posix/flags.sml 20.11-20.13 *)
val Posix.IO.FD.allSet: Posix.IO.FD.flags * Posix.IO.FD.flags -> bool (* @ $(SML_LIB)/basis/posix/flags.sml 32.11-32.16 *)
val Posix.IO.FD.anySet: Posix.IO.FD.flags * Posix.IO.FD.flags -> bool (* @ $(SML_LIB)/basis/posix/flags.sml 34.11-34.16 *)
val Posix.IO.FD.clear: Posix.IO.FD.flags * Posix.IO.FD.flags -> Posix.IO.FD.flags (* @ $(SML_LIB)/basis/posix/flags.sml 30.11-30.15 *)
val Posix.IO.FD.cloexec: Posix.IO.FD.flags (* @ $(SML_LIB)/basis/posix/io.sml 53.11-53.17 *)
val Posix.IO.FD.flags: Posix.IO.FD.flags list -> Posix.IO.FD.flags (* @ $(SML_LIB)/basis/posix/flags.sml 26.11-26.15 *)
val Posix.IO.FD.fromWord: LargeWord.word -> Posix.IO.FD.flags (* @ $(SML_LIB)/basis/posix/flags.sml 24.11-24.18 *)
val Posix.IO.FD.intersect: Posix.IO.FD.flags list -> Posix.IO.FD.flags (* @ $(SML_LIB)/basis/posix/flags.sml 28.11-28.19 *)
val Posix.IO.FD.toWord: Posix.IO.FD.flags -> LargeWord.word (* @ $(SML_LIB)/basis/posix/flags.sml 23.11-23.16 *)
structure Posix.IO.FLock:
   sig
      type flock = Posix.IO.FLock.flock
      val flock: {len: Int64.int, ltype: Posix.IO.lock_type, pid: Posix.TTY.pid option, start: Int64.int, whence: Posix.IO.whence} -> Posix.IO.FLock.flock
      val len: Posix.IO.FLock.flock -> Int64.int
      val ltype: Posix.IO.FLock.flock -> Posix.IO.lock_type
      val pid: Posix.IO.FLock.flock -> Posix.TTY.pid option
      val start: Posix.IO.FLock.flock -> Int64.int
      val whence: Posix.IO.FLock.flock -> Posix.IO.whence
   end
   (* @ $(SML_LIB)/basis/posix/io.sml 131.11-131.15 *)
type Posix.IO.FLock.flock = Posix.IO.FLock.flock (* @ $(SML_LIB)/basis/posix/io.sml 135.12-135.16 *)
val Posix.IO.FLock.flock: {len: Int64.int, ltype: Posix.IO.lock_type, pid: Posix.TTY.pid option, start: Int64.int, whence: Posix.IO.whence} -> Posix.IO.FLock.flock (* @ $(SML_LIB)/basis/posix/io.sml 141.11-141.15 *)
val Posix.IO.FLock.len: Posix.IO.FLock.flock -> Int64.int (* @ $(SML_LIB)/basis/posix/io.sml 145.11-145.13 *)
val Posix.IO.FLock.ltype: Posix.IO.FLock.flock -> Posix.IO.lock_type (* @ $(SML_LIB)/basis/posix/io.sml 142.11-142.15 *)
val Posix.IO.FLock.pid: Posix.IO.FLock.flock -> Posix.TTY.pid option (* @ $(SML_LIB)/basis/posix/io.sml 146.11-146.13 *)
val Posix.IO.FLock.start: Posix.IO.FLock.flock -> Int64.int (* @ $(SML_LIB)/basis/posix/io.sml 144.11-144.15 *)
val Posix.IO.FLock.whence: Posix.IO.FLock.flock -> Posix.IO.whence (* @ $(SML_LIB)/basis/posix/io.sml 143.11-143.16 *)
structure Posix.IO.O:
   sig
      type flags = Posix.IO.O.flags
      val all: Posix.IO.O.flags
      val allSet: Posix.IO.O.flags * Posix.IO.O.flags -> bool
      val anySet: Posix.IO.O.flags * Posix.IO.O.flags -> bool
      val append: Posix.IO.O.flags
      val clear: Posix.IO.O.flags * Posix.IO.O.flags -> Posix.IO.O.flags
      val flags: Posix.IO.O.flags list -> Posix.IO.O.flags
      val fromWord: LargeWord.word -> Posix.IO.O.flags
      val intersect: Posix.IO.O.flags list -> Posix.IO.O.flags
      val nonblock: Posix.IO.O.flags
      val sync: Posix.IO.O.flags
      val toWord: Posix.IO.O.flags -> LargeWord.word
   end
   (* @ $(SML_LIB)/basis/posix/io.sml 56.11-56.11 *)
type Posix.IO.O.flags = Posix.IO.O.flags (* @ $(SML_LIB)/basis/posix/flags.sml 18.12-18.16 *)
val Posix.IO.O.all: Posix.IO.O.flags (* @ $(SML_LIB)/basis/posix/flags.sml 20.11-20.13 *)
val Posix.IO.O.allSet: Posix.IO.O.flags * Posix.IO.O.flags -> bool (* @ $(SML_LIB)/basis/posix/flags.sml 32.11-32.16 *)
val Posix.IO.O.anySet: Posix.IO.O.flags * Posix.IO.O.flags -> bool (* @ $(SML_LIB)/basis/posix/flags.sml 34.11-34.16 *)
val Posix.IO.O.append: Posix.IO.O.flags (* @ $(SML_LIB)/basis/posix/file-sys.sml 194.17-194.22 *)
val Posix.IO.O.clear: Posix.IO.O.flags * Posix.IO.O.flags -> Posix.IO.O.flags (* @ $(SML_LIB)/basis/posix/flags.sml 30.11-30.15 *)
val Posix.IO.O.flags: Posix.IO.O.flags list -> Posix.IO.O.flags (* @ $(SML_LIB)/basis/posix/flags.sml 26.11-26.15 *)
val Posix.IO.O.fromWord: LargeWord.word -> Posix.IO.O.flags (* @ $(SML_LIB)/basis/posix/flags.sml 24.11-24.18 *)
val Posix.IO.O.intersect: Posix.IO.O.flags list -> Posix.IO.O.flags (* @ $(SML_LIB)/basis/posix/flags.sml 28.11-28.19 *)
val Posix.IO.O.nonblock: Posix.IO.O.flags (* @ $(SML_LIB)/basis/posix/file-sys.sml 200.17-200.24 *)
val Posix.IO.O.sync: Posix.IO.O.flags (* @ $(SML_LIB)/basis/posix/file-sys.sml 204.17-204.20 *)
val Posix.IO.O.toWord: Posix.IO.O.flags -> LargeWord.word (* @ $(SML_LIB)/basis/posix/flags.sml 23.11-23.16 *)
structure Posix.ProcEnv: POSIX_PROC_ENV where type file_desc = Posix.TTY.file_desc where type gid = Posix.SysDB.gid where type pid = Posix.TTY.pid where type uid = Posix.SysDB.uid (* @ $(SML_LIB)/basis/posix/posix.sml 17.17-17.23 *)
type Posix.ProcEnv.file_desc = Posix.TTY.file_desc (* @ $(SML_LIB)/basis/posix/proc-env.sml 23.12-23.20 *)
type Posix.ProcEnv.gid = Posix.SysDB.gid (* @ $(SML_LIB)/basis/posix/proc-env.sml 24.12-24.14 *)
type Posix.ProcEnv.pid = Posix.TTY.pid (* @ $(SML_LIB)/basis/posix/proc-env.sml 25.12-25.14 *)
type Posix.ProcEnv.uid = Posix.SysDB.uid (* @ $(SML_LIB)/basis/posix/proc-env.sml 26.12-26.14 *)
val Posix.ProcEnv.ctermid: unit -> string (* @ $(SML_LIB)/basis/posix/proc-env.sml 280.11-280.17 *)
val Posix.ProcEnv.environ: unit -> string list (* @ $(SML_LIB)/basis/posix/proc-env.sml 269.11-269.17 *)
val Posix.ProcEnv.getegid: unit -> Posix.SysDB.gid (* @ $(SML_LIB)/basis/posix/proc-env.sml 37.14-37.20 *)
val Posix.ProcEnv.getenv: string -> string option (* @ $(SML_LIB)/basis/posix/proc-env.sml 271.11-271.16 *)
val Posix.ProcEnv.geteuid: unit -> Posix.SysDB.uid (* @ $(SML_LIB)/basis/posix/proc-env.sml 38.14-38.20 *)
val Posix.ProcEnv.getgid: unit -> Posix.SysDB.gid (* @ $(SML_LIB)/basis/posix/proc-env.sml 39.14-39.19 *)
val Posix.ProcEnv.getgroups: unit -> Posix.SysDB.gid list (* @ $(SML_LIB)/basis/posix/proc-env.sml 55.11-55.19 *)
val Posix.ProcEnv.getlogin: unit -> string (* @ $(SML_LIB)/basis/posix/proc-env.sml 67.11-67.18 *)
val Posix.ProcEnv.getpgrp: unit -> Posix.TTY.pid (* @ $(SML_LIB)/basis/posix/proc-env.sml 36.14-36.20 *)
val Posix.ProcEnv.getpid: unit -> Posix.TTY.pid (* @ $(SML_LIB)/basis/posix/proc-env.sml 40.14-40.19 *)
val Posix.ProcEnv.getppid: unit -> Posix.TTY.pid (* @ $(SML_LIB)/basis/posix/proc-env.sml 41.14-41.20 *)
val Posix.ProcEnv.getuid: unit -> Posix.SysDB.uid (* @ $(SML_LIB)/basis/posix/proc-env.sml 42.14-42.19 *)
val Posix.ProcEnv.gidToWord: Posix.SysDB.gid -> LargeWord.word (* @ $(SML_LIB)/basis/posix/proc-env.sml 30.11-30.19 *)
val Posix.ProcEnv.isatty: Posix.TTY.file_desc -> bool (* @ $(SML_LIB)/basis/posix/proc-env.sml 282.11-282.16 *)
val Posix.ProcEnv.setgid: Posix.SysDB.gid -> unit (* @ $(SML_LIB)/basis/posix/proc-env.sml 43.14-43.19 *)
val Posix.ProcEnv.setpgid: {pgid: Posix.TTY.pid option, pid: Posix.TTY.pid option} -> unit (* @ $(SML_LIB)/basis/posix/proc-env.sml 73.11-73.17 *)
val Posix.ProcEnv.setsid: unit -> Posix.TTY.pid (* @ $(SML_LIB)/basis/posix/proc-env.sml 51.11-51.16 *)
val Posix.ProcEnv.setuid: Posix.SysDB.uid -> unit (* @ $(SML_LIB)/basis/posix/proc-env.sml 46.14-46.19 *)
val Posix.ProcEnv.sysconf: string -> LargeWord.word (* @ $(SML_LIB)/basis/posix/proc-env.sml 233.14-233.20 *)
val Posix.ProcEnv.time: unit -> Time.time (* @ $(SML_LIB)/basis/posix/proc-env.sml 92.11-92.14 *)
val Posix.ProcEnv.times: unit -> {cstime: Time.time, cutime: Time.time, elapsed: Time.time, stime: Time.time, utime: Time.time} (* @ $(SML_LIB)/basis/posix/proc-env.sml 258.14-258.18 *)
val Posix.ProcEnv.ttyname: Posix.TTY.file_desc -> string (* @ $(SML_LIB)/basis/posix/proc-env.sml 284.11-284.17 *)
val Posix.ProcEnv.uidToWord: Posix.SysDB.uid -> LargeWord.word (* @ $(SML_LIB)/basis/posix/proc-env.sml 28.11-28.19 *)
val Posix.ProcEnv.uname: unit -> (string * string) list (* @ $(SML_LIB)/basis/posix/proc-env.sml 82.11-82.15 *)
val Posix.ProcEnv.wordToGid: LargeWord.word -> Posix.SysDB.gid (* @ $(SML_LIB)/basis/posix/proc-env.sml 31.11-31.19 *)
val Posix.ProcEnv.wordToUid: LargeWord.word -> Posix.SysDB.uid (* @ $(SML_LIB)/basis/posix/proc-env.sml 29.11-29.19 *)
structure Posix.Process: POSIX_PROCESS where type W.flags = Posix.Process.W.flags where type exit_status = Unix.exit_status where type killpid_arg = Posix.Process.killpid_arg where type pid = Posix.TTY.pid where type signal = Unix.signal where type waitpid_arg = Posix.Process.waitpid_arg (* @ $(SML_LIB)/basis/posix/posix.sml 15.17-15.23 *)
datatype Posix.Process.exit_status = W_EXITED | W_EXITSTATUS of Word8.word | W_SIGNALED of Unix.signal | W_STOPPED of Unix.signal (* = datatype Unix.exit_status *) (* @ $(SML_LIB)/basis/posix/process.sml 73.16-73.26 *)
datatype Posix.Process.killpid_arg = K_GROUP of Posix.TTY.pid | K_PROC of Posix.TTY.pid | K_SAME_GROUP (* = datatype Posix.Process.killpid_arg *) (* @ $(SML_LIB)/basis/posix/process.sml 149.16-149.26 *)
type Posix.Process.pid = Posix.TTY.pid (* @ $(SML_LIB)/basis/posix/process.sml 22.12-22.14 *)
type Posix.Process.signal = Unix.signal (* @ $(SML_LIB)/basis/posix/process.sml 21.12-21.17 *)
datatype Posix.Process.waitpid_arg = W_ANY_CHILD | W_CHILD of Posix.TTY.pid | W_GROUP of Posix.TTY.pid | W_SAME_GROUP (* = datatype Posix.Process.waitpid_arg *) (* @ $(SML_LIB)/basis/posix/process.sml 67.16-67.26 *)
con Posix.Process.K_GROUP: Posix.TTY.pid -> Posix.Process.killpid_arg (* @ $(SML_LIB)/basis/posix/process.sml 152.10-152.16 *)
con Posix.Process.K_PROC: Posix.TTY.pid -> Posix.Process.killpid_arg (* @ $(SML_LIB)/basis/posix/process.sml 150.10-150.15 *)
con Posix.Process.K_SAME_GROUP: Posix.Process.killpid_arg (* @ $(SML_LIB)/basis/posix/process.sml 151.10-151.21 *)
con Posix.Process.W_ANY_CHILD: Posix.Process.waitpid_arg (* @ $(SML_LIB)/basis/posix/process.sml 68.10-68.20 *)
con Posix.Process.W_CHILD: Posix.TTY.pid -> Posix.Process.waitpid_arg (* @ $(SML_LIB)/basis/posix/process.sml 69.10-69.16 *)
con Posix.Process.W_EXITED: Unix.exit_status (* @ $(SML_LIB)/basis/posix/process.sml 74.10-74.17 *)
con Posix.Process.W_EXITSTATUS: Word8.word -> Unix.exit_status (* @ $(SML_LIB)/basis/posix/process.sml 75.10-75.21 *)
con Posix.Process.W_GROUP: Posix.TTY.pid -> Posix.Process.waitpid_arg (* @ $(SML_LIB)/basis/posix/process.sml 71.10-71.16 *)
con Posix.Process.W_SAME_GROUP: Posix.Process.waitpid_arg (* @ $(SML_LIB)/basis/posix/process.sml 70.10-70.21 *)
con Posix.Process.W_SIGNALED: Unix.signal -> Unix.exit_status (* @ $(SML_LIB)/basis/posix/process.sml 76.10-76.19 *)
con Posix.Process.W_STOPPED: Unix.signal -> Unix.exit_status (* @ $(SML_LIB)/basis/posix/process.sml 77.10-77.18 *)
val Posix.Process.alarm: Time.time -> Time.time (* @ $(SML_LIB)/basis/posix/process.sml 174.14-174.18 *)
val Posix.Process.exec: string * string list -> 'a (* @ $(SML_LIB)/basis/posix/process.sml 54.11-54.14 *)
val Posix.Process.exece: string * string list * string list -> 'a (* @ $(SML_LIB)/basis/posix/process.sml 43.11-43.15 *)
val Posix.Process.execp: string * string list -> 'a (* @ $(SML_LIB)/basis/posix/process.sml 57.11-57.15 *)
val Posix.Process.exit: Word8.word -> 'a (* @ $(SML_LIB)/basis/posix/process.sml 142.11-142.14 *)
val Posix.Process.fork: unit -> Posix.TTY.pid option (* @ $(SML_LIB)/basis/posix/process.sml 35.11-35.14 *)
val Posix.Process.fromStatus: OS.Process.status -> Unix.exit_status (* @ $(SML_LIB)/basis/posix/process.sml 89.11-89.20 *)
val Posix.Process.kill: Posix.Process.killpid_arg * Unix.signal -> unit (* @ $(SML_LIB)/basis/posix/process.sml 154.11-154.14 *)
val Posix.Process.pause: unit -> unit (* @ $(SML_LIB)/basis/posix/process.sml 200.11-200.15 *)
val Posix.Process.pidToWord: Posix.TTY.pid -> LargeWord.word (* @ $(SML_LIB)/basis/posix/process.sml 24.11-24.19 *)
val Posix.Process.sleep: Time.time -> Time.time (* @ $(SML_LIB)/basis/posix/process.sml 178.11-178.15 *)
val Posix.Process.wait: unit -> Posix.TTY.pid * Unix.exit_status (* @ $(SML_LIB)/basis/posix/process.sml 140.11-140.14 *)
val Posix.Process.waitpid: Posix.Process.waitpid_arg * Posix.Process.W.flags list -> Posix.TTY.pid * Unix.exit_status (* @ $(SML_LIB)/basis/posix/process.sml 123.14-123.20 *)
val Posix.Process.waitpid_nh: Posix.Process.waitpid_arg * Posix.Process.W.flags list -> (Posix.TTY.pid * Unix.exit_status) option (* @ $(SML_LIB)/basis/posix/process.sml 130.14-130.23 *)
val Posix.Process.wordToPid: LargeWord.word -> Posix.TTY.pid (* @ $(SML_LIB)/basis/posix/process.sml 25.11-25.19 *)
structure Posix.Process.W:
   sig
      type flags = Posix.Process.W.flags
      val all: Posix.Process.W.flags
      val allSet: Posix.Process.W.flags * Posix.Process.W.flags -> bool
      val anySet: Posix.Process.W.flags * Posix.Process.W.flags -> bool
      val clear: Posix.Process.W.flags * Posix.Process.W.flags -> Posix.Process.W.flags
      val flags: Posix.Process.W.flags list -> Posix.Process.W.flags
      val fromWord: LargeWord.word -> Posix.Process.W.flags
      val intersect: Posix.Process.W.flags list -> Posix.Process.W.flags
      val toWord: Posix.Process.W.flags -> LargeWord.word
      val untraced: Posix.Process.W.flags
   end
   (* @ $(SML_LIB)/basis/posix/process.sml 92.17-92.17 *)
type Posix.Process.W.flags = Posix.Process.W.flags (* @ $(SML_LIB)/basis/posix/flags.sml 18.12-18.16 *)
val Posix.Process.W.all: Posix.Process.W.flags (* @ $(SML_LIB)/basis/posix/flags.sml 20.11-20.13 *)
val Posix.Process.W.allSet: Posix.Process.W.flags * Posix.Process.W.flags -> bool (* @ $(SML_LIB)/basis/posix/flags.sml 32.11-32.16 *)
val Posix.Process.W.anySet: Posix.Process.W.flags * Posix.Process.W.flags -> bool (* @ $(SML_LIB)/basis/posix/flags.sml 34.11-34.16 *)
val Posix.Process.W.clear: Posix.Process.W.flags * Posix.Process.W.flags -> Posix.Process.W.flags (* @ $(SML_LIB)/basis/posix/flags.sml 30.11-30.15 *)
val Posix.Process.W.flags: Posix.Process.W.flags list -> Posix.Process.W.flags (* @ $(SML_LIB)/basis/posix/flags.sml 26.11-26.15 *)
val Posix.Process.W.fromWord: LargeWord.word -> Posix.Process.W.flags (* @ $(SML_LIB)/basis/posix/flags.sml 24.11-24.18 *)
val Posix.Process.W.intersect: Posix.Process.W.flags list -> Posix.Process.W.flags (* @ $(SML_LIB)/basis/posix/flags.sml 28.11-28.19 *)
val Posix.Process.W.toWord: Posix.Process.W.flags -> LargeWord.word (* @ $(SML_LIB)/basis/posix/flags.sml 23.11-23.16 *)
val Posix.Process.W.untraced: Posix.Process.W.flags (* @ $(SML_LIB)/basis/posix/process.sml 98.17-98.24 *)
structure Posix.Signal: POSIX_SIGNAL where type signal = Unix.signal (* @ $(SML_LIB)/basis/posix/posix.sml 13.17-13.22 *)
type Posix.Signal.signal = Unix.signal (* @ $(SML_LIB)/basis/posix/signal.sml 14.12-14.17 *)
val Posix.Signal.abrt: Unix.signal (* @ $(SML_LIB)/basis/posix/signal.sml 16.11-16.14 *)
val Posix.Signal.alrm: Unix.signal (* @ $(SML_LIB)/basis/posix/signal.sml 17.11-17.14 *)
val Posix.Signal.bus: Unix.signal (* @ $(SML_LIB)/basis/posix/signal.sml 18.11-18.13 *)
val Posix.Signal.chld: Unix.signal (* @ $(SML_LIB)/basis/posix/signal.sml 19.11-19.14 *)
val Posix.Signal.cont: Unix.signal (* @ $(SML_LIB)/basis/posix/signal.sml 20.11-20.14 *)
val Posix.Signal.fpe: Unix.signal (* @ $(SML_LIB)/basis/posix/signal.sml 21.11-21.13 *)
val Posix.Signal.fromWord: LargeWord.word -> Unix.signal (* @ $(SML_LIB)/basis/posix/signal.sml 58.11-58.18 *)
val Posix.Signal.hup: Unix.signal (* @ $(SML_LIB)/basis/posix/signal.sml 22.11-22.13 *)
val Posix.Signal.ill: Unix.signal (* @ $(SML_LIB)/basis/posix/signal.sml 23.11-23.13 *)
val Posix.Signal.int: Unix.signal (* @ $(SML_LIB)/basis/posix/signal.sml 24.11-24.13 *)
val Posix.Signal.kill: Unix.signal (* @ $(SML_LIB)/basis/posix/signal.sml 25.11-25.14 *)
val Posix.Signal.pipe: Unix.signal (* @ $(SML_LIB)/basis/posix/signal.sml 26.11-26.14 *)
val Posix.Signal.quit: Unix.signal (* @ $(SML_LIB)/basis/posix/signal.sml 29.11-29.14 *)
val Posix.Signal.segv: Unix.signal (* @ $(SML_LIB)/basis/posix/signal.sml 30.11-30.14 *)
val Posix.Signal.stop: Unix.signal (* @ $(SML_LIB)/basis/posix/signal.sml 31.11-31.14 *)
val Posix.Signal.term: Unix.signal (* @ $(SML_LIB)/basis/posix/signal.sml 33.11-33.14 *)
val Posix.Signal.toWord: Unix.signal -> LargeWord.word (* @ $(SML_LIB)/basis/posix/signal.sml 57.11-57.16 *)
val Posix.Signal.tstp: Unix.signal (* @ $(SML_LIB)/basis/posix/signal.sml 35.11-35.14 *)
val Posix.Signal.ttin: Unix.signal (* @ $(SML_LIB)/basis/posix/signal.sml 36.11-36.14 *)
val Posix.Signal.ttou: Unix.signal (* @ $(SML_LIB)/basis/posix/signal.sml 37.11-37.14 *)
val Posix.Signal.usr1: Unix.signal (* @ $(SML_LIB)/basis/posix/signal.sml 39.11-39.14 *)
val Posix.Signal.usr2: Unix.signal (* @ $(SML_LIB)/basis/posix/signal.sml 40.11-40.14 *)
structure Posix.SysDB: POSIX_SYS_DB where type Group.group = Posix.SysDB.Group.group where type Passwd.passwd = Posix.SysDB.Passwd.passwd where type gid = Posix.SysDB.gid where type uid = Posix.SysDB.uid (* @ $(SML_LIB)/basis/posix/posix.sml 23.17-23.21 *)
type Posix.SysDB.gid = Posix.SysDB.gid (* @ $(SML_LIB)/basis/posix/sys-db.sml 18.12-18.14 *)
type Posix.SysDB.uid = Posix.SysDB.uid (* @ $(SML_LIB)/basis/posix/sys-db.sml 19.12-19.14 *)
val Posix.SysDB.getgrgid: Posix.SysDB.gid -> Posix.SysDB.Group.group (* @ $(SML_LIB)/basis/posix/sys-db.sml 94.11-94.18 *)
val Posix.SysDB.getgrnam: string -> Posix.SysDB.Group.group (* @ $(SML_LIB)/basis/posix/sys-db.sml 89.11-89.18 *)
val Posix.SysDB.getpwnam: string -> Posix.SysDB.Passwd.passwd (* @ $(SML_LIB)/basis/posix/sys-db.sml 53.11-53.18 *)
val Posix.SysDB.getpwuid: Posix.SysDB.uid -> Posix.SysDB.Passwd.passwd (* @ $(SML_LIB)/basis/posix/sys-db.sml 58.11-58.18 *)
structure Posix.SysDB.Group:
   sig
      type group = Posix.SysDB.Group.group
      val gid: Posix.SysDB.Group.group -> Posix.SysDB.gid
      val members: Posix.SysDB.Group.group -> string list
      val name: Posix.SysDB.Group.group -> string
   end
   (* @ $(SML_LIB)/basis/posix/sys-db.sml 63.17-63.21 *)
type Posix.SysDB.Group.group = Posix.SysDB.Group.group (* @ $(SML_LIB)/basis/posix/sys-db.sml 65.18-65.22 *)
val Posix.SysDB.Group.gid: Posix.SysDB.Group.group -> Posix.SysDB.gid (* @ $(SML_LIB)/basis/posix/sys-db.sml 85.17-85.19 *)
val Posix.SysDB.Group.members: Posix.SysDB.Group.group -> string list (* @ $(SML_LIB)/basis/posix/sys-db.sml 86.17-86.23 *)
val Posix.SysDB.Group.name: Posix.SysDB.Group.group -> string (* @ $(SML_LIB)/basis/posix/sys-db.sml 84.17-84.20 *)
structure Posix.SysDB.Passwd:
   sig
      type passwd = Posix.SysDB.Passwd.passwd
      val gid: Posix.SysDB.Passwd.passwd -> Posix.SysDB.gid
      val home: Posix.SysDB.Passwd.passwd -> string
      val name: Posix.SysDB.Passwd.passwd -> string
      val shell: Posix.SysDB.Passwd.passwd -> string
      val uid: Posix.SysDB.Passwd.passwd -> Posix.SysDB.uid
   end
   (* @ $(SML_LIB)/basis/posix/sys-db.sml 21.17-21.22 *)
type Posix.SysDB.Passwd.passwd = Posix.SysDB.Passwd.passwd (* @ $(SML_LIB)/basis/posix/sys-db.sml 23.18-23.23 *)
val Posix.SysDB.Passwd.gid: Posix.SysDB.Passwd.passwd -> Posix.SysDB.gid (* @ $(SML_LIB)/basis/posix/sys-db.sml 48.17-48.19 *)
val Posix.SysDB.Passwd.home: Posix.SysDB.Passwd.passwd -> string (* @ $(SML_LIB)/basis/posix/sys-db.sml 49.17-49.20 *)
val Posix.SysDB.Passwd.name: Posix.SysDB.Passwd.passwd -> string (* @ $(SML_LIB)/basis/posix/sys-db.sml 46.17-46.20 *)
val Posix.SysDB.Passwd.shell: Posix.SysDB.Passwd.passwd -> string (* @ $(SML_LIB)/basis/posix/sys-db.sml 50.17-50.21 *)
val Posix.SysDB.Passwd.uid: Posix.SysDB.Passwd.passwd -> Posix.SysDB.uid (* @ $(SML_LIB)/basis/posix/sys-db.sml 47.17-47.19 *)
structure Posix.TTY: POSIX_TTY where type C.flags = Posix.TTY.C.flags where type I.flags = Posix.TTY.I.flags where type L.flags = Posix.TTY.L.flags where type O.flags = Posix.TTY.O.flags where type TC.flow_action = Posix.TTY.TC.flow_action where type TC.queue_sel = Posix.TTY.TC.queue_sel where type TC.set_action = Posix.TTY.TC.set_action where type V.cc = Posix.TTY.V.cc where type file_desc = Posix.TTY.file_desc where type pid = Posix.TTY.pid where type speed = Posix.TTY.speed where type termios = Posix.TTY.termios (* @ $(SML_LIB)/basis/posix/posix.sml 25.17-25.19 *)
type Posix.TTY.file_desc = Posix.TTY.file_desc (* @ $(SML_LIB)/basis/posix/tty.sml 19.12-19.20 *)
type Posix.TTY.pid = Posix.TTY.pid (* @ $(SML_LIB)/basis/posix/tty.sml 20.12-20.14 *)
type Posix.TTY.speed = Posix.TTY.speed (* @ $(SML_LIB)/basis/posix/tty.sml 145.12-145.16 *)
type Posix.TTY.termios = Posix.TTY.termios (* @ $(SML_LIB)/basis/posix/tty.sml 168.12-168.18 *)
val Posix.TTY.b0: Posix.TTY.speed (* @ $(SML_LIB)/basis/posix/tty.sml 147.11-147.12 *)
val Posix.TTY.b110: Posix.TTY.speed (* @ $(SML_LIB)/basis/posix/tty.sml 148.11-148.14 *)
val Posix.TTY.b1200: Posix.TTY.speed (* @ $(SML_LIB)/basis/posix/tty.sml 149.11-149.15 *)
val Posix.TTY.b134: Posix.TTY.speed (* @ $(SML_LIB)/basis/posix/tty.sml 150.11-150.14 *)
val Posix.TTY.b150: Posix.TTY.speed (* @ $(SML_LIB)/basis/posix/tty.sml 151.11-151.14 *)
val Posix.TTY.b1800: Posix.TTY.speed (* @ $(SML_LIB)/basis/posix/tty.sml 152.11-152.15 *)
val Posix.TTY.b19200: Posix.TTY.speed (* @ $(SML_LIB)/basis/posix/tty.sml 153.11-153.16 *)
val Posix.TTY.b200: Posix.TTY.speed (* @ $(SML_LIB)/basis/posix/tty.sml 154.11-154.14 *)
val Posix.TTY.b2400: Posix.TTY.speed (* @ $(SML_LIB)/basis/posix/tty.sml 155.11-155.15 *)
val Posix.TTY.b300: Posix.TTY.speed (* @ $(SML_LIB)/basis/posix/tty.sml 156.11-156.14 *)
val Posix.TTY.b38400: Posix.TTY.speed (* @ $(SML_LIB)/basis/posix/tty.sml 157.11-157.16 *)
val Posix.TTY.b4800: Posix.TTY.speed (* @ $(SML_LIB)/basis/posix/tty.sml 158.11-158.15 *)
val Posix.TTY.b50: Posix.TTY.speed (* @ $(SML_LIB)/basis/posix/tty.sml 159.11-159.13 *)
val Posix.TTY.b600: Posix.TTY.speed (* @ $(SML_LIB)/basis/posix/tty.sml 160.11-160.14 *)
val Posix.TTY.b75: Posix.TTY.speed (* @ $(SML_LIB)/basis/posix/tty.sml 161.11-161.13 *)
val Posix.TTY.b9600: Posix.TTY.speed (* @ $(SML_LIB)/basis/posix/tty.sml 162.11-162.15 *)
val Posix.TTY.compareSpeed: Posix.TTY.speed * Posix.TTY.speed -> order (* @ $(SML_LIB)/basis/posix/tty.sml 164.11-164.22 *)
val Posix.TTY.fieldsOf: Posix.TTY.termios -> {cc: Posix.TTY.V.cc, cflag: Posix.TTY.C.flags, iflag: Posix.TTY.I.flags, ispeed: Posix.TTY.speed, lflag: Posix.TTY.L.flags, oflag: Posix.TTY.O.flags, ospeed: Posix.TTY.speed} (* @ $(SML_LIB)/basis/posix/tty.sml 178.11-178.18 *)
val Posix.TTY.getcc: Posix.TTY.termios -> Posix.TTY.V.cc (* @ $(SML_LIB)/basis/posix/tty.sml 184.11-184.15 *)
val Posix.TTY.getcflag: Posix.TTY.termios -> Posix.TTY.C.flags (* @ $(SML_LIB)/basis/posix/tty.sml 182.11-182.18 *)
val Posix.TTY.getiflag: Posix.TTY.termios -> Posix.TTY.I.flags (* @ $(SML_LIB)/basis/posix/tty.sml 180.11-180.18 *)
val Posix.TTY.getlflag: Posix.TTY.termios -> Posix.TTY.L.flags (* @ $(SML_LIB)/basis/posix/tty.sml 183.11-183.18 *)
val Posix.TTY.getoflag: Posix.TTY.termios -> Posix.TTY.O.flags (* @ $(SML_LIB)/basis/posix/tty.sml 181.11-181.18 *)
val Posix.TTY.speedToWord: Posix.TTY.speed -> LargeWord.word (* @ $(SML_LIB)/basis/posix/tty.sml 165.11-165.21 *)
val Posix.TTY.termios: {cc: Posix.TTY.V.cc, cflag: Posix.TTY.C.flags, iflag: Posix.TTY.I.flags, ispeed: Posix.TTY.speed, lflag: Posix.TTY.L.flags, oflag: Posix.TTY.O.flags, ospeed: Posix.TTY.speed} -> Posix.TTY.termios (* @ $(SML_LIB)/basis/posix/tty.sml 177.11-177.17 *)
val Posix.TTY.wordToSpeed: LargeWord.word -> Posix.TTY.speed (* @ $(SML_LIB)/basis/posix/tty.sml 166.11-166.21 *)
structure Posix.TTY.C:
   sig
      type flags = Posix.TTY.C.flags
      val all: Posix.TTY.C.flags
      val allSet: Posix.TTY.C.flags * Posix.TTY.C.flags -> bool
      val anySet: Posix.TTY.C.flags * Posix.TTY.C.flags -> bool
      val clear: Posix.TTY.C.flags * Posix.TTY.C.flags -> Posix.TTY.C.flags
      val clocal: Posix.TTY.C.flags
      val cread: Posix.TTY.C.flags
      val cs5: Posix.TTY.C.flags
      val cs6: Posix.TTY.C.flags
      val cs7: Posix.TTY.C.flags
      val cs8: Posix.TTY.C.flags
      val csize: Posix.TTY.C.flags
      val cstopb: Posix.TTY.C.flags
      val flags: Posix.TTY.C.flags list -> Posix.TTY.C.flags
      val fromWord: LargeWord.word -> Posix.TTY.C.flags
      val hupcl: Posix.TTY.C.flags
      val intersect: Posix.TTY.C.flags list -> Posix.TTY.C.flags
      val parenb: Posix.TTY.C.flags
      val parodd: Posix.TTY.C.flags
      val toWord: Posix.TTY.C.flags -> LargeWord.word
   end
   (* @ $(SML_LIB)/basis/posix/tty.sml 115.17-115.17 *)
type Posix.TTY.C.flags = Posix.TTY.C.flags (* @ $(SML_LIB)/basis/posix/flags.sml 18.12-18.16 *)
val Posix.TTY.C.all: Posix.TTY.C.flags (* @ $(SML_LIB)/basis/posix/flags.sml 20.11-20.13 *)
val Posix.TTY.C.allSet: Posix.TTY.C.flags * Posix.TTY.C.flags -> bool (* @ $(SML_LIB)/basis/posix/flags.sml 32.11-32.16 *)
val Posix.TTY.C.anySet: Posix.TTY.C.flags * Posix.TTY.C.flags -> bool (* @ $(SML_LIB)/basis/posix/flags.sml 34.11-34.16 *)
val Posix.TTY.C.clear: Posix.TTY.C.flags * Posix.TTY.C.flags -> Posix.TTY.C.flags (* @ $(SML_LIB)/basis/posix/flags.sml 30.11-30.15 *)
val Posix.TTY.C.clocal: Posix.TTY.C.flags (* @ $(SML_LIB)/basis/posix/tty.sml 118.17-118.22 *)
val Posix.TTY.C.cread: Posix.TTY.C.flags (* @ $(SML_LIB)/basis/posix/tty.sml 119.17-119.21 *)
val Posix.TTY.C.cs5: Posix.TTY.C.flags (* @ $(SML_LIB)/basis/posix/tty.sml 120.17-120.19 *)
val Posix.TTY.C.cs6: Posix.TTY.C.flags (* @ $(SML_LIB)/basis/posix/tty.sml 121.17-121.19 *)
val Posix.TTY.C.cs7: Posix.TTY.C.flags (* @ $(SML_LIB)/basis/posix/tty.sml 122.17-122.19 *)
val Posix.TTY.C.cs8: Posix.TTY.C.flags (* @ $(SML_LIB)/basis/posix/tty.sml 123.17-123.19 *)
val Posix.TTY.C.csize: Posix.TTY.C.flags (* @ $(SML_LIB)/basis/posix/tty.sml 124.17-124.21 *)
val Posix.TTY.C.cstopb: Posix.TTY.C.flags (* @ $(SML_LIB)/basis/posix/tty.sml 125.17-125.22 *)
val Posix.TTY.C.flags: Posix.TTY.C.flags list -> Posix.TTY.C.flags (* @ $(SML_LIB)/basis/posix/flags.sml 26.11-26.15 *)
val Posix.TTY.C.fromWord: LargeWord.word -> Posix.TTY.C.flags (* @ $(SML_LIB)/basis/posix/flags.sml 24.11-24.18 *)
val Posix.TTY.C.hupcl: Posix.TTY.C.flags (* @ $(SML_LIB)/basis/posix/tty.sml 126.17-126.21 *)
val Posix.TTY.C.intersect: Posix.TTY.C.flags list -> Posix.TTY.C.flags (* @ $(SML_LIB)/basis/posix/flags.sml 28.11-28.19 *)
val Posix.TTY.C.parenb: Posix.TTY.C.flags (* @ $(SML_LIB)/basis/posix/tty.sml 127.17-127.22 *)
val Posix.TTY.C.parodd: Posix.TTY.C.flags (* @ $(SML_LIB)/basis/posix/tty.sml 128.17-128.22 *)
val Posix.TTY.C.toWord: Posix.TTY.C.flags -> LargeWord.word (* @ $(SML_LIB)/basis/posix/flags.sml 23.11-23.16 *)
structure Posix.TTY.CF:
   sig
      val getispeed: Posix.TTY.termios -> Posix.TTY.speed
      val getospeed: Posix.TTY.termios -> Posix.TTY.speed
      val setispeed: Posix.TTY.termios * Posix.TTY.speed -> Posix.TTY.termios
      val setospeed: Posix.TTY.termios * Posix.TTY.speed -> Posix.TTY.termios
   end
   (* @ $(SML_LIB)/basis/posix/tty.sml 186.17-186.18 *)
val Posix.TTY.CF.getispeed: Posix.TTY.termios -> Posix.TTY.speed (* @ $(SML_LIB)/basis/posix/tty.sml 199.17-199.25 *)
val Posix.TTY.CF.getospeed: Posix.TTY.termios -> Posix.TTY.speed (* @ $(SML_LIB)/basis/posix/tty.sml 188.17-188.25 *)
val Posix.TTY.CF.setispeed: Posix.TTY.termios * Posix.TTY.speed -> Posix.TTY.termios (* @ $(SML_LIB)/basis/posix/tty.sml 201.17-201.25 *)
val Posix.TTY.CF.setospeed: Posix.TTY.termios * Posix.TTY.speed -> Posix.TTY.termios (* @ $(SML_LIB)/basis/posix/tty.sml 189.17-189.25 *)
structure Posix.TTY.I:
   sig
      type flags = Posix.TTY.I.flags
      val all: Posix.TTY.I.flags
      val allSet: Posix.TTY.I.flags * Posix.TTY.I.flags -> bool
      val anySet: Posix.TTY.I.flags * Posix.TTY.I.flags -> bool
      val brkint: Posix.TTY.I.flags
      val clear: Posix.TTY.I.flags * Posix.TTY.I.flags -> Posix.TTY.I.flags
      val flags: Posix.TTY.I.flags list -> Posix.TTY.I.flags
      val fromWord: LargeWord.word -> Posix.TTY.I.flags
      val icrnl: Posix.TTY.I.flags
      val ignbrk: Posix.TTY.I.flags
      val igncr: Posix.TTY.I.flags
      val ignpar: Posix.TTY.I.flags
      val inlcr: Posix.TTY.I.flags
      val inpck: Posix.TTY.I.flags
      val intersect: Posix.TTY.I.flags list -> Posix.TTY.I.flags
      val istrip: Posix.TTY.I.flags
      val ixoff: Posix.TTY.I.flags
      val ixon: Posix.TTY.I.flags
      val parmrk: Posix.TTY.I.flags
      val toWord: Posix.TTY.I.flags -> LargeWord.word
   end
   (* @ $(SML_LIB)/basis/posix/tty.sml 65.17-65.17 *)
type Posix.TTY.I.flags = Posix.TTY.I.flags (* @ $(SML_LIB)/basis/posix/flags.sml 18.12-18.16 *)
val Posix.TTY.I.all: Posix.TTY.I.flags (* @ $(SML_LIB)/basis/posix/flags.sml 20.11-20.13 *)
val Posix.TTY.I.allSet: Posix.TTY.I.flags * Posix.TTY.I.flags -> bool (* @ $(SML_LIB)/basis/posix/flags.sml 32.11-32.16 *)
val Posix.TTY.I.anySet: Posix.TTY.I.flags * Posix.TTY.I.flags -> bool (* @ $(SML_LIB)/basis/posix/flags.sml 34.11-34.16 *)
val Posix.TTY.I.brkint: Posix.TTY.I.flags (* @ $(SML_LIB)/basis/posix/tty.sml 68.17-68.22 *)
val Posix.TTY.I.clear: Posix.TTY.I.flags * Posix.TTY.I.flags -> Posix.TTY.I.flags (* @ $(SML_LIB)/basis/posix/flags.sml 30.11-30.15 *)
val Posix.TTY.I.flags: Posix.TTY.I.flags list -> Posix.TTY.I.flags (* @ $(SML_LIB)/basis/posix/flags.sml 26.11-26.15 *)
val Posix.TTY.I.fromWord: LargeWord.word -> Posix.TTY.I.flags (* @ $(SML_LIB)/basis/posix/flags.sml 24.11-24.18 *)
val Posix.TTY.I.icrnl: Posix.TTY.I.flags (* @ $(SML_LIB)/basis/posix/tty.sml 69.17-69.21 *)
val Posix.TTY.I.ignbrk: Posix.TTY.I.flags (* @ $(SML_LIB)/basis/posix/tty.sml 70.17-70.22 *)
val Posix.TTY.I.igncr: Posix.TTY.I.flags (* @ $(SML_LIB)/basis/posix/tty.sml 71.17-71.21 *)
val Posix.TTY.I.ignpar: Posix.TTY.I.flags (* @ $(SML_LIB)/basis/posix/tty.sml 72.17-72.22 *)
val Posix.TTY.I.inlcr: Posix.TTY.I.flags (* @ $(SML_LIB)/basis/posix/tty.sml 73.17-73.21 *)
val Posix.TTY.I.inpck: Posix.TTY.I.flags (* @ $(SML_LIB)/basis/posix/tty.sml 74.17-74.21 *)
val Posix.TTY.I.intersect: Posix.TTY.I.flags list -> Posix.TTY.I.flags (* @ $(SML_LIB)/basis/posix/flags.sml 28.11-28.19 *)
val Posix.TTY.I.istrip: Posix.TTY.I.flags (* @ $(SML_LIB)/basis/posix/tty.sml 75.17-75.22 *)
val Posix.TTY.I.ixoff: Posix.TTY.I.flags (* @ $(SML_LIB)/basis/posix/tty.sml 77.17-77.21 *)
val Posix.TTY.I.ixon: Posix.TTY.I.flags (* @ $(SML_LIB)/basis/posix/tty.sml 78.17-78.20 *)
val Posix.TTY.I.parmrk: Posix.TTY.I.flags (* @ $(SML_LIB)/basis/posix/tty.sml 79.17-79.22 *)
val Posix.TTY.I.toWord: Posix.TTY.I.flags -> LargeWord.word (* @ $(SML_LIB)/basis/posix/flags.sml 23.11-23.16 *)
structure Posix.TTY.L:
   sig
      type flags = Posix.TTY.L.flags
      val all: Posix.TTY.L.flags
      val allSet: Posix.TTY.L.flags * Posix.TTY.L.flags -> bool
      val anySet: Posix.TTY.L.flags * Posix.TTY.L.flags -> bool
      val clear: Posix.TTY.L.flags * Posix.TTY.L.flags -> Posix.TTY.L.flags
      val echo: Posix.TTY.L.flags
      val echoe: Posix.TTY.L.flags
      val echok: Posix.TTY.L.flags
      val echonl: Posix.TTY.L.flags
      val flags: Posix.TTY.L.flags list -> Posix.TTY.L.flags
      val fromWord: LargeWord.word -> Posix.TTY.L.flags
      val icanon: Posix.TTY.L.flags
      val iexten: Posix.TTY.L.flags
      val intersect: Posix.TTY.L.flags list -> Posix.TTY.L.flags
      val isig: Posix.TTY.L.flags
      val noflsh: Posix.TTY.L.flags
      val toWord: Posix.TTY.L.flags -> LargeWord.word
      val tostop: Posix.TTY.L.flags
   end
   (* @ $(SML_LIB)/basis/posix/tty.sml 131.17-131.17 *)
type Posix.TTY.L.flags = Posix.TTY.L.flags (* @ $(SML_LIB)/basis/posix/flags.sml 18.12-18.16 *)
val Posix.TTY.L.all: Posix.TTY.L.flags (* @ $(SML_LIB)/basis/posix/flags.sml 20.11-20.13 *)
val Posix.TTY.L.allSet: Posix.TTY.L.flags * Posix.TTY.L.flags -> bool (* @ $(SML_LIB)/basis/posix/flags.sml 32.11-32.16 *)
val Posix.TTY.L.anySet: Posix.TTY.L.flags * Posix.TTY.L.flags -> bool (* @ $(SML_LIB)/basis/posix/flags.sml 34.11-34.16 *)
val Posix.TTY.L.clear: Posix.TTY.L.flags * Posix.TTY.L.flags -> Posix.TTY.L.flags (* @ $(SML_LIB)/basis/posix/flags.sml 30.11-30.15 *)
val Posix.TTY.L.echo: Posix.TTY.L.flags (* @ $(SML_LIB)/basis/posix/tty.sml 134.17-134.20 *)
val Posix.TTY.L.echoe: Posix.TTY.L.flags (* @ $(SML_LIB)/basis/posix/tty.sml 135.17-135.21 *)
val Posix.TTY.L.echok: Posix.TTY.L.flags (* @ $(SML_LIB)/basis/posix/tty.sml 136.17-136.21 *)
val Posix.TTY.L.echonl: Posix.TTY.L.flags (* @ $(SML_LIB)/basis/posix/tty.sml 137.17-137.22 *)
val Posix.TTY.L.flags: Posix.TTY.L.flags list -> Posix.TTY.L.flags (* @ $(SML_LIB)/basis/posix/flags.sml 26.11-26.15 *)
val Posix.TTY.L.fromWord: LargeWord.word -> Posix.TTY.L.flags (* @ $(SML_LIB)/basis/posix/flags.sml 24.11-24.18 *)
val Posix.TTY.L.icanon: Posix.TTY.L.flags (* @ $(SML_LIB)/basis/posix/tty.sml 138.17-138.22 *)
val Posix.TTY.L.iexten: Posix.TTY.L.flags (* @ $(SML_LIB)/basis/posix/tty.sml 139.17-139.22 *)
val Posix.TTY.L.intersect: Posix.TTY.L.flags list -> Posix.TTY.L.flags (* @ $(SML_LIB)/basis/posix/flags.sml 28.11-28.19 *)
val Posix.TTY.L.isig: Posix.TTY.L.flags (* @ $(SML_LIB)/basis/posix/tty.sml 140.17-140.20 *)
val Posix.TTY.L.noflsh: Posix.TTY.L.flags (* @ $(SML_LIB)/basis/posix/tty.sml 141.17-141.22 *)
val Posix.TTY.L.toWord: Posix.TTY.L.flags -> LargeWord.word (* @ $(SML_LIB)/basis/posix/flags.sml 23.11-23.16 *)
val Posix.TTY.L.tostop: Posix.TTY.L.flags (* @ $(SML_LIB)/basis/posix/tty.sml 142.17-142.22 *)
structure Posix.TTY.O:
   sig
      type flags = Posix.TTY.O.flags
      val all: Posix.TTY.O.flags
      val allSet: Posix.TTY.O.flags * Posix.TTY.O.flags -> bool
      val anySet: Posix.TTY.O.flags * Posix.TTY.O.flags -> bool
      val clear: Posix.TTY.O.flags * Posix.TTY.O.flags -> Posix.TTY.O.flags
      val flags: Posix.TTY.O.flags list -> Posix.TTY.O.flags
      val fromWord: LargeWord.word -> Posix.TTY.O.flags
      val intersect: Posix.TTY.O.flags list -> Posix.TTY.O.flags
      val opost: Posix.TTY.O.flags
      val toWord: Posix.TTY.O.flags -> LargeWord.word
   end
   (* @ $(SML_LIB)/basis/posix/tty.sml 82.17-82.17 *)
type Posix.TTY.O.flags = Posix.TTY.O.flags (* @ $(SML_LIB)/basis/posix/flags.sml 18.12-18.16 *)
val Posix.TTY.O.all: Posix.TTY.O.flags (* @ $(SML_LIB)/basis/posix/flags.sml 20.11-20.13 *)
val Posix.TTY.O.allSet: Posix.TTY.O.flags * Posix.TTY.O.flags -> bool (* @ $(SML_LIB)/basis/posix/flags.sml 32.11-32.16 *)
val Posix.TTY.O.anySet: Posix.TTY.O.flags * Posix.TTY.O.flags -> bool (* @ $(SML_LIB)/basis/posix/flags.sml 34.11-34.16 *)
val Posix.TTY.O.clear: Posix.TTY.O.flags * Posix.TTY.O.flags -> Posix.TTY.O.flags (* @ $(SML_LIB)/basis/posix/flags.sml 30.11-30.15 *)
val Posix.TTY.O.flags: Posix.TTY.O.flags list -> Posix.TTY.O.flags (* @ $(SML_LIB)/basis/posix/flags.sml 26.11-26.15 *)
val Posix.TTY.O.fromWord: LargeWord.word -> Posix.TTY.O.flags (* @ $(SML_LIB)/basis/posix/flags.sml 24.11-24.18 *)
val Posix.TTY.O.intersect: Posix.TTY.O.flags list -> Posix.TTY.O.flags (* @ $(SML_LIB)/basis/posix/flags.sml 28.11-28.19 *)
val Posix.TTY.O.opost: Posix.TTY.O.flags (* @ $(SML_LIB)/basis/posix/tty.sml 104.17-104.21 *)
val Posix.TTY.O.toWord: Posix.TTY.O.flags -> LargeWord.word (* @ $(SML_LIB)/basis/posix/flags.sml 23.11-23.16 *)
structure Posix.TTY.TC:
   sig
      type flow_action = Posix.TTY.TC.flow_action
      type queue_sel = Posix.TTY.TC.queue_sel
      type set_action = Posix.TTY.TC.set_action
      val drain: Posix.TTY.file_desc -> unit
      val flow: Posix.TTY.file_desc * Posix.TTY.TC.flow_action -> unit
      val flush: Posix.TTY.file_desc * Posix.TTY.TC.queue_sel -> unit
      val getattr: Posix.TTY.file_desc -> Posix.TTY.termios
      val getpgrp: Posix.TTY.file_desc -> Posix.TTY.pid
      val iflush: Posix.TTY.TC.queue_sel
      val ioff: Posix.TTY.TC.flow_action
      val ioflush: Posix.TTY.TC.queue_sel
      val ion: Posix.TTY.TC.flow_action
      val oflush: Posix.TTY.TC.queue_sel
      val ooff: Posix.TTY.TC.flow_action
      val oon: Posix.TTY.TC.flow_action
      val sadrain: Posix.TTY.TC.set_action
      val saflush: Posix.TTY.TC.set_action
      val sanow: Posix.TTY.TC.set_action
      val sendbreak: Posix.TTY.file_desc * int -> unit
      val setattr: Posix.TTY.file_desc * Posix.TTY.TC.set_action * Posix.TTY.termios -> unit
      val setpgrp: Posix.TTY.file_desc * Posix.TTY.pid -> unit
   end
   (* @ $(SML_LIB)/basis/posix/tty.sml 214.17-214.18 *)
type Posix.TTY.TC.flow_action = Posix.TTY.TC.flow_action (* @ $(SML_LIB)/basis/posix/tty.sml 223.18-223.28 *)
type Posix.TTY.TC.queue_sel = Posix.TTY.TC.queue_sel (* @ $(SML_LIB)/basis/posix/tty.sml 229.18-229.26 *)
type Posix.TTY.TC.set_action = Posix.TTY.TC.set_action (* @ $(SML_LIB)/basis/posix/tty.sml 218.18-218.27 *)
val Posix.TTY.TC.drain: Posix.TTY.file_desc -> unit (* @ $(SML_LIB)/basis/posix/tty.sml 265.17-265.21 *)
val Posix.TTY.TC.flow: Posix.TTY.file_desc * Posix.TTY.TC.flow_action -> unit (* @ $(SML_LIB)/basis/posix/tty.sml 273.17-273.20 *)
val Posix.TTY.TC.flush: Posix.TTY.file_desc * Posix.TTY.TC.queue_sel -> unit (* @ $(SML_LIB)/basis/posix/tty.sml 269.17-269.21 *)
val Posix.TTY.TC.getattr: Posix.TTY.file_desc -> Posix.TTY.termios (* @ $(SML_LIB)/basis/posix/tty.sml 234.17-234.23 *)
val Posix.TTY.TC.getpgrp: Posix.TTY.file_desc -> Posix.TTY.pid (* @ $(SML_LIB)/basis/posix/tty.sml 277.17-277.23 *)
val Posix.TTY.TC.iflush: Posix.TTY.TC.queue_sel (* @ $(SML_LIB)/basis/posix/tty.sml 230.17-230.22 *)
val Posix.TTY.TC.ioff: Posix.TTY.TC.flow_action (* @ $(SML_LIB)/basis/posix/tty.sml 224.17-224.20 *)
val Posix.TTY.TC.ioflush: Posix.TTY.TC.queue_sel (* @ $(SML_LIB)/basis/posix/tty.sml 232.17-232.23 *)
val Posix.TTY.TC.ion: Posix.TTY.TC.flow_action (* @ $(SML_LIB)/basis/posix/tty.sml 225.17-225.19 *)
val Posix.TTY.TC.oflush: Posix.TTY.TC.queue_sel (* @ $(SML_LIB)/basis/posix/tty.sml 231.17-231.22 *)
val Posix.TTY.TC.ooff: Posix.TTY.TC.flow_action (* @ $(SML_LIB)/basis/posix/tty.sml 226.17-226.20 *)
val Posix.TTY.TC.oon: Posix.TTY.TC.flow_action (* @ $(SML_LIB)/basis/posix/tty.sml 227.17-227.19 *)
val Posix.TTY.TC.sadrain: Posix.TTY.TC.set_action (* @ $(SML_LIB)/basis/posix/tty.sml 219.17-219.23 *)
val Posix.TTY.TC.saflush: Posix.TTY.TC.set_action (* @ $(SML_LIB)/basis/posix/tty.sml 220.17-220.23 *)
val Posix.TTY.TC.sanow: Posix.TTY.TC.set_action (* @ $(SML_LIB)/basis/posix/tty.sml 221.17-221.21 *)
val Posix.TTY.TC.sendbreak: Posix.TTY.file_desc * int -> unit (* @ $(SML_LIB)/basis/posix/tty.sml 261.17-261.25 *)
val Posix.TTY.TC.setattr: Posix.TTY.file_desc * Posix.TTY.TC.set_action * Posix.TTY.termios -> unit (* @ $(SML_LIB)/basis/posix/tty.sml 248.17-248.23 *)
val Posix.TTY.TC.setpgrp: Posix.TTY.file_desc * Posix.TTY.pid -> unit (* @ $(SML_LIB)/basis/posix/tty.sml 282.17-282.23 *)
structure Posix.TTY.V:
   sig
      type cc = Posix.TTY.V.cc
      val cc: (int * char) list -> Posix.TTY.V.cc
      val eof: int
      val eol: int
      val erase: int
      val intr: int
      val kill: int
      val min: int
      val nccs: int
      val quit: int
      val start: int
      val stop: int
      val sub: Posix.TTY.V.cc * int -> char
      val susp: int
      val time: int
      val update: Posix.TTY.V.cc * (int * char) list -> Posix.TTY.V.cc
   end
   (* @ $(SML_LIB)/basis/posix/tty.sml 22.17-22.17 *)
type Posix.TTY.V.cc = Posix.TTY.V.cc (* @ $(SML_LIB)/basis/posix/tty.sml 38.18-38.19 *)
val Posix.TTY.V.cc: (int * char) list -> Posix.TTY.V.cc (* @ $(SML_LIB)/basis/posix/tty.sml 49.17-49.18 *)
val Posix.TTY.V.eof: int (* @ $(SML_LIB)/basis/posix/tty.sml 26.17-26.19 *)
val Posix.TTY.V.eol: int (* @ $(SML_LIB)/basis/posix/tty.sml 27.17-27.19 *)
val Posix.TTY.V.erase: int (* @ $(SML_LIB)/basis/posix/tty.sml 28.17-28.21 *)
val Posix.TTY.V.intr: int (* @ $(SML_LIB)/basis/posix/tty.sml 29.17-29.20 *)
val Posix.TTY.V.kill: int (* @ $(SML_LIB)/basis/posix/tty.sml 30.17-30.20 *)
val Posix.TTY.V.min: int (* @ $(SML_LIB)/basis/posix/tty.sml 31.17-31.19 *)
val Posix.TTY.V.nccs: int (* @ $(SML_LIB)/basis/posix/tty.sml 25.17-25.20 *)
val Posix.TTY.V.quit: int (* @ $(SML_LIB)/basis/posix/tty.sml 32.17-32.20 *)
val Posix.TTY.V.start: int (* @ $(SML_LIB)/basis/posix/tty.sml 35.17-35.21 *)
val Posix.TTY.V.stop: int (* @ $(SML_LIB)/basis/posix/tty.sml 36.17-36.20 *)
val Posix.TTY.V.sub: Posix.TTY.V.cc * int -> char (* @ $(SML_LIB)/basis/posix/tty.sml 61.17-61.19 *)
val Posix.TTY.V.susp: int (* @ $(SML_LIB)/basis/posix/tty.sml 33.17-33.20 *)
val Posix.TTY.V.time: int (* @ $(SML_LIB)/basis/posix/tty.sml 34.17-34.20 *)
val Posix.TTY.V.update: Posix.TTY.V.cc * (int * char) list -> Posix.TTY.V.cc (* @ $(SML_LIB)/basis/posix/tty.sml 54.17-54.22 *)
structure Real: REAL where type real = real (* @ $(SML_LIB)/basis/libs/basis-2002/top-level/top-level.sml 86.11-86.14 *)
type Real.real = real (* @ $(SML_LIB)/basis/real/real.sml 26.12-26.15 *)
val Real.!= : real * real -> bool (* @ $(SML_LIB)/basis/real/real.sml 176.14-176.15 *)
val Real.* : real * real -> real (* @ $(SML_LIB)/basis/real/real.sml 103.17-103.17 *)
val Real.*+ : real * real * real -> real (* @ $(SML_LIB)/basis/real/real.sml 101.17-101.18 *)
val Real.*- : real * real * real -> real (* @ $(SML_LIB)/basis/real/real.sml 102.17-102.18 *)
val Real.+ : real * real -> real (* @ $(SML_LIB)/basis/real/real.sml 104.17-104.17 *)
val Real.- : real * real -> real (* @ $(SML_LIB)/basis/real/real.sml 105.17-105.17 *)
val Real./ : real * real -> real (* @ $(SML_LIB)/basis/real/real.sml 106.17-106.17 *)
val Real.< : real * real -> bool (* @ $(SML_LIB)/basis/real/real.sml 107.17-107.17 *)
val Real.<= : real * real -> bool (* @ $(SML_LIB)/basis/real/real.sml 108.17-108.18 *)
val Real.== : real * real -> bool (* @ $(SML_LIB)/basis/real/real.sml 174.14-174.15 *)
val Real.> : real * real -> bool (* @ $(SML_LIB)/basis/real/real.sml 109.17-109.17 *)
val Real.>= : real * real -> bool (* @ $(SML_LIB)/basis/real/real.sml 110.17-110.18 *)
val Real.?= : real * real -> bool (* @ $(SML_LIB)/basis/real/real.sml 182.14-182.15 *)
val Real.abs: real -> real (* @ $(SML_LIB)/basis/real/real.sml 112.14-112.16 *)
val Real.ceil: real -> int (* @ $(SML_LIB)/basis/real/real.sml 859.11-859.14 *)
val Real.checkFloat: real -> real (* @ $(SML_LIB)/basis/real/real.sml 328.11-328.20 *)
val Real.class: real -> IEEEReal.float_class (* @ $(SML_LIB)/basis/real/real.sml 54.11-54.15 *)
val Real.compare: real * real -> order (* @ $(SML_LIB)/basis/real/real.sml 234.14-234.20 *)
val Real.compareReal: real * real -> IEEEReal.real_order (* @ $(SML_LIB)/basis/real/real.sml 223.14-223.24 *)
val Real.copySign: real * real -> real (* @ $(SML_LIB)/basis/real/real.sml 215.11-215.18 *)
val Real.floor: real -> int (* @ $(SML_LIB)/basis/real/real.sml 858.11-858.15 *)
val Real.fmt: StringCvt.realfmt -> real -> string (* @ $(SML_LIB)/basis/real/real.sml 607.14-607.16 *)
val Real.fromDecimal: {class: IEEEReal.float_class, digits: int list, exp: int, sign: bool} -> real option (* @ $(SML_LIB)/basis/real/real.sml 416.11-416.21 *)
val Real.fromInt: int -> real (* @ $(SML_LIB)/basis/real/real.sml 819.14-819.20 *)
val Real.fromLarge: IEEEReal.rounding_mode -> real -> real (* @ $(SML_LIB)/basis/real/real.sml 151.14-151.22 *)
val Real.fromLargeInt: LargeInt.int -> real (* @ $(SML_LIB)/basis/real/real.sml 831.14-831.25 *)
val Real.fromManExp: {exp: int, man: real} -> real (* @ $(SML_LIB)/basis/real/real.sml 289.11-289.20 *)
val Real.fromString: string -> real option (* @ $(SML_LIB)/basis/real/real.sml 426.11-426.20 *)
val Real.isFinite: real -> bool (* @ $(SML_LIB)/basis/real/real.sml 171.11-171.18 *)
val Real.isNan: real -> bool (* @ $(SML_LIB)/basis/real/real.sml 178.11-178.15 *)
val Real.isNormal: real -> bool (* @ $(SML_LIB)/basis/real/real.sml 180.11-180.18 *)
val Real.max: real * real -> real (* @ $(SML_LIB)/basis/real/real.sml 199.11-199.13 *)
val Real.maxFinite: real (* @ $(SML_LIB)/basis/real/real.sml 163.11-163.19 *)
val Real.min: real * real -> real (* @ $(SML_LIB)/basis/real/real.sml 193.11-193.13 *)
val Real.minNormalPos: real (* @ $(SML_LIB)/basis/real/real.sml 159.11-159.22 *)
val Real.minPos: real (* @ $(SML_LIB)/basis/real/real.sml 158.11-158.16 *)
val Real.negInf: real (* @ $(SML_LIB)/basis/real/real.sml 154.11-154.16 *)
val Real.nextAfter: real * real -> real (* @ $(SML_LIB)/basis/real/real.sml 252.11-252.19 *)
val Real.posInf: real (* @ $(SML_LIB)/basis/real/real.sml 164.11-164.16 *)
val Real.precision: int (* @ $(SML_LIB)/basis/real/real.sml 33.14-33.22 *)
val Real.radix: int (* @ $(SML_LIB)/basis/real/real.sml 34.14-34.18 *)
val Real.realCeil: real -> real (* @ $(SML_LIB)/basis/real/real.sml 333.11-333.18 *)
val Real.realFloor: real -> real (* @ $(SML_LIB)/basis/real/real.sml 334.11-334.19 *)
val Real.realMod: real -> real (* @ $(SML_LIB)/basis/real/real.sml 326.11-326.17 *)
val Real.realRound: real -> real (* @ $(SML_LIB)/basis/real/real.sml 339.11-339.19 *)
val Real.realTrunc: real -> real (* @ $(SML_LIB)/basis/real/real.sml 335.11-335.19 *)
val Real.rem: real * real -> real (* @ $(SML_LIB)/basis/real/real.sml 341.11-341.13 *)
val Real.round: real -> int (* @ $(SML_LIB)/basis/real/real.sml 861.11-861.15 *)
val Real.sameSign: real * real -> bool (* @ $(SML_LIB)/basis/real/real.sml 213.11-213.18 *)
val Real.scan: ('a -> (char * 'a) option) -> 'a -> (real * 'a) option (* @ $(SML_LIB)/basis/real/real.sml 418.11-418.14 *)
val Real.sign: real -> int (* @ $(SML_LIB)/basis/real/real.sml 205.11-205.14 *)
val Real.signBit: real -> bool (* @ $(SML_LIB)/basis/real/real.sml 211.11-211.17 *)
val Real.split: real -> {frac: real, whole: real} (* @ $(SML_LIB)/basis/real/real.sml 303.14-303.18 *)
val Real.toDecimal: real -> {class: IEEEReal.float_class, digits: int list, exp: int, sign: bool} (* @ $(SML_LIB)/basis/real/real.sml 455.11-455.19 *)
val Real.toInt: IEEEReal.rounding_mode -> real -> int (* @ $(SML_LIB)/basis/real/real.sml 843.14-843.18 *)
val Real.toLarge: real -> real (* @ $(SML_LIB)/basis/real/real.sml 142.14-142.20 *)
val Real.toLargeInt: IEEEReal.rounding_mode -> real -> LargeInt.int (* @ $(SML_LIB)/basis/real/real.sml 855.14-855.23 *)
val Real.toManExp: real -> {exp: int, man: real} (* @ $(SML_LIB)/basis/real/real.sml 271.14-271.21 *)
val Real.toString: real -> string (* @ $(SML_LIB)/basis/real/real.sml 664.11-664.18 *)
val Real.trunc: real -> int (* @ $(SML_LIB)/basis/real/real.sml 860.11-860.15 *)
val Real.unordered: real * real -> bool (* @ $(SML_LIB)/basis/real/real.sml 242.11-242.19 *)
val Real.~ : real -> real (* @ $(SML_LIB)/basis/real/real.sml 111.14-111.14 *)
structure Real.Math: MATH where type real = real (* @ $(SML_LIB)/basis/real/real.sml 1002.17-1002.20 *)
type Real.Math.real = real (* @ $(SML_LIB)/basis/primitive/prim-real.sml 205.18-205.21 *)
val Real.Math.acos: real -> real (* @ $(SML_LIB)/basis/real/real.sml 1016.20-1016.23 *)
val Real.Math.asin: real -> real (* @ $(SML_LIB)/basis/real/real.sml 1017.20-1017.23 *)
val Real.Math.atan: real -> real (* @ $(SML_LIB)/basis/primitive/prim-real.sml 209.17-209.20 *)
val Real.Math.atan2: real * real -> real (* @ $(SML_LIB)/basis/primitive/prim-real.sml 210.17-210.21 *)
val Real.Math.cos: real -> real (* @ $(SML_LIB)/basis/primitive/prim-real.sml 211.17-211.19 *)
val Real.Math.cosh: real -> real (* @ $(SML_LIB)/basis/real/real.sml 1099.17-1099.20 *)
val Real.Math.e: real (* @ $(SML_LIB)/basis/primitive/prim-real.sml 213.17-213.17 *)
val Real.Math.exp: real -> real (* @ $(SML_LIB)/basis/real/real.sml 1028.17-1028.19 *)
val Real.Math.ln: real -> real (* @ $(SML_LIB)/basis/real/real.sml 1023.20-1023.21 *)
val Real.Math.log10: real -> real (* @ $(SML_LIB)/basis/real/real.sml 1024.20-1024.24 *)
val Real.Math.pi: real (* @ $(SML_LIB)/basis/primitive/prim-real.sml 217.17-217.18 *)
val Real.Math.pow: real * real -> real (* @ $(SML_LIB)/basis/real/real.sml 1055.17-1055.19 *)
val Real.Math.sin: real -> real (* @ $(SML_LIB)/basis/primitive/prim-real.sml 219.17-219.19 *)
val Real.Math.sinh: real -> real (* @ $(SML_LIB)/basis/real/real.sml 1105.17-1105.20 *)
val Real.Math.sqrt: real -> real (* @ $(SML_LIB)/basis/primitive/prim-real.sml 221.17-221.20 *)
val Real.Math.tan: real -> real (* @ $(SML_LIB)/basis/primitive/prim-real.sml 222.17-222.19 *)
val Real.Math.tanh: real -> real (* @ $(SML_LIB)/basis/real/real.sml 1111.17-1111.20 *)
structure Real32: REAL where type real = Real32.real (* @ $(SML_LIB)/basis/libs/basis-2002/top-level/top-level.sml 83.11-83.16 *)
type Real32.real = Real32.real (* @ $(SML_LIB)/basis/real/real.sml 26.12-26.15 *)
val Real32.!= : Real32.real * Real32.real -> bool (* @ $(SML_LIB)/basis/real/real.sml 176.14-176.15 *)
val Real32.* : Real32.real * Real32.real -> Real32.real (* @ $(SML_LIB)/basis/real/real.sml 103.17-103.17 *)
val Real32.*+ : Real32.real * Real32.real * Real32.real -> Real32.real (* @ $(SML_LIB)/basis/real/real.sml 101.17-101.18 *)
val Real32.*- : Real32.real * Real32.real * Real32.real -> Real32.real (* @ $(SML_LIB)/basis/real/real.sml 102.17-102.18 *)
val Real32.+ : Real32.real * Real32.real -> Real32.real (* @ $(SML_LIB)/basis/real/real.sml 104.17-104.17 *)
val Real32.- : Real32.real * Real32.real -> Real32.real (* @ $(SML_LIB)/basis/real/real.sml 105.17-105.17 *)
val Real32./ : Real32.real * Real32.real -> Real32.real (* @ $(SML_LIB)/basis/real/real.sml 106.17-106.17 *)
val Real32.< : Real32.real * Real32.real -> bool (* @ $(SML_LIB)/basis/real/real.sml 107.17-107.17 *)
val Real32.<= : Real32.real * Real32.real -> bool (* @ $(SML_LIB)/basis/real/real.sml 108.17-108.18 *)
val Real32.== : Real32.real * Real32.real -> bool (* @ $(SML_LIB)/basis/real/real.sml 174.14-174.15 *)
val Real32.> : Real32.real * Real32.real -> bool (* @ $(SML_LIB)/basis/real/real.sml 109.17-109.17 *)
val Real32.>= : Real32.real * Real32.real -> bool (* @ $(SML_LIB)/basis/real/real.sml 110.17-110.18 *)
val Real32.?= : Real32.real * Real32.real -> bool (* @ $(SML_LIB)/basis/real/real.sml 182.14-182.15 *)
val Real32.abs: Real32.real -> Real32.real (* @ $(SML_LIB)/basis/real/real.sml 112.14-112.16 *)
val Real32.ceil: Real32.real -> int (* @ $(SML_LIB)/basis/real/real.sml 859.11-859.14 *)
val Real32.checkFloat: Real32.real -> Real32.real (* @ $(SML_LIB)/basis/real/real.sml 328.11-328.20 *)
val Real32.class: Real32.real -> IEEEReal.float_class (* @ $(SML_LIB)/basis/real/real.sml 54.11-54.15 *)
val Real32.compare: Real32.real * Real32.real -> order (* @ $(SML_LIB)/basis/real/real.sml 234.14-234.20 *)
val Real32.compareReal: Real32.real * Real32.real -> IEEEReal.real_order (* @ $(SML_LIB)/basis/real/real.sml 223.14-223.24 *)
val Real32.copySign: Real32.real * Real32.real -> Real32.real (* @ $(SML_LIB)/basis/real/real.sml 215.11-215.18 *)
val Real32.floor: Real32.real -> int (* @ $(SML_LIB)/basis/real/real.sml 858.11-858.15 *)
val Real32.fmt: StringCvt.realfmt -> Real32.real -> string (* @ $(SML_LIB)/basis/real/real.sml 607.14-607.16 *)
val Real32.fromDecimal: {class: IEEEReal.float_class, digits: int list, exp: int, sign: bool} -> Real32.real option (* @ $(SML_LIB)/basis/real/real.sml 416.11-416.21 *)
val Real32.fromInt: int -> Real32.real (* @ $(SML_LIB)/basis/real/real.sml 819.14-819.20 *)
val Real32.fromLarge: IEEEReal.rounding_mode -> real -> Real32.real (* @ $(SML_LIB)/basis/real/real.sml 151.14-151.22 *)
val Real32.fromLargeInt: LargeInt.int -> Real32.real (* @ $(SML_LIB)/basis/real/real.sml 831.14-831.25 *)
val Real32.fromManExp: {exp: int, man: Real32.real} -> Real32.real (* @ $(SML_LIB)/basis/real/real.sml 289.11-289.20 *)
val Real32.fromString: string -> Real32.real option (* @ $(SML_LIB)/basis/real/real.sml 426.11-426.20 *)
val Real32.isFinite: Real32.real -> bool (* @ $(SML_LIB)/basis/real/real.sml 171.11-171.18 *)
val Real32.isNan: Real32.real -> bool (* @ $(SML_LIB)/basis/real/real.sml 178.11-178.15 *)
val Real32.isNormal: Real32.real -> bool (* @ $(SML_LIB)/basis/real/real.sml 180.11-180.18 *)
val Real32.max: Real32.real * Real32.real -> Real32.real (* @ $(SML_LIB)/basis/real/real.sml 199.11-199.13 *)
val Real32.maxFinite: Real32.real (* @ $(SML_LIB)/basis/real/real.sml 163.11-163.19 *)
val Real32.min: Real32.real * Real32.real -> Real32.real (* @ $(SML_LIB)/basis/real/real.sml 193.11-193.13 *)
val Real32.minNormalPos: Real32.real (* @ $(SML_LIB)/basis/real/real.sml 159.11-159.22 *)
val Real32.minPos: Real32.real (* @ $(SML_LIB)/basis/real/real.sml 158.11-158.16 *)
val Real32.negInf: Real32.real (* @ $(SML_LIB)/basis/real/real.sml 154.11-154.16 *)
val Real32.nextAfter: Real32.real * Real32.real -> Real32.real (* @ $(SML_LIB)/basis/real/real.sml 252.11-252.19 *)
val Real32.posInf: Real32.real (* @ $(SML_LIB)/basis/real/real.sml 164.11-164.16 *)
val Real32.precision: int (* @ $(SML_LIB)/basis/real/real.sml 33.14-33.22 *)
val Real32.radix: int (* @ $(SML_LIB)/basis/real/real.sml 34.14-34.18 *)
val Real32.realCeil: Real32.real -> Real32.real (* @ $(SML_LIB)/basis/real/real.sml 333.11-333.18 *)
val Real32.realFloor: Real32.real -> Real32.real (* @ $(SML_LIB)/basis/real/real.sml 334.11-334.19 *)
val Real32.realMod: Real32.real -> Real32.real (* @ $(SML_LIB)/basis/real/real.sml 326.11-326.17 *)
val Real32.realRound: Real32.real -> Real32.real (* @ $(SML_LIB)/basis/real/real.sml 339.11-339.19 *)
val Real32.realTrunc: Real32.real -> Real32.real (* @ $(SML_LIB)/basis/real/real.sml 335.11-335.19 *)
val Real32.rem: Real32.real * Real32.real -> Real32.real (* @ $(SML_LIB)/basis/real/real.sml 341.11-341.13 *)
val Real32.round: Real32.real -> int (* @ $(SML_LIB)/basis/real/real.sml 861.11-861.15 *)
val Real32.sameSign: Real32.real * Real32.real -> bool (* @ $(SML_LIB)/basis/real/real.sml 213.11-213.18 *)
val Real32.scan: ('a -> (char * 'a) option) -> 'a -> (Real32.real * 'a) option (* @ $(SML_LIB)/basis/real/real.sml 418.11-418.14 *)
val Real32.sign: Real32.real -> int (* @ $(SML_LIB)/basis/real/real.sml 205.11-205.14 *)
val Real32.signBit: Real32.real -> bool (* @ $(SML_LIB)/basis/real/real.sml 211.11-211.17 *)
val Real32.split: Real32.real -> {frac: Real32.real, whole: Real32.real} (* @ $(SML_LIB)/basis/real/real.sml 303.14-303.18 *)
val Real32.toDecimal: Real32.real -> {class: IEEEReal.float_class, digits: int list, exp: int, sign: bool} (* @ $(SML_LIB)/basis/real/real.sml 455.11-455.19 *)
val Real32.toInt: IEEEReal.rounding_mode -> Real32.real -> int (* @ $(SML_LIB)/basis/real/real.sml 843.14-843.18 *)
val Real32.toLarge: Real32.real -> real (* @ $(SML_LIB)/basis/real/real.sml 142.14-142.20 *)
val Real32.toLargeInt: IEEEReal.rounding_mode -> Real32.real -> LargeInt.int (* @ $(SML_LIB)/basis/real/real.sml 855.14-855.23 *)
val Real32.toManExp: Real32.real -> {exp: int, man: Real32.real} (* @ $(SML_LIB)/basis/real/real.sml 271.14-271.21 *)
val Real32.toString: Real32.real -> string (* @ $(SML_LIB)/basis/real/real.sml 664.11-664.18 *)
val Real32.trunc: Real32.real -> int (* @ $(SML_LIB)/basis/real/real.sml 860.11-860.15 *)
val Real32.unordered: Real32.real * Real32.real -> bool (* @ $(SML_LIB)/basis/real/real.sml 242.11-242.19 *)
val Real32.~ : Real32.real -> Real32.real (* @ $(SML_LIB)/basis/real/real.sml 111.14-111.14 *)
structure Real32.Math: MATH where type real = Real32.real (* @ $(SML_LIB)/basis/real/real.sml 1002.17-1002.20 *)
type Real32.Math.real = Real32.real (* @ $(SML_LIB)/basis/primitive/prim-real.sml 115.18-115.21 *)
val Real32.Math.acos: Real32.real -> Real32.real (* @ $(SML_LIB)/basis/real/real.sml 1016.20-1016.23 *)
val Real32.Math.asin: Real32.real -> Real32.real (* @ $(SML_LIB)/basis/real/real.sml 1017.20-1017.23 *)
val Real32.Math.atan: Real32.real -> Real32.real (* @ $(SML_LIB)/basis/primitive/prim-real.sml 119.17-119.20 *)
val Real32.Math.atan2: Real32.real * Real32.real -> Real32.real (* @ $(SML_LIB)/basis/primitive/prim-real.sml 120.17-120.21 *)
val Real32.Math.cos: Real32.real -> Real32.real (* @ $(SML_LIB)/basis/primitive/prim-real.sml 121.17-121.19 *)
val Real32.Math.cosh: Real32.real -> Real32.real (* @ $(SML_LIB)/basis/real/real.sml 1099.17-1099.20 *)
val Real32.Math.e: Real32.real (* @ $(SML_LIB)/basis/primitive/prim-real.sml 123.17-123.17 *)
val Real32.Math.exp: Real32.real -> Real32.real (* @ $(SML_LIB)/basis/real/real.sml 1028.17-1028.19 *)
val Real32.Math.ln: Real32.real -> Real32.real (* @ $(SML_LIB)/basis/real/real.sml 1023.20-1023.21 *)
val Real32.Math.log10: Real32.real -> Real32.real (* @ $(SML_LIB)/basis/real/real.sml 1024.20-1024.24 *)
val Real32.Math.pi: Real32.real (* @ $(SML_LIB)/basis/primitive/prim-real.sml 127.17-127.18 *)
val Real32.Math.pow: Real32.real * Real32.real -> Real32.real (* @ $(SML_LIB)/basis/real/real.sml 1055.17-1055.19 *)
val Real32.Math.sin: Real32.real -> Real32.real (* @ $(SML_LIB)/basis/primitive/prim-real.sml 129.17-129.19 *)
val Real32.Math.sinh: Real32.real -> Real32.real (* @ $(SML_LIB)/basis/real/real.sml 1105.17-1105.20 *)
val Real32.Math.sqrt: Real32.real -> Real32.real (* @ $(SML_LIB)/basis/primitive/prim-real.sml 131.17-131.20 *)
val Real32.Math.tan: Real32.real -> Real32.real (* @ $(SML_LIB)/basis/primitive/prim-real.sml 132.17-132.19 *)
val Real32.Math.tanh: Real32.real -> Real32.real (* @ $(SML_LIB)/basis/real/real.sml 1111.17-1111.20 *)
structure Real32Array: MONO_ARRAY where type array = Real32Array.array where type elem = Real32.real where type vector = Real32Vector.vector (* @ $(SML_LIB)/basis/libs/basis-2002/top-level/top-level.sml 49.11-49.21 *)
type Real32Array.array = Real32Array.array (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array.fun 23.12-23.16 *)
type Real32Array.elem = Real32.real (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array.fun 22.12-22.15 *)
type Real32Array.vector = Real32Vector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array.fun 24.12-24.17 *)
val Real32Array.all: (Real32.real -> bool) -> Real32Array.array -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 476.13-476.15 *)
val Real32Array.app: (Real32.real -> unit) -> Real32Array.array -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 464.13-464.15 *)
val Real32Array.appi: (int * Real32.real -> unit) -> Real32Array.array -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 463.13-463.16 *)
val Real32Array.array: int * Real32.real -> Real32Array.array (* @ $(SML_LIB)/basis/arrays-and-vectors/array.sml 34.11-34.15 *)
val Real32Array.collate: (Real32.real * Real32.real -> order) -> Real32Array.array * Real32Array.array -> order (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 477.13-477.19 *)
val Real32Array.copy: {di: int, dst: Real32Array.array, src: Real32Array.array} -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 457.13-457.16 *)
val Real32Array.copyVec: {di: int, dst: Real32Array.array, src: Real32Vector.vector} -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array.sml 37.11-37.17 *)
val Real32Array.exists: (Real32.real -> bool) -> Real32Array.array -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 474.13-474.18 *)
val Real32Array.find: (Real32.real -> bool) -> Real32Array.array -> Real32.real option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 472.13-472.16 *)
val Real32Array.findi: (int * Real32.real -> bool) -> Real32Array.array -> (int * Real32.real) option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 471.13-471.17 *)
val Real32Array.foldl: (Real32.real * 'a -> 'a) -> 'a -> Real32Array.array -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 468.13-468.17 *)
val Real32Array.foldli: (int * Real32.real * 'a -> 'a) -> 'a -> Real32Array.array -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 467.13-467.18 *)
val Real32Array.foldr: (Real32.real * 'a -> 'a) -> 'a -> Real32Array.array -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 470.13-470.17 *)
val Real32Array.foldri: (int * Real32.real * 'a -> 'a) -> 'a -> Real32Array.array -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 469.13-469.18 *)
val Real32Array.fromList: Real32.real list -> Real32Array.array (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 122.11-122.18 *)
val Real32Array.length: Real32Array.array -> int (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 90.11-90.16 *)
val Real32Array.maxLen: int (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 88.11-88.16 *)
val Real32Array.modify: (Real32.real -> Real32.real) -> Real32Array.array -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array.sml 40.11-40.16 *)
val Real32Array.modifyi: (int * Real32.real -> Real32.real) -> Real32Array.array -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array.sml 39.11-39.17 *)
val Real32Array.sub: Real32Array.array * int -> Real32.real (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 450.13-450.15 *)
val Real32Array.tabulate: int * (int -> Real32.real) -> Real32Array.array (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 114.11-114.18 *)
val Real32Array.update: Real32Array.array * int * Real32.real -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 452.13-452.18 *)
val Real32Array.vector: Real32Array.array -> Real32Vector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/array.sml 36.11-36.16 *)
structure Real32Array2: MONO_ARRAY2 where type array = Real32Array2.array where type elem = Real32.real where type vector = Real32Vector.vector (* @ $(SML_LIB)/basis/libs/basis-2002/top-level/top-level.sml 50.11-50.22 *)
type Real32Array2.array = Real32Array2.array (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array2.fun 18.12-18.16 *)
type Real32Array2.elem = Real32.real (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array2.fun 15.12-15.15 *)
type Real32Array2.region = {base: Real32Array2.array, col: int, ncols: int option, nrows: int option, row: int} (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array2.fun 19.12-19.17 *)
datatype Real32Array2.traversal = ColMajor | RowMajor (* = datatype Array2.traversal *) (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 106.16-106.24 *)
type Real32Array2.vector = Real32Vector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array2.fun 16.12-16.17 *)
con Real32Array2.ColMajor: Array2.traversal (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 106.39-106.46 *)
con Real32Array2.RowMajor: Array2.traversal (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 106.28-106.35 *)
val Real32Array2.app: Array2.traversal -> (Real32.real -> unit) -> Real32Array2.array -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 294.11-294.13 *)
val Real32Array2.appi: Array2.traversal -> (int * int * Real32.real -> unit) -> {base: Real32Array2.array, col: int, ncols: int option, nrows: int option, row: int} -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 291.11-291.14 *)
val Real32Array2.array: int * int * Real32.real -> Real32Array2.array (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 140.14-140.18 *)
val Real32Array2.column: Real32Array2.array * int -> Real32Vector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 237.11-237.16 *)
val Real32Array2.copy: {dst: Real32Array2.array, dst_col: int, dst_row: int, src: {base: Real32Array2.array, col: int, ncols: int option, nrows: int option, row: int}} -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 309.11-309.14 *)
val Real32Array2.dimensions: Real32Array2.array -> int * int (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 33.11-33.20 *)
val Real32Array2.fold: Array2.traversal -> (Real32.real * 'a -> 'a) -> 'a -> Real32Array2.array -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 288.11-288.14 *)
val Real32Array2.foldi: Array2.traversal -> (int * int * Real32.real * 'a -> 'a) -> 'a -> {base: Real32Array2.array, col: int, ncols: int option, nrows: int option, row: int} -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 283.11-283.15 *)
val Real32Array2.fromList: Real32.real list list -> Real32Array2.array (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 188.14-188.21 *)
val Real32Array2.modify: Array2.traversal -> (Real32.real -> Real32.real) -> Real32Array2.array -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 299.11-299.16 *)
val Real32Array2.modifyi: Array2.traversal -> (int * int * Real32.real -> Real32.real) -> {base: Real32Array2.array, col: int, ncols: int option, nrows: int option, row: int} -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 296.11-296.17 *)
val Real32Array2.nCols: Real32Array2.array -> int (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 38.11-38.15 *)
val Real32Array2.nRows: Real32Array2.array -> int (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 36.11-36.15 *)
val Real32Array2.row: Real32Array2.array * int -> Real32Vector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 222.11-222.13 *)
val Real32Array2.sub: Real32Array2.array * int * int -> Real32.real (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 182.14-182.16 *)
val Real32Array2.tabulate: Array2.traversal -> int * int * (int * int -> Real32.real) -> Real32Array2.array (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 301.11-301.18 *)
val Real32Array2.update: Real32Array2.array * int * int * Real32.real -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 184.14-184.19 *)
structure Real32ArraySlice: MONO_ARRAY_SLICE where type array = Real32Array.array where type elem = Real32.real where type slice = Real32ArraySlice.slice where type vector = Real32Vector.vector where type vector_slice = Real32VectorSlice.slice (* @ $(SML_LIB)/basis/libs/basis-extra/top-level/basis.sml 165.17-165.32 *)
type Real32ArraySlice.array = Real32Array.array (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array.fun 35.18-35.22 *)
type Real32ArraySlice.elem = Real32.real (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array.fun 34.18-34.21 *)
type Real32ArraySlice.slice = Real32ArraySlice.slice (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array.fun 36.18-36.22 *)
type Real32ArraySlice.vector = Real32Vector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array.fun 37.18-37.23 *)
type Real32ArraySlice.vector_slice = Real32VectorSlice.slice (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array.fun 38.18-38.29 *)
val Real32ArraySlice.all: (Real32.real -> bool) -> Real32ArraySlice.slice -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 235.17-235.19 *)
val Real32ArraySlice.app: (Real32.real -> unit) -> Real32ArraySlice.slice -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 226.17-226.19 *)
val Real32ArraySlice.appi: (int * Real32.real -> unit) -> Real32ArraySlice.slice -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 225.17-225.20 *)
val Real32ArraySlice.base: Real32ArraySlice.slice -> Real32Array.array * int * int (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 208.17-208.20 *)
val Real32ArraySlice.collate: (Real32.real * Real32.real -> order) -> Real32ArraySlice.slice * Real32ArraySlice.slice -> order (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 236.17-236.23 *)
val Real32ArraySlice.copy: {di: int, dst: Real32Array.array, src: Real32ArraySlice.slice} -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 185.17-185.20 *)
val Real32ArraySlice.copyVec: {di: int, dst: Real32Array.array, src: Real32VectorSlice.slice} -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array.sml 28.17-28.23 *)
val Real32ArraySlice.exists: (Real32.real -> bool) -> Real32ArraySlice.slice -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 233.17-233.22 *)
val Real32ArraySlice.find: (Real32.real -> bool) -> Real32ArraySlice.slice -> Real32.real option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 231.17-231.20 *)
val Real32ArraySlice.findi: (int * Real32.real -> bool) -> Real32ArraySlice.slice -> (int * Real32.real) option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 229.17-229.21 *)
val Real32ArraySlice.foldl: (Real32.real * 'a -> 'a) -> 'a -> Real32ArraySlice.slice -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 223.17-223.21 *)
val Real32ArraySlice.foldli: (int * Real32.real * 'a -> 'a) -> 'a -> Real32ArraySlice.slice -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 221.17-221.22 *)
val Real32ArraySlice.foldr: (Real32.real * 'a -> 'a) -> 'a -> Real32ArraySlice.slice -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 224.17-224.21 *)
val Real32ArraySlice.foldri: (int * Real32.real * 'a -> 'a) -> 'a -> Real32ArraySlice.slice -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 222.17-222.22 *)
val Real32ArraySlice.full: Real32Array.array -> Real32ArraySlice.slice (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 192.17-192.20 *)
val Real32ArraySlice.getItem: Real32ArraySlice.slice -> (Real32.real * Real32ArraySlice.slice) option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 220.17-220.23 *)
val Real32ArraySlice.isEmpty: Real32ArraySlice.slice -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 219.17-219.23 *)
val Real32ArraySlice.length: Real32ArraySlice.slice -> int (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 134.17-134.22 *)
val Real32ArraySlice.modify: (Real32.real -> Real32.real) -> Real32ArraySlice.slice -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array.sml 31.17-31.22 *)
val Real32ArraySlice.modifyi: (int * Real32.real -> Real32.real) -> Real32ArraySlice.slice -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array.sml 30.17-30.23 *)
val Real32ArraySlice.slice: Real32Array.array * int * int option -> Real32ArraySlice.slice (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 206.17-206.21 *)
val Real32ArraySlice.sub: Real32ArraySlice.slice * int -> Real32.real (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 142.17-142.19 *)
val Real32ArraySlice.subslice: Real32ArraySlice.slice * int * int option -> Real32ArraySlice.slice (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 199.17-199.24 *)
val Real32ArraySlice.update: Real32ArraySlice.slice * int * Real32.real -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 155.17-155.22 *)
val Real32ArraySlice.vector: Real32ArraySlice.slice -> Real32Vector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/array.sml 27.17-27.22 *)
structure Real32Vector: MONO_VECTOR where type elem = Real32.real where type vector = Real32Vector.vector (* @ $(SML_LIB)/basis/libs/basis-2002/top-level/top-level.sml 51.11-51.22 *)
type Real32Vector.elem = Real32.real (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-vector.fun 15.12-15.15 *)
type Real32Vector.vector = Real32Vector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-vector.fun 16.12-16.17 *)
val Real32Vector.all: (Real32.real -> bool) -> Real32Vector.vector -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 476.13-476.15 *)
val Real32Vector.app: (Real32.real -> unit) -> Real32Vector.vector -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 464.13-464.15 *)
val Real32Vector.appi: (int * Real32.real -> unit) -> Real32Vector.vector -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 463.13-463.16 *)
val Real32Vector.collate: (Real32.real * Real32.real -> order) -> Real32Vector.vector * Real32Vector.vector -> order (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 477.13-477.19 *)
val Real32Vector.concat: Real32Vector.vector list -> Real32Vector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 462.13-462.18 *)
val Real32Vector.exists: (Real32.real -> bool) -> Real32Vector.vector -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 474.13-474.18 *)
val Real32Vector.find: (Real32.real -> bool) -> Real32Vector.vector -> Real32.real option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 472.13-472.16 *)
val Real32Vector.findi: (int * Real32.real -> bool) -> Real32Vector.vector -> (int * Real32.real) option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 471.13-471.17 *)
val Real32Vector.foldl: (Real32.real * 'a -> 'a) -> 'a -> Real32Vector.vector -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 468.13-468.17 *)
val Real32Vector.foldli: (int * Real32.real * 'a -> 'a) -> 'a -> Real32Vector.vector -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 467.13-467.18 *)
val Real32Vector.foldr: (Real32.real * 'a -> 'a) -> 'a -> Real32Vector.vector -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 470.13-470.17 *)
val Real32Vector.foldri: (int * Real32.real * 'a -> 'a) -> 'a -> Real32Vector.vector -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 469.13-469.18 *)
val Real32Vector.fromList: Real32.real list -> Real32Vector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 122.11-122.18 *)
val Real32Vector.length: Real32Vector.vector -> int (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 90.11-90.16 *)
val Real32Vector.map: (Real32.real -> Real32.real) -> Real32Vector.vector -> Real32Vector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 466.13-466.15 *)
val Real32Vector.mapi: (int * Real32.real -> Real32.real) -> Real32Vector.vector -> Real32Vector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 465.13-465.16 *)
val Real32Vector.maxLen: int (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 88.11-88.16 *)
val Real32Vector.sub: Real32Vector.vector * int -> Real32.real (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 450.13-450.15 *)
val Real32Vector.tabulate: int * (int -> Real32.real) -> Real32Vector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 114.11-114.18 *)
val Real32Vector.update: Real32Vector.vector * int * Real32.real -> Real32Vector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/vector.sml 30.11-30.16 *)
structure Real32VectorSlice: MONO_VECTOR_SLICE where type elem = Real32.real where type slice = Real32VectorSlice.slice where type vector = Real32Vector.vector (* @ $(SML_LIB)/basis/libs/basis-extra/top-level/basis.sml 167.17-167.33 *)
type Real32VectorSlice.elem = Real32.real (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-vector.fun 22.18-22.21 *)
type Real32VectorSlice.slice = Real32VectorSlice.slice (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-vector.fun 24.18-24.22 *)
type Real32VectorSlice.vector = Real32Vector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-vector.fun 23.18-23.23 *)
val Real32VectorSlice.all: (Real32.real -> bool) -> Real32VectorSlice.slice -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 235.17-235.19 *)
val Real32VectorSlice.app: (Real32.real -> unit) -> Real32VectorSlice.slice -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 226.17-226.19 *)
val Real32VectorSlice.appi: (int * Real32.real -> unit) -> Real32VectorSlice.slice -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 225.17-225.20 *)
val Real32VectorSlice.base: Real32VectorSlice.slice -> Real32Vector.vector * int * int (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 208.17-208.20 *)
val Real32VectorSlice.collate: (Real32.real * Real32.real -> order) -> Real32VectorSlice.slice * Real32VectorSlice.slice -> order (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 236.17-236.23 *)
val Real32VectorSlice.concat: Real32VectorSlice.slice list -> Real32Vector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 240.17-240.22 *)
val Real32VectorSlice.exists: (Real32.real -> bool) -> Real32VectorSlice.slice -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 233.17-233.22 *)
val Real32VectorSlice.find: (Real32.real -> bool) -> Real32VectorSlice.slice -> Real32.real option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 231.17-231.20 *)
val Real32VectorSlice.findi: (int * Real32.real -> bool) -> Real32VectorSlice.slice -> (int * Real32.real) option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 229.17-229.21 *)
val Real32VectorSlice.foldl: (Real32.real * 'a -> 'a) -> 'a -> Real32VectorSlice.slice -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 223.17-223.21 *)
val Real32VectorSlice.foldli: (int * Real32.real * 'a -> 'a) -> 'a -> Real32VectorSlice.slice -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 221.17-221.22 *)
val Real32VectorSlice.foldr: (Real32.real * 'a -> 'a) -> 'a -> Real32VectorSlice.slice -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 224.17-224.21 *)
val Real32VectorSlice.foldri: (int * Real32.real * 'a -> 'a) -> 'a -> Real32VectorSlice.slice -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 222.17-222.22 *)
val Real32VectorSlice.full: Real32Vector.vector -> Real32VectorSlice.slice (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 192.17-192.20 *)
val Real32VectorSlice.getItem: Real32VectorSlice.slice -> (Real32.real * Real32VectorSlice.slice) option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 220.17-220.23 *)
val Real32VectorSlice.isEmpty: Real32VectorSlice.slice -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 219.17-219.23 *)
val Real32VectorSlice.length: Real32VectorSlice.slice -> int (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 134.17-134.22 *)
val Real32VectorSlice.map: (Real32.real -> Real32.real) -> Real32VectorSlice.slice -> Real32Vector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 228.17-228.19 *)
val Real32VectorSlice.mapi: (int * Real32.real -> Real32.real) -> Real32VectorSlice.slice -> Real32Vector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 227.17-227.20 *)
val Real32VectorSlice.slice: Real32Vector.vector * int * int option -> Real32VectorSlice.slice (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 206.17-206.21 *)
val Real32VectorSlice.sub: Real32VectorSlice.slice * int -> Real32.real (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 142.17-142.19 *)
val Real32VectorSlice.subslice: Real32VectorSlice.slice * int * int option -> Real32VectorSlice.slice (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 199.17-199.24 *)
val Real32VectorSlice.vector: Real32VectorSlice.slice -> Real32Vector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/vector.sml 21.17-21.22 *)
structure Real64: REAL where type real = real (* @ $(SML_LIB)/basis/libs/basis-2002/top-level/top-level.sml 84.11-84.16 *)
type Real64.real = real (* @ $(SML_LIB)/basis/real/real.sml 26.12-26.15 *)
val Real64.!= : real * real -> bool (* @ $(SML_LIB)/basis/real/real.sml 176.14-176.15 *)
val Real64.* : real * real -> real (* @ $(SML_LIB)/basis/real/real.sml 103.17-103.17 *)
val Real64.*+ : real * real * real -> real (* @ $(SML_LIB)/basis/real/real.sml 101.17-101.18 *)
val Real64.*- : real * real * real -> real (* @ $(SML_LIB)/basis/real/real.sml 102.17-102.18 *)
val Real64.+ : real * real -> real (* @ $(SML_LIB)/basis/real/real.sml 104.17-104.17 *)
val Real64.- : real * real -> real (* @ $(SML_LIB)/basis/real/real.sml 105.17-105.17 *)
val Real64./ : real * real -> real (* @ $(SML_LIB)/basis/real/real.sml 106.17-106.17 *)
val Real64.< : real * real -> bool (* @ $(SML_LIB)/basis/real/real.sml 107.17-107.17 *)
val Real64.<= : real * real -> bool (* @ $(SML_LIB)/basis/real/real.sml 108.17-108.18 *)
val Real64.== : real * real -> bool (* @ $(SML_LIB)/basis/real/real.sml 174.14-174.15 *)
val Real64.> : real * real -> bool (* @ $(SML_LIB)/basis/real/real.sml 109.17-109.17 *)
val Real64.>= : real * real -> bool (* @ $(SML_LIB)/basis/real/real.sml 110.17-110.18 *)
val Real64.?= : real * real -> bool (* @ $(SML_LIB)/basis/real/real.sml 182.14-182.15 *)
val Real64.abs: real -> real (* @ $(SML_LIB)/basis/real/real.sml 112.14-112.16 *)
val Real64.ceil: real -> int (* @ $(SML_LIB)/basis/real/real.sml 859.11-859.14 *)
val Real64.checkFloat: real -> real (* @ $(SML_LIB)/basis/real/real.sml 328.11-328.20 *)
val Real64.class: real -> IEEEReal.float_class (* @ $(SML_LIB)/basis/real/real.sml 54.11-54.15 *)
val Real64.compare: real * real -> order (* @ $(SML_LIB)/basis/real/real.sml 234.14-234.20 *)
val Real64.compareReal: real * real -> IEEEReal.real_order (* @ $(SML_LIB)/basis/real/real.sml 223.14-223.24 *)
val Real64.copySign: real * real -> real (* @ $(SML_LIB)/basis/real/real.sml 215.11-215.18 *)
val Real64.floor: real -> int (* @ $(SML_LIB)/basis/real/real.sml 858.11-858.15 *)
val Real64.fmt: StringCvt.realfmt -> real -> string (* @ $(SML_LIB)/basis/real/real.sml 607.14-607.16 *)
val Real64.fromDecimal: {class: IEEEReal.float_class, digits: int list, exp: int, sign: bool} -> real option (* @ $(SML_LIB)/basis/real/real.sml 416.11-416.21 *)
val Real64.fromInt: int -> real (* @ $(SML_LIB)/basis/real/real.sml 819.14-819.20 *)
val Real64.fromLarge: IEEEReal.rounding_mode -> real -> real (* @ $(SML_LIB)/basis/real/real.sml 151.14-151.22 *)
val Real64.fromLargeInt: LargeInt.int -> real (* @ $(SML_LIB)/basis/real/real.sml 831.14-831.25 *)
val Real64.fromManExp: {exp: int, man: real} -> real (* @ $(SML_LIB)/basis/real/real.sml 289.11-289.20 *)
val Real64.fromString: string -> real option (* @ $(SML_LIB)/basis/real/real.sml 426.11-426.20 *)
val Real64.isFinite: real -> bool (* @ $(SML_LIB)/basis/real/real.sml 171.11-171.18 *)
val Real64.isNan: real -> bool (* @ $(SML_LIB)/basis/real/real.sml 178.11-178.15 *)
val Real64.isNormal: real -> bool (* @ $(SML_LIB)/basis/real/real.sml 180.11-180.18 *)
val Real64.max: real * real -> real (* @ $(SML_LIB)/basis/real/real.sml 199.11-199.13 *)
val Real64.maxFinite: real (* @ $(SML_LIB)/basis/real/real.sml 163.11-163.19 *)
val Real64.min: real * real -> real (* @ $(SML_LIB)/basis/real/real.sml 193.11-193.13 *)
val Real64.minNormalPos: real (* @ $(SML_LIB)/basis/real/real.sml 159.11-159.22 *)
val Real64.minPos: real (* @ $(SML_LIB)/basis/real/real.sml 158.11-158.16 *)
val Real64.negInf: real (* @ $(SML_LIB)/basis/real/real.sml 154.11-154.16 *)
val Real64.nextAfter: real * real -> real (* @ $(SML_LIB)/basis/real/real.sml 252.11-252.19 *)
val Real64.posInf: real (* @ $(SML_LIB)/basis/real/real.sml 164.11-164.16 *)
val Real64.precision: int (* @ $(SML_LIB)/basis/real/real.sml 33.14-33.22 *)
val Real64.radix: int (* @ $(SML_LIB)/basis/real/real.sml 34.14-34.18 *)
val Real64.realCeil: real -> real (* @ $(SML_LIB)/basis/real/real.sml 333.11-333.18 *)
val Real64.realFloor: real -> real (* @ $(SML_LIB)/basis/real/real.sml 334.11-334.19 *)
val Real64.realMod: real -> real (* @ $(SML_LIB)/basis/real/real.sml 326.11-326.17 *)
val Real64.realRound: real -> real (* @ $(SML_LIB)/basis/real/real.sml 339.11-339.19 *)
val Real64.realTrunc: real -> real (* @ $(SML_LIB)/basis/real/real.sml 335.11-335.19 *)
val Real64.rem: real * real -> real (* @ $(SML_LIB)/basis/real/real.sml 341.11-341.13 *)
val Real64.round: real -> int (* @ $(SML_LIB)/basis/real/real.sml 861.11-861.15 *)
val Real64.sameSign: real * real -> bool (* @ $(SML_LIB)/basis/real/real.sml 213.11-213.18 *)
val Real64.scan: ('a -> (char * 'a) option) -> 'a -> (real * 'a) option (* @ $(SML_LIB)/basis/real/real.sml 418.11-418.14 *)
val Real64.sign: real -> int (* @ $(SML_LIB)/basis/real/real.sml 205.11-205.14 *)
val Real64.signBit: real -> bool (* @ $(SML_LIB)/basis/real/real.sml 211.11-211.17 *)
val Real64.split: real -> {frac: real, whole: real} (* @ $(SML_LIB)/basis/real/real.sml 303.14-303.18 *)
val Real64.toDecimal: real -> {class: IEEEReal.float_class, digits: int list, exp: int, sign: bool} (* @ $(SML_LIB)/basis/real/real.sml 455.11-455.19 *)
val Real64.toInt: IEEEReal.rounding_mode -> real -> int (* @ $(SML_LIB)/basis/real/real.sml 843.14-843.18 *)
val Real64.toLarge: real -> real (* @ $(SML_LIB)/basis/real/real.sml 142.14-142.20 *)
val Real64.toLargeInt: IEEEReal.rounding_mode -> real -> LargeInt.int (* @ $(SML_LIB)/basis/real/real.sml 855.14-855.23 *)
val Real64.toManExp: real -> {exp: int, man: real} (* @ $(SML_LIB)/basis/real/real.sml 271.14-271.21 *)
val Real64.toString: real -> string (* @ $(SML_LIB)/basis/real/real.sml 664.11-664.18 *)
val Real64.trunc: real -> int (* @ $(SML_LIB)/basis/real/real.sml 860.11-860.15 *)
val Real64.unordered: real * real -> bool (* @ $(SML_LIB)/basis/real/real.sml 242.11-242.19 *)
val Real64.~ : real -> real (* @ $(SML_LIB)/basis/real/real.sml 111.14-111.14 *)
structure Real64.Math: MATH where type real = real (* @ $(SML_LIB)/basis/real/real.sml 1002.17-1002.20 *)
type Real64.Math.real = real (* @ $(SML_LIB)/basis/primitive/prim-real.sml 205.18-205.21 *)
val Real64.Math.acos: real -> real (* @ $(SML_LIB)/basis/real/real.sml 1016.20-1016.23 *)
val Real64.Math.asin: real -> real (* @ $(SML_LIB)/basis/real/real.sml 1017.20-1017.23 *)
val Real64.Math.atan: real -> real (* @ $(SML_LIB)/basis/primitive/prim-real.sml 209.17-209.20 *)
val Real64.Math.atan2: real * real -> real (* @ $(SML_LIB)/basis/primitive/prim-real.sml 210.17-210.21 *)
val Real64.Math.cos: real -> real (* @ $(SML_LIB)/basis/primitive/prim-real.sml 211.17-211.19 *)
val Real64.Math.cosh: real -> real (* @ $(SML_LIB)/basis/real/real.sml 1099.17-1099.20 *)
val Real64.Math.e: real (* @ $(SML_LIB)/basis/primitive/prim-real.sml 213.17-213.17 *)
val Real64.Math.exp: real -> real (* @ $(SML_LIB)/basis/real/real.sml 1028.17-1028.19 *)
val Real64.Math.ln: real -> real (* @ $(SML_LIB)/basis/real/real.sml 1023.20-1023.21 *)
val Real64.Math.log10: real -> real (* @ $(SML_LIB)/basis/real/real.sml 1024.20-1024.24 *)
val Real64.Math.pi: real (* @ $(SML_LIB)/basis/primitive/prim-real.sml 217.17-217.18 *)
val Real64.Math.pow: real * real -> real (* @ $(SML_LIB)/basis/real/real.sml 1055.17-1055.19 *)
val Real64.Math.sin: real -> real (* @ $(SML_LIB)/basis/primitive/prim-real.sml 219.17-219.19 *)
val Real64.Math.sinh: real -> real (* @ $(SML_LIB)/basis/real/real.sml 1105.17-1105.20 *)
val Real64.Math.sqrt: real -> real (* @ $(SML_LIB)/basis/primitive/prim-real.sml 221.17-221.20 *)
val Real64.Math.tan: real -> real (* @ $(SML_LIB)/basis/primitive/prim-real.sml 222.17-222.19 *)
val Real64.Math.tanh: real -> real (* @ $(SML_LIB)/basis/real/real.sml 1111.17-1111.20 *)
structure Real64Array: MONO_ARRAY where type array = Real64Array.array where type elem = real where type vector = Real64Vector.vector (* @ $(SML_LIB)/basis/libs/basis-2002/top-level/top-level.sml 52.11-52.21 *)
type Real64Array.array = Real64Array.array (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array.fun 23.12-23.16 *)
type Real64Array.elem = real (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array.fun 22.12-22.15 *)
type Real64Array.vector = Real64Vector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array.fun 24.12-24.17 *)
val Real64Array.all: (real -> bool) -> Real64Array.array -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 476.13-476.15 *)
val Real64Array.app: (real -> unit) -> Real64Array.array -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 464.13-464.15 *)
val Real64Array.appi: (int * real -> unit) -> Real64Array.array -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 463.13-463.16 *)
val Real64Array.array: int * real -> Real64Array.array (* @ $(SML_LIB)/basis/arrays-and-vectors/array.sml 34.11-34.15 *)
val Real64Array.collate: (real * real -> order) -> Real64Array.array * Real64Array.array -> order (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 477.13-477.19 *)
val Real64Array.copy: {di: int, dst: Real64Array.array, src: Real64Array.array} -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 457.13-457.16 *)
val Real64Array.copyVec: {di: int, dst: Real64Array.array, src: Real64Vector.vector} -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array.sml 37.11-37.17 *)
val Real64Array.exists: (real -> bool) -> Real64Array.array -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 474.13-474.18 *)
val Real64Array.find: (real -> bool) -> Real64Array.array -> real option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 472.13-472.16 *)
val Real64Array.findi: (int * real -> bool) -> Real64Array.array -> (int * real) option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 471.13-471.17 *)
val Real64Array.foldl: (real * 'a -> 'a) -> 'a -> Real64Array.array -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 468.13-468.17 *)
val Real64Array.foldli: (int * real * 'a -> 'a) -> 'a -> Real64Array.array -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 467.13-467.18 *)
val Real64Array.foldr: (real * 'a -> 'a) -> 'a -> Real64Array.array -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 470.13-470.17 *)
val Real64Array.foldri: (int * real * 'a -> 'a) -> 'a -> Real64Array.array -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 469.13-469.18 *)
val Real64Array.fromList: real list -> Real64Array.array (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 122.11-122.18 *)
val Real64Array.length: Real64Array.array -> int (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 90.11-90.16 *)
val Real64Array.maxLen: int (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 88.11-88.16 *)
val Real64Array.modify: (real -> real) -> Real64Array.array -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array.sml 40.11-40.16 *)
val Real64Array.modifyi: (int * real -> real) -> Real64Array.array -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array.sml 39.11-39.17 *)
val Real64Array.sub: Real64Array.array * int -> real (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 450.13-450.15 *)
val Real64Array.tabulate: int * (int -> real) -> Real64Array.array (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 114.11-114.18 *)
val Real64Array.update: Real64Array.array * int * real -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 452.13-452.18 *)
val Real64Array.vector: Real64Array.array -> Real64Vector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/array.sml 36.11-36.16 *)
structure Real64Array2: MONO_ARRAY2 where type array = Real64Array2.array where type elem = real where type vector = Real64Vector.vector (* @ $(SML_LIB)/basis/libs/basis-2002/top-level/top-level.sml 53.11-53.22 *)
type Real64Array2.array = Real64Array2.array (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array2.fun 18.12-18.16 *)
type Real64Array2.elem = real (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array2.fun 15.12-15.15 *)
type Real64Array2.region = {base: Real64Array2.array, col: int, ncols: int option, nrows: int option, row: int} (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array2.fun 19.12-19.17 *)
datatype Real64Array2.traversal = ColMajor | RowMajor (* = datatype Array2.traversal *) (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 106.16-106.24 *)
type Real64Array2.vector = Real64Vector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array2.fun 16.12-16.17 *)
con Real64Array2.ColMajor: Array2.traversal (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 106.39-106.46 *)
con Real64Array2.RowMajor: Array2.traversal (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 106.28-106.35 *)
val Real64Array2.app: Array2.traversal -> (real -> unit) -> Real64Array2.array -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 294.11-294.13 *)
val Real64Array2.appi: Array2.traversal -> (int * int * real -> unit) -> {base: Real64Array2.array, col: int, ncols: int option, nrows: int option, row: int} -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 291.11-291.14 *)
val Real64Array2.array: int * int * real -> Real64Array2.array (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 140.14-140.18 *)
val Real64Array2.column: Real64Array2.array * int -> Real64Vector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 237.11-237.16 *)
val Real64Array2.copy: {dst: Real64Array2.array, dst_col: int, dst_row: int, src: {base: Real64Array2.array, col: int, ncols: int option, nrows: int option, row: int}} -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 309.11-309.14 *)
val Real64Array2.dimensions: Real64Array2.array -> int * int (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 33.11-33.20 *)
val Real64Array2.fold: Array2.traversal -> (real * 'a -> 'a) -> 'a -> Real64Array2.array -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 288.11-288.14 *)
val Real64Array2.foldi: Array2.traversal -> (int * int * real * 'a -> 'a) -> 'a -> {base: Real64Array2.array, col: int, ncols: int option, nrows: int option, row: int} -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 283.11-283.15 *)
val Real64Array2.fromList: real list list -> Real64Array2.array (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 188.14-188.21 *)
val Real64Array2.modify: Array2.traversal -> (real -> real) -> Real64Array2.array -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 299.11-299.16 *)
val Real64Array2.modifyi: Array2.traversal -> (int * int * real -> real) -> {base: Real64Array2.array, col: int, ncols: int option, nrows: int option, row: int} -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 296.11-296.17 *)
val Real64Array2.nCols: Real64Array2.array -> int (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 38.11-38.15 *)
val Real64Array2.nRows: Real64Array2.array -> int (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 36.11-36.15 *)
val Real64Array2.row: Real64Array2.array * int -> Real64Vector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 222.11-222.13 *)
val Real64Array2.sub: Real64Array2.array * int * int -> real (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 182.14-182.16 *)
val Real64Array2.tabulate: Array2.traversal -> int * int * (int * int -> real) -> Real64Array2.array (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 301.11-301.18 *)
val Real64Array2.update: Real64Array2.array * int * int * real -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 184.14-184.19 *)
structure Real64ArraySlice: MONO_ARRAY_SLICE where type array = Real64Array.array where type elem = real where type slice = Real64ArraySlice.slice where type vector = Real64Vector.vector where type vector_slice = Real64VectorSlice.slice (* @ $(SML_LIB)/basis/libs/basis-extra/top-level/basis.sml 171.17-171.32 *)
type Real64ArraySlice.array = Real64Array.array (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array.fun 35.18-35.22 *)
type Real64ArraySlice.elem = real (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array.fun 34.18-34.21 *)
type Real64ArraySlice.slice = Real64ArraySlice.slice (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array.fun 36.18-36.22 *)
type Real64ArraySlice.vector = Real64Vector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array.fun 37.18-37.23 *)
type Real64ArraySlice.vector_slice = Real64VectorSlice.slice (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array.fun 38.18-38.29 *)
val Real64ArraySlice.all: (real -> bool) -> Real64ArraySlice.slice -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 235.17-235.19 *)
val Real64ArraySlice.app: (real -> unit) -> Real64ArraySlice.slice -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 226.17-226.19 *)
val Real64ArraySlice.appi: (int * real -> unit) -> Real64ArraySlice.slice -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 225.17-225.20 *)
val Real64ArraySlice.base: Real64ArraySlice.slice -> Real64Array.array * int * int (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 208.17-208.20 *)
val Real64ArraySlice.collate: (real * real -> order) -> Real64ArraySlice.slice * Real64ArraySlice.slice -> order (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 236.17-236.23 *)
val Real64ArraySlice.copy: {di: int, dst: Real64Array.array, src: Real64ArraySlice.slice} -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 185.17-185.20 *)
val Real64ArraySlice.copyVec: {di: int, dst: Real64Array.array, src: Real64VectorSlice.slice} -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array.sml 28.17-28.23 *)
val Real64ArraySlice.exists: (real -> bool) -> Real64ArraySlice.slice -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 233.17-233.22 *)
val Real64ArraySlice.find: (real -> bool) -> Real64ArraySlice.slice -> real option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 231.17-231.20 *)
val Real64ArraySlice.findi: (int * real -> bool) -> Real64ArraySlice.slice -> (int * real) option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 229.17-229.21 *)
val Real64ArraySlice.foldl: (real * 'a -> 'a) -> 'a -> Real64ArraySlice.slice -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 223.17-223.21 *)
val Real64ArraySlice.foldli: (int * real * 'a -> 'a) -> 'a -> Real64ArraySlice.slice -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 221.17-221.22 *)
val Real64ArraySlice.foldr: (real * 'a -> 'a) -> 'a -> Real64ArraySlice.slice -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 224.17-224.21 *)
val Real64ArraySlice.foldri: (int * real * 'a -> 'a) -> 'a -> Real64ArraySlice.slice -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 222.17-222.22 *)
val Real64ArraySlice.full: Real64Array.array -> Real64ArraySlice.slice (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 192.17-192.20 *)
val Real64ArraySlice.getItem: Real64ArraySlice.slice -> (real * Real64ArraySlice.slice) option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 220.17-220.23 *)
val Real64ArraySlice.isEmpty: Real64ArraySlice.slice -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 219.17-219.23 *)
val Real64ArraySlice.length: Real64ArraySlice.slice -> int (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 134.17-134.22 *)
val Real64ArraySlice.modify: (real -> real) -> Real64ArraySlice.slice -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array.sml 31.17-31.22 *)
val Real64ArraySlice.modifyi: (int * real -> real) -> Real64ArraySlice.slice -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array.sml 30.17-30.23 *)
val Real64ArraySlice.slice: Real64Array.array * int * int option -> Real64ArraySlice.slice (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 206.17-206.21 *)
val Real64ArraySlice.sub: Real64ArraySlice.slice * int -> real (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 142.17-142.19 *)
val Real64ArraySlice.subslice: Real64ArraySlice.slice * int * int option -> Real64ArraySlice.slice (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 199.17-199.24 *)
val Real64ArraySlice.update: Real64ArraySlice.slice * int * real -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 155.17-155.22 *)
val Real64ArraySlice.vector: Real64ArraySlice.slice -> Real64Vector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/array.sml 27.17-27.22 *)
structure Real64Vector: MONO_VECTOR where type elem = real where type vector = Real64Vector.vector (* @ $(SML_LIB)/basis/libs/basis-2002/top-level/top-level.sml 54.11-54.22 *)
type Real64Vector.elem = real (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-vector.fun 15.12-15.15 *)
type Real64Vector.vector = Real64Vector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-vector.fun 16.12-16.17 *)
val Real64Vector.all: (real -> bool) -> Real64Vector.vector -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 476.13-476.15 *)
val Real64Vector.app: (real -> unit) -> Real64Vector.vector -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 464.13-464.15 *)
val Real64Vector.appi: (int * real -> unit) -> Real64Vector.vector -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 463.13-463.16 *)
val Real64Vector.collate: (real * real -> order) -> Real64Vector.vector * Real64Vector.vector -> order (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 477.13-477.19 *)
val Real64Vector.concat: Real64Vector.vector list -> Real64Vector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 462.13-462.18 *)
val Real64Vector.exists: (real -> bool) -> Real64Vector.vector -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 474.13-474.18 *)
val Real64Vector.find: (real -> bool) -> Real64Vector.vector -> real option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 472.13-472.16 *)
val Real64Vector.findi: (int * real -> bool) -> Real64Vector.vector -> (int * real) option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 471.13-471.17 *)
val Real64Vector.foldl: (real * 'a -> 'a) -> 'a -> Real64Vector.vector -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 468.13-468.17 *)
val Real64Vector.foldli: (int * real * 'a -> 'a) -> 'a -> Real64Vector.vector -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 467.13-467.18 *)
val Real64Vector.foldr: (real * 'a -> 'a) -> 'a -> Real64Vector.vector -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 470.13-470.17 *)
val Real64Vector.foldri: (int * real * 'a -> 'a) -> 'a -> Real64Vector.vector -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 469.13-469.18 *)
val Real64Vector.fromList: real list -> Real64Vector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 122.11-122.18 *)
val Real64Vector.length: Real64Vector.vector -> int (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 90.11-90.16 *)
val Real64Vector.map: (real -> real) -> Real64Vector.vector -> Real64Vector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 466.13-466.15 *)
val Real64Vector.mapi: (int * real -> real) -> Real64Vector.vector -> Real64Vector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 465.13-465.16 *)
val Real64Vector.maxLen: int (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 88.11-88.16 *)
val Real64Vector.sub: Real64Vector.vector * int -> real (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 450.13-450.15 *)
val Real64Vector.tabulate: int * (int -> real) -> Real64Vector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 114.11-114.18 *)
val Real64Vector.update: Real64Vector.vector * int * real -> Real64Vector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/vector.sml 30.11-30.16 *)
structure Real64VectorSlice: MONO_VECTOR_SLICE where type elem = real where type slice = Real64VectorSlice.slice where type vector = Real64Vector.vector (* @ $(SML_LIB)/basis/libs/basis-extra/top-level/basis.sml 173.17-173.33 *)
type Real64VectorSlice.elem = real (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-vector.fun 22.18-22.21 *)
type Real64VectorSlice.slice = Real64VectorSlice.slice (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-vector.fun 24.18-24.22 *)
type Real64VectorSlice.vector = Real64Vector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-vector.fun 23.18-23.23 *)
val Real64VectorSlice.all: (real -> bool) -> Real64VectorSlice.slice -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 235.17-235.19 *)
val Real64VectorSlice.app: (real -> unit) -> Real64VectorSlice.slice -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 226.17-226.19 *)
val Real64VectorSlice.appi: (int * real -> unit) -> Real64VectorSlice.slice -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 225.17-225.20 *)
val Real64VectorSlice.base: Real64VectorSlice.slice -> Real64Vector.vector * int * int (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 208.17-208.20 *)
val Real64VectorSlice.collate: (real * real -> order) -> Real64VectorSlice.slice * Real64VectorSlice.slice -> order (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 236.17-236.23 *)
val Real64VectorSlice.concat: Real64VectorSlice.slice list -> Real64Vector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 240.17-240.22 *)
val Real64VectorSlice.exists: (real -> bool) -> Real64VectorSlice.slice -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 233.17-233.22 *)
val Real64VectorSlice.find: (real -> bool) -> Real64VectorSlice.slice -> real option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 231.17-231.20 *)
val Real64VectorSlice.findi: (int * real -> bool) -> Real64VectorSlice.slice -> (int * real) option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 229.17-229.21 *)
val Real64VectorSlice.foldl: (real * 'a -> 'a) -> 'a -> Real64VectorSlice.slice -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 223.17-223.21 *)
val Real64VectorSlice.foldli: (int * real * 'a -> 'a) -> 'a -> Real64VectorSlice.slice -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 221.17-221.22 *)
val Real64VectorSlice.foldr: (real * 'a -> 'a) -> 'a -> Real64VectorSlice.slice -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 224.17-224.21 *)
val Real64VectorSlice.foldri: (int * real * 'a -> 'a) -> 'a -> Real64VectorSlice.slice -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 222.17-222.22 *)
val Real64VectorSlice.full: Real64Vector.vector -> Real64VectorSlice.slice (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 192.17-192.20 *)
val Real64VectorSlice.getItem: Real64VectorSlice.slice -> (real * Real64VectorSlice.slice) option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 220.17-220.23 *)
val Real64VectorSlice.isEmpty: Real64VectorSlice.slice -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 219.17-219.23 *)
val Real64VectorSlice.length: Real64VectorSlice.slice -> int (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 134.17-134.22 *)
val Real64VectorSlice.map: (real -> real) -> Real64VectorSlice.slice -> Real64Vector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 228.17-228.19 *)
val Real64VectorSlice.mapi: (int * real -> real) -> Real64VectorSlice.slice -> Real64Vector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 227.17-227.20 *)
val Real64VectorSlice.slice: Real64Vector.vector * int * int option -> Real64VectorSlice.slice (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 206.17-206.21 *)
val Real64VectorSlice.sub: Real64VectorSlice.slice * int -> real (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 142.17-142.19 *)
val Real64VectorSlice.subslice: Real64VectorSlice.slice * int * int option -> Real64VectorSlice.slice (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 199.17-199.24 *)
val Real64VectorSlice.vector: Real64VectorSlice.slice -> Real64Vector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/vector.sml 21.17-21.22 *)
structure RealArray: MONO_ARRAY where type array = RealArray.array where type elem = real where type vector = RealVector.vector (* @ $(SML_LIB)/basis/libs/basis-2002/top-level/top-level.sml 55.11-55.19 *)
type RealArray.array = RealArray.array (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array.fun 23.12-23.16 *)
type RealArray.elem = real (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array.fun 22.12-22.15 *)
type RealArray.vector = RealVector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array.fun 24.12-24.17 *)
val RealArray.all: (real -> bool) -> RealArray.array -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 476.13-476.15 *)
val RealArray.app: (real -> unit) -> RealArray.array -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 464.13-464.15 *)
val RealArray.appi: (int * real -> unit) -> RealArray.array -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 463.13-463.16 *)
val RealArray.array: int * real -> RealArray.array (* @ $(SML_LIB)/basis/arrays-and-vectors/array.sml 34.11-34.15 *)
val RealArray.collate: (real * real -> order) -> RealArray.array * RealArray.array -> order (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 477.13-477.19 *)
val RealArray.copy: {di: int, dst: RealArray.array, src: RealArray.array} -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 457.13-457.16 *)
val RealArray.copyVec: {di: int, dst: RealArray.array, src: RealVector.vector} -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array.sml 37.11-37.17 *)
val RealArray.exists: (real -> bool) -> RealArray.array -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 474.13-474.18 *)
val RealArray.find: (real -> bool) -> RealArray.array -> real option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 472.13-472.16 *)
val RealArray.findi: (int * real -> bool) -> RealArray.array -> (int * real) option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 471.13-471.17 *)
val RealArray.foldl: (real * 'a -> 'a) -> 'a -> RealArray.array -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 468.13-468.17 *)
val RealArray.foldli: (int * real * 'a -> 'a) -> 'a -> RealArray.array -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 467.13-467.18 *)
val RealArray.foldr: (real * 'a -> 'a) -> 'a -> RealArray.array -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 470.13-470.17 *)
val RealArray.foldri: (int * real * 'a -> 'a) -> 'a -> RealArray.array -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 469.13-469.18 *)
val RealArray.fromList: real list -> RealArray.array (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 122.11-122.18 *)
val RealArray.length: RealArray.array -> int (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 90.11-90.16 *)
val RealArray.maxLen: int (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 88.11-88.16 *)
val RealArray.modify: (real -> real) -> RealArray.array -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array.sml 40.11-40.16 *)
val RealArray.modifyi: (int * real -> real) -> RealArray.array -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array.sml 39.11-39.17 *)
val RealArray.sub: RealArray.array * int -> real (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 450.13-450.15 *)
val RealArray.tabulate: int * (int -> real) -> RealArray.array (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 114.11-114.18 *)
val RealArray.update: RealArray.array * int * real -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 452.13-452.18 *)
val RealArray.vector: RealArray.array -> RealVector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/array.sml 36.11-36.16 *)
structure RealArray2: MONO_ARRAY2 where type array = RealArray2.array where type elem = real where type vector = RealVector.vector (* @ $(SML_LIB)/basis/libs/basis-2002/top-level/top-level.sml 56.11-56.20 *)
type RealArray2.array = RealArray2.array (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array2.fun 18.12-18.16 *)
type RealArray2.elem = real (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array2.fun 15.12-15.15 *)
type RealArray2.region = {base: RealArray2.array, col: int, ncols: int option, nrows: int option, row: int} (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array2.fun 19.12-19.17 *)
datatype RealArray2.traversal = ColMajor | RowMajor (* = datatype Array2.traversal *) (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 106.16-106.24 *)
type RealArray2.vector = RealVector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array2.fun 16.12-16.17 *)
con RealArray2.ColMajor: Array2.traversal (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 106.39-106.46 *)
con RealArray2.RowMajor: Array2.traversal (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 106.28-106.35 *)
val RealArray2.app: Array2.traversal -> (real -> unit) -> RealArray2.array -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 294.11-294.13 *)
val RealArray2.appi: Array2.traversal -> (int * int * real -> unit) -> {base: RealArray2.array, col: int, ncols: int option, nrows: int option, row: int} -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 291.11-291.14 *)
val RealArray2.array: int * int * real -> RealArray2.array (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 140.14-140.18 *)
val RealArray2.column: RealArray2.array * int -> RealVector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 237.11-237.16 *)
val RealArray2.copy: {dst: RealArray2.array, dst_col: int, dst_row: int, src: {base: RealArray2.array, col: int, ncols: int option, nrows: int option, row: int}} -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 309.11-309.14 *)
val RealArray2.dimensions: RealArray2.array -> int * int (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 33.11-33.20 *)
val RealArray2.fold: Array2.traversal -> (real * 'a -> 'a) -> 'a -> RealArray2.array -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 288.11-288.14 *)
val RealArray2.foldi: Array2.traversal -> (int * int * real * 'a -> 'a) -> 'a -> {base: RealArray2.array, col: int, ncols: int option, nrows: int option, row: int} -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 283.11-283.15 *)
val RealArray2.fromList: real list list -> RealArray2.array (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 188.14-188.21 *)
val RealArray2.modify: Array2.traversal -> (real -> real) -> RealArray2.array -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 299.11-299.16 *)
val RealArray2.modifyi: Array2.traversal -> (int * int * real -> real) -> {base: RealArray2.array, col: int, ncols: int option, nrows: int option, row: int} -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 296.11-296.17 *)
val RealArray2.nCols: RealArray2.array -> int (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 38.11-38.15 *)
val RealArray2.nRows: RealArray2.array -> int (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 36.11-36.15 *)
val RealArray2.row: RealArray2.array * int -> RealVector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 222.11-222.13 *)
val RealArray2.sub: RealArray2.array * int * int -> real (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 182.14-182.16 *)
val RealArray2.tabulate: Array2.traversal -> int * int * (int * int -> real) -> RealArray2.array (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 301.11-301.18 *)
val RealArray2.update: RealArray2.array * int * int * real -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 184.14-184.19 *)
structure RealArraySlice: MONO_ARRAY_SLICE where type array = RealArray.array where type elem = real where type slice = RealArraySlice.slice where type vector = RealVector.vector where type vector_slice = RealVectorSlice.slice (* @ $(SML_LIB)/basis/libs/basis-extra/top-level/basis.sml 176.17-176.30 *)
type RealArraySlice.array = RealArray.array (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array.fun 35.18-35.22 *)
type RealArraySlice.elem = real (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array.fun 34.18-34.21 *)
type RealArraySlice.slice = RealArraySlice.slice (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array.fun 36.18-36.22 *)
type RealArraySlice.vector = RealVector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array.fun 37.18-37.23 *)
type RealArraySlice.vector_slice = RealVectorSlice.slice (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array.fun 38.18-38.29 *)
val RealArraySlice.all: (real -> bool) -> RealArraySlice.slice -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 235.17-235.19 *)
val RealArraySlice.app: (real -> unit) -> RealArraySlice.slice -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 226.17-226.19 *)
val RealArraySlice.appi: (int * real -> unit) -> RealArraySlice.slice -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 225.17-225.20 *)
val RealArraySlice.base: RealArraySlice.slice -> RealArray.array * int * int (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 208.17-208.20 *)
val RealArraySlice.collate: (real * real -> order) -> RealArraySlice.slice * RealArraySlice.slice -> order (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 236.17-236.23 *)
val RealArraySlice.copy: {di: int, dst: RealArray.array, src: RealArraySlice.slice} -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 185.17-185.20 *)
val RealArraySlice.copyVec: {di: int, dst: RealArray.array, src: RealVectorSlice.slice} -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array.sml 28.17-28.23 *)
val RealArraySlice.exists: (real -> bool) -> RealArraySlice.slice -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 233.17-233.22 *)
val RealArraySlice.find: (real -> bool) -> RealArraySlice.slice -> real option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 231.17-231.20 *)
val RealArraySlice.findi: (int * real -> bool) -> RealArraySlice.slice -> (int * real) option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 229.17-229.21 *)
val RealArraySlice.foldl: (real * 'a -> 'a) -> 'a -> RealArraySlice.slice -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 223.17-223.21 *)
val RealArraySlice.foldli: (int * real * 'a -> 'a) -> 'a -> RealArraySlice.slice -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 221.17-221.22 *)
val RealArraySlice.foldr: (real * 'a -> 'a) -> 'a -> RealArraySlice.slice -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 224.17-224.21 *)
val RealArraySlice.foldri: (int * real * 'a -> 'a) -> 'a -> RealArraySlice.slice -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 222.17-222.22 *)
val RealArraySlice.full: RealArray.array -> RealArraySlice.slice (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 192.17-192.20 *)
val RealArraySlice.getItem: RealArraySlice.slice -> (real * RealArraySlice.slice) option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 220.17-220.23 *)
val RealArraySlice.isEmpty: RealArraySlice.slice -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 219.17-219.23 *)
val RealArraySlice.length: RealArraySlice.slice -> int (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 134.17-134.22 *)
val RealArraySlice.modify: (real -> real) -> RealArraySlice.slice -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array.sml 31.17-31.22 *)
val RealArraySlice.modifyi: (int * real -> real) -> RealArraySlice.slice -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array.sml 30.17-30.23 *)
val RealArraySlice.slice: RealArray.array * int * int option -> RealArraySlice.slice (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 206.17-206.21 *)
val RealArraySlice.sub: RealArraySlice.slice * int -> real (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 142.17-142.19 *)
val RealArraySlice.subslice: RealArraySlice.slice * int * int option -> RealArraySlice.slice (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 199.17-199.24 *)
val RealArraySlice.update: RealArraySlice.slice * int * real -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 155.17-155.22 *)
val RealArraySlice.vector: RealArraySlice.slice -> RealVector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/array.sml 27.17-27.22 *)
structure RealVector: MONO_VECTOR where type elem = real where type vector = RealVector.vector (* @ $(SML_LIB)/basis/libs/basis-2002/top-level/top-level.sml 57.11-57.20 *)
type RealVector.elem = real (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-vector.fun 15.12-15.15 *)
type RealVector.vector = RealVector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-vector.fun 16.12-16.17 *)
val RealVector.all: (real -> bool) -> RealVector.vector -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 476.13-476.15 *)
val RealVector.app: (real -> unit) -> RealVector.vector -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 464.13-464.15 *)
val RealVector.appi: (int * real -> unit) -> RealVector.vector -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 463.13-463.16 *)
val RealVector.collate: (real * real -> order) -> RealVector.vector * RealVector.vector -> order (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 477.13-477.19 *)
val RealVector.concat: RealVector.vector list -> RealVector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 462.13-462.18 *)
val RealVector.exists: (real -> bool) -> RealVector.vector -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 474.13-474.18 *)
val RealVector.find: (real -> bool) -> RealVector.vector -> real option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 472.13-472.16 *)
val RealVector.findi: (int * real -> bool) -> RealVector.vector -> (int * real) option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 471.13-471.17 *)
val RealVector.foldl: (real * 'a -> 'a) -> 'a -> RealVector.vector -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 468.13-468.17 *)
val RealVector.foldli: (int * real * 'a -> 'a) -> 'a -> RealVector.vector -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 467.13-467.18 *)
val RealVector.foldr: (real * 'a -> 'a) -> 'a -> RealVector.vector -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 470.13-470.17 *)
val RealVector.foldri: (int * real * 'a -> 'a) -> 'a -> RealVector.vector -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 469.13-469.18 *)
val RealVector.fromList: real list -> RealVector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 122.11-122.18 *)
val RealVector.length: RealVector.vector -> int (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 90.11-90.16 *)
val RealVector.map: (real -> real) -> RealVector.vector -> RealVector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 466.13-466.15 *)
val RealVector.mapi: (int * real -> real) -> RealVector.vector -> RealVector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 465.13-465.16 *)
val RealVector.maxLen: int (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 88.11-88.16 *)
val RealVector.sub: RealVector.vector * int -> real (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 450.13-450.15 *)
val RealVector.tabulate: int * (int -> real) -> RealVector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 114.11-114.18 *)
val RealVector.update: RealVector.vector * int * real -> RealVector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/vector.sml 30.11-30.16 *)
structure RealVectorSlice: MONO_VECTOR_SLICE where type elem = real where type slice = RealVectorSlice.slice where type vector = RealVector.vector (* @ $(SML_LIB)/basis/libs/basis-extra/top-level/basis.sml 178.17-178.31 *)
type RealVectorSlice.elem = real (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-vector.fun 22.18-22.21 *)
type RealVectorSlice.slice = RealVectorSlice.slice (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-vector.fun 24.18-24.22 *)
type RealVectorSlice.vector = RealVector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-vector.fun 23.18-23.23 *)
val RealVectorSlice.all: (real -> bool) -> RealVectorSlice.slice -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 235.17-235.19 *)
val RealVectorSlice.app: (real -> unit) -> RealVectorSlice.slice -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 226.17-226.19 *)
val RealVectorSlice.appi: (int * real -> unit) -> RealVectorSlice.slice -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 225.17-225.20 *)
val RealVectorSlice.base: RealVectorSlice.slice -> RealVector.vector * int * int (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 208.17-208.20 *)
val RealVectorSlice.collate: (real * real -> order) -> RealVectorSlice.slice * RealVectorSlice.slice -> order (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 236.17-236.23 *)
val RealVectorSlice.concat: RealVectorSlice.slice list -> RealVector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 240.17-240.22 *)
val RealVectorSlice.exists: (real -> bool) -> RealVectorSlice.slice -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 233.17-233.22 *)
val RealVectorSlice.find: (real -> bool) -> RealVectorSlice.slice -> real option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 231.17-231.20 *)
val RealVectorSlice.findi: (int * real -> bool) -> RealVectorSlice.slice -> (int * real) option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 229.17-229.21 *)
val RealVectorSlice.foldl: (real * 'a -> 'a) -> 'a -> RealVectorSlice.slice -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 223.17-223.21 *)
val RealVectorSlice.foldli: (int * real * 'a -> 'a) -> 'a -> RealVectorSlice.slice -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 221.17-221.22 *)
val RealVectorSlice.foldr: (real * 'a -> 'a) -> 'a -> RealVectorSlice.slice -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 224.17-224.21 *)
val RealVectorSlice.foldri: (int * real * 'a -> 'a) -> 'a -> RealVectorSlice.slice -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 222.17-222.22 *)
val RealVectorSlice.full: RealVector.vector -> RealVectorSlice.slice (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 192.17-192.20 *)
val RealVectorSlice.getItem: RealVectorSlice.slice -> (real * RealVectorSlice.slice) option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 220.17-220.23 *)
val RealVectorSlice.isEmpty: RealVectorSlice.slice -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 219.17-219.23 *)
val RealVectorSlice.length: RealVectorSlice.slice -> int (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 134.17-134.22 *)
val RealVectorSlice.map: (real -> real) -> RealVectorSlice.slice -> RealVector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 228.17-228.19 *)
val RealVectorSlice.mapi: (int * real -> real) -> RealVectorSlice.slice -> RealVector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 227.17-227.20 *)
val RealVectorSlice.slice: RealVector.vector * int * int option -> RealVectorSlice.slice (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 206.17-206.21 *)
val RealVectorSlice.sub: RealVectorSlice.slice * int -> real (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 142.17-142.19 *)
val RealVectorSlice.subslice: RealVectorSlice.slice * int * int option -> RealVectorSlice.slice (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 199.17-199.24 *)
val RealVectorSlice.vector: RealVectorSlice.slice -> RealVector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/vector.sml 21.17-21.22 *)
structure SMLofNJ: SML_OF_NJ where type 'a Cont.cont = 'a SMLofNJ.Cont.cont where type SysInfo.os_kind = SMLofNJ.SysInfo.os_kind (* @ $(SML_LIB)/basis/sml-nj.mlb 19.17-19.23 *)
val SMLofNJ.exnHistory: exn -> string list (* @ $(SML_LIB)/basis/sml-nj/sml-nj.sml 55.11-55.20 *)
val SMLofNJ.exportFn: string * (string * string list -> OS.Process.status) -> unit (* @ $(SML_LIB)/basis/sml-nj/sml-nj.sml 57.11-57.18 *)
val SMLofNJ.exportML: string -> bool (* @ $(SML_LIB)/basis/sml-nj/sml-nj.sml 66.11-66.18 *)
val SMLofNJ.getAllArgs: unit -> string list (* @ $(SML_LIB)/basis/sml-nj/sml-nj.sml 53.11-53.20 *)
val SMLofNJ.getArgs: unit -> string list (* @ $(SML_LIB)/basis/sml-nj/sml-nj.sml 51.11-51.17 *)
val SMLofNJ.getCmdName: unit -> string (* @ $(SML_LIB)/basis/sml-nj/sml-nj.sml 50.11-50.20 *)
structure SMLofNJ.Cont:
   sig
      type 'a cont = 'a SMLofNJ.Cont.cont
      val callcc: ('a SMLofNJ.Cont.cont -> 'a) -> 'a
      val isolate: ('a -> unit) -> 'a SMLofNJ.Cont.cont
      val throw: 'a SMLofNJ.Cont.cont -> 'a -> 'b
   end
   (* @ $(SML_LIB)/basis/sml-nj/sml-nj.sml 11.17-11.20 *)
type 'a SMLofNJ.Cont.cont = 'a SMLofNJ.Cont.cont (* @ $(SML_LIB)/basis/sml-nj/sml-nj.sml 15.21-15.24 *)
val SMLofNJ.Cont.callcc: ('a SMLofNJ.Cont.cont -> 'a) -> 'a (* @ $(SML_LIB)/basis/sml-nj/sml-nj.sml 16.17-16.22 *)
val SMLofNJ.Cont.isolate: ('a -> unit) -> 'a SMLofNJ.Cont.cont (* @ $(SML_LIB)/basis/sml-nj/sml-nj.sml 17.17-17.23 *)
val SMLofNJ.Cont.throw: 'a SMLofNJ.Cont.cont -> 'a -> 'b (* @ $(SML_LIB)/basis/sml-nj/sml-nj.sml 18.17-18.21 *)
structure SMLofNJ.SysInfo:
   sig
      datatype os_kind = BEOS | MACOS | OS2 | UNIX | WIN32 (* = datatype SMLofNJ.SysInfo.os_kind *)
      exception UNKNOWN
      val getHostArch: unit -> string
      val getOSKind: unit -> SMLofNJ.SysInfo.os_kind
      val getOSName: unit -> string
   end
   (* @ $(SML_LIB)/basis/sml-nj/sml-nj.sml 21.17-21.23 *)
datatype SMLofNJ.SysInfo.os_kind = BEOS | MACOS | OS2 | UNIX | WIN32 (* = datatype SMLofNJ.SysInfo.os_kind *) (* @ $(SML_LIB)/basis/sml-nj/sml-nj.sml 24.22-24.28 *)
con SMLofNJ.SysInfo.BEOS: SMLofNJ.SysInfo.os_kind (* @ $(SML_LIB)/basis/sml-nj/sml-nj.sml 24.32-24.35 *)
con SMLofNJ.SysInfo.MACOS: SMLofNJ.SysInfo.os_kind (* @ $(SML_LIB)/basis/sml-nj/sml-nj.sml 24.39-24.43 *)
con SMLofNJ.SysInfo.OS2: SMLofNJ.SysInfo.os_kind (* @ $(SML_LIB)/basis/sml-nj/sml-nj.sml 24.47-24.49 *)
con SMLofNJ.SysInfo.UNIX: SMLofNJ.SysInfo.os_kind (* @ $(SML_LIB)/basis/sml-nj/sml-nj.sml 24.53-24.56 *)
exn SMLofNJ.SysInfo.UNKNOWN: exn (* @ $(SML_LIB)/basis/sml-nj/sml-nj.sml 23.23-23.29 *)
con SMLofNJ.SysInfo.WIN32: SMLofNJ.SysInfo.os_kind (* @ $(SML_LIB)/basis/sml-nj/sml-nj.sml 24.60-24.64 *)
val SMLofNJ.SysInfo.getHostArch: unit -> string (* @ $(SML_LIB)/basis/sml-nj/sml-nj.sml 26.17-26.27 *)
val SMLofNJ.SysInfo.getOSKind: unit -> SMLofNJ.SysInfo.os_kind (* @ $(SML_LIB)/basis/sml-nj/sml-nj.sml 29.17-29.25 *)
val SMLofNJ.SysInfo.getOSName: unit -> string (* @ $(SML_LIB)/basis/sml-nj/sml-nj.sml 47.17-47.25 *)
structure Socket: SOCKET where type SOCK.sock_type = Socket.SOCK.sock_type where type active = Socket.active where type dgram = Socket.dgram where type passive = Socket.passive where type shutdown_mode = Socket.shutdown_mode where type ('a, 'b) sock = ('a, 'b) Socket.sock where type 'a sock_addr = 'a Socket.sock_addr where type sock_desc = Socket.sock_desc where type 'a stream = 'a Socket.stream (* @ $(SML_LIB)/basis/libs/basis-extra/top-level/basis.sml 179.17-179.22 *)
type Socket.active = Socket.active (* @ $(SML_LIB)/basis/net/socket.sml 43.10-43.15 *)
type Socket.dgram = Socket.dgram (* @ $(SML_LIB)/basis/net/socket.sml 40.10-40.14 *)
type Socket.in_flags = {oob: bool, peek: bool} (* @ $(SML_LIB)/basis/net/socket.sml 459.6-459.13 *)
type Socket.out_flags = {don't_route: bool, oob: bool} (* @ $(SML_LIB)/basis/net/socket.sml 382.6-382.14 *)
type Socket.passive = Socket.passive (* @ $(SML_LIB)/basis/net/socket.sml 42.10-42.16 *)
datatype Socket.shutdown_mode = NO_RECVS | NO_RECVS_OR_SENDS | NO_SENDS (* = datatype Socket.shutdown_mode *) (* @ $(SML_LIB)/basis/net/socket.sml 301.10-301.22 *)
type ('a, 'b) Socket.sock = ('a, 'b) Socket.sock (* @ $(SML_LIB)/basis/net/socket.sml 584.24-584.27 *)
type 'a Socket.sock_addr = 'a Socket.sock_addr (* @ $(SML_LIB)/basis/net/socket.sml 586.10-586.18 *)
type Socket.sock_desc = Socket.sock_desc (* @ $(SML_LIB)/basis/net/socket.sml 314.6-314.14 *)
type 'a Socket.stream = 'a Socket.stream (* @ $(SML_LIB)/basis/net/socket.sml 588.12-588.17 *)
con Socket.NO_RECVS: Socket.shutdown_mode (* @ $(SML_LIB)/basis/net/socket.sml 301.26-301.33 *)
con Socket.NO_RECVS_OR_SENDS: Socket.shutdown_mode (* @ $(SML_LIB)/basis/net/socket.sml 301.48-301.64 *)
con Socket.NO_SENDS: Socket.shutdown_mode (* @ $(SML_LIB)/basis/net/socket.sml 301.37-301.44 *)
val Socket.accept: ('a, Socket.passive Socket.stream) Socket.sock -> ('a, Socket.active Socket.stream) Socket.sock * 'a Socket.sock_addr (* @ $(SML_LIB)/basis/net/socket.sml 280.5-280.10 *)
val Socket.acceptNB: ('a, Socket.passive Socket.stream) Socket.sock -> (('a, Socket.active Socket.stream) Socket.sock * 'a Socket.sock_addr) option (* @ $(SML_LIB)/basis/net/socket.sml 288.5-288.12 *)
val Socket.bind: ('a, 'b) Socket.sock * 'a Socket.sock_addr -> unit (* @ $(SML_LIB)/basis/net/socket.sml 217.5-217.8 *)
val Socket.close: ('a, 'b) Socket.sock -> unit (* @ $(SML_LIB)/basis/net/socket.sml 299.5-299.9 *)
val Socket.connect: ('a, 'b) Socket.sock * 'a Socket.sock_addr -> unit (* @ $(SML_LIB)/basis/net/socket.sml 270.5-270.11 *)
val Socket.connectNB: ('a, 'b) Socket.sock * 'a Socket.sock_addr -> bool (* @ $(SML_LIB)/basis/net/socket.sml 273.5-273.13 *)
val Socket.familyOfAddr: 'a Socket.sock_addr -> NetHostDB.addr_family (* @ $(SML_LIB)/basis/net/socket.sml 215.5-215.16 *)
val Socket.ioDesc: ('a, 'b) Socket.sock -> OS.IO.iodesc (* @ $(SML_LIB)/basis/net/socket.sml 380.5-380.10 *)
val Socket.listen: ('a, Socket.passive Socket.stream) Socket.sock * int -> unit (* @ $(SML_LIB)/basis/net/socket.sml 220.5-220.10 *)
val Socket.recvArr: ('a, Socket.active Socket.stream) Socket.sock * Word8ArraySlice.slice -> int (* @ $(SML_LIB)/basis/net/socket.sml 492.5-492.11 *)
val Socket.recvArr': ('a, Socket.active Socket.stream) Socket.sock * Word8ArraySlice.slice * {oob: bool, peek: bool} -> int (* @ $(SML_LIB)/basis/net/socket.sml 468.5-468.12 *)
val Socket.recvArrFrom: ('a, Socket.dgram) Socket.sock * Word8ArraySlice.slice -> int * 'a Socket.sock_addr (* @ $(SML_LIB)/basis/net/socket.sml 519.5-519.15 *)
val Socket.recvArrFrom': ('a, Socket.dgram) Socket.sock * Word8ArraySlice.slice * {oob: bool, peek: bool} -> int * 'a Socket.sock_addr (* @ $(SML_LIB)/basis/net/socket.sml 496.5-496.16 *)
val Socket.recvArrFromNB: ('a, Socket.dgram) Socket.sock * Word8ArraySlice.slice -> (int * 'a Socket.sock_addr) option (* @ $(SML_LIB)/basis/net/socket.sml 579.5-579.17 *)
val Socket.recvArrFromNB': ('a, Socket.dgram) Socket.sock * Word8ArraySlice.slice * {oob: bool, peek: bool} -> (int * 'a Socket.sock_addr) option (* @ $(SML_LIB)/basis/net/socket.sml 553.5-553.18 *)
val Socket.recvArrNB: ('a, Socket.active Socket.stream) Socket.sock * Word8ArraySlice.slice -> int option (* @ $(SML_LIB)/basis/net/socket.sml 549.5-549.13 *)
val Socket.recvArrNB': ('a, Socket.active Socket.stream) Socket.sock * Word8ArraySlice.slice * {oob: bool, peek: bool} -> int option (* @ $(SML_LIB)/basis/net/socket.sml 525.5-525.14 *)
val Socket.recvVec: ('a, Socket.active Socket.stream) Socket.sock * int -> Word8Vector.vector (* @ $(SML_LIB)/basis/net/socket.sml 494.5-494.11 *)
val Socket.recvVec': ('a, Socket.active Socket.stream) Socket.sock * int * {oob: bool, peek: bool} -> Word8Vector.vector (* @ $(SML_LIB)/basis/net/socket.sml 483.5-483.12 *)
val Socket.recvVecFrom: ('a, Socket.dgram) Socket.sock * int -> Word8Vector.vector * 'a Socket.sock_addr (* @ $(SML_LIB)/basis/net/socket.sml 521.5-521.15 *)
val Socket.recvVecFrom': ('a, Socket.dgram) Socket.sock * int * {oob: bool, peek: bool} -> Word8Vector.vector * 'a Socket.sock_addr (* @ $(SML_LIB)/basis/net/socket.sml 510.5-510.16 *)
val Socket.recvVecFromNB: ('a, Socket.dgram) Socket.sock * int -> (Word8Vector.vector * 'a Socket.sock_addr) option (* @ $(SML_LIB)/basis/net/socket.sml 581.5-581.17 *)
val Socket.recvVecFromNB': ('a, Socket.dgram) Socket.sock * int * {oob: bool, peek: bool} -> (Word8Vector.vector * 'a Socket.sock_addr) option (* @ $(SML_LIB)/basis/net/socket.sml 566.5-566.18 *)
val Socket.recvVecNB: ('a, Socket.active Socket.stream) Socket.sock * int -> Word8Vector.vector option (* @ $(SML_LIB)/basis/net/socket.sml 551.5-551.13 *)
val Socket.recvVecNB': ('a, Socket.active Socket.stream) Socket.sock * int * {oob: bool, peek: bool} -> Word8Vector.vector option (* @ $(SML_LIB)/basis/net/socket.sml 537.5-537.14 *)
val Socket.sameAddr: 'a Socket.sock_addr * 'a Socket.sock_addr -> bool (* @ $(SML_LIB)/basis/net/socket.sml 213.5-213.12 *)
val Socket.sameDesc: Socket.sock_desc * Socket.sock_desc -> bool (* @ $(SML_LIB)/basis/net/socket.sml 318.5-318.12 *)
val Socket.select: {exs: Socket.sock_desc list, rds: Socket.sock_desc list, timeout: Time.time option, wrs: Socket.sock_desc list} -> {exs: Socket.sock_desc list, rds: Socket.sock_desc list, wrs: Socket.sock_desc list} (* @ $(SML_LIB)/basis/net/socket.sml 320.5-320.10 *)
val Socket.sendArr: ('a, Socket.active Socket.stream) Socket.sock * Word8ArraySlice.slice -> int (* @ $(SML_LIB)/basis/net/socket.sml 451.9-451.15 *)
val Socket.sendArr': ('a, Socket.active Socket.stream) Socket.sock * Word8ArraySlice.slice * {don't_route: bool, oob: bool} -> int (* @ $(SML_LIB)/basis/net/socket.sml 451.18-451.25 *)
val Socket.sendArrNB: ('a, Socket.active Socket.stream) Socket.sock * Word8ArraySlice.slice -> int option (* @ $(SML_LIB)/basis/net/socket.sml 451.28-451.36 *)
val Socket.sendArrNB': ('a, Socket.active Socket.stream) Socket.sock * Word8ArraySlice.slice * {don't_route: bool, oob: bool} -> int option (* @ $(SML_LIB)/basis/net/socket.sml 451.39-451.48 *)
val Socket.sendArrTo: ('a, Socket.dgram) Socket.sock * 'a Socket.sock_addr * Word8ArraySlice.slice -> unit (* @ $(SML_LIB)/basis/net/socket.sml 452.9-452.17 *)
val Socket.sendArrTo': ('a, Socket.dgram) Socket.sock * 'a Socket.sock_addr * Word8ArraySlice.slice * {don't_route: bool, oob: bool} -> unit (* @ $(SML_LIB)/basis/net/socket.sml 452.20-452.29 *)
val Socket.sendArrToNB: ('a, Socket.dgram) Socket.sock * 'a Socket.sock_addr * Word8ArraySlice.slice -> bool (* @ $(SML_LIB)/basis/net/socket.sml 452.32-452.42 *)
val Socket.sendArrToNB': ('a, Socket.dgram) Socket.sock * 'a Socket.sock_addr * Word8ArraySlice.slice * {don't_route: bool, oob: bool} -> bool (* @ $(SML_LIB)/basis/net/socket.sml 452.45-452.56 *)
val Socket.sendVec: ('a, Socket.active Socket.stream) Socket.sock * Word8VectorSlice.slice -> int (* @ $(SML_LIB)/basis/net/socket.sml 454.9-454.15 *)
val Socket.sendVec': ('a, Socket.active Socket.stream) Socket.sock * Word8VectorSlice.slice * {don't_route: bool, oob: bool} -> int (* @ $(SML_LIB)/basis/net/socket.sml 454.18-454.25 *)
val Socket.sendVecNB: ('a, Socket.active Socket.stream) Socket.sock * Word8VectorSlice.slice -> int option (* @ $(SML_LIB)/basis/net/socket.sml 454.28-454.36 *)
val Socket.sendVecNB': ('a, Socket.active Socket.stream) Socket.sock * Word8VectorSlice.slice * {don't_route: bool, oob: bool} -> int option (* @ $(SML_LIB)/basis/net/socket.sml 454.39-454.48 *)
val Socket.sendVecTo: ('a, Socket.dgram) Socket.sock * 'a Socket.sock_addr * Word8VectorSlice.slice -> unit (* @ $(SML_LIB)/basis/net/socket.sml 455.9-455.17 *)
val Socket.sendVecTo': ('a, Socket.dgram) Socket.sock * 'a Socket.sock_addr * Word8VectorSlice.slice * {don't_route: bool, oob: bool} -> unit (* @ $(SML_LIB)/basis/net/socket.sml 455.20-455.29 *)
val Socket.sendVecToNB: ('a, Socket.dgram) Socket.sock * 'a Socket.sock_addr * Word8VectorSlice.slice -> bool (* @ $(SML_LIB)/basis/net/socket.sml 455.32-455.42 *)
val Socket.sendVecToNB': ('a, Socket.dgram) Socket.sock * 'a Socket.sock_addr * Word8VectorSlice.slice * {don't_route: bool, oob: bool} -> bool (* @ $(SML_LIB)/basis/net/socket.sml 455.45-455.56 *)
val Socket.shutdown: ('a, 'b Socket.stream) Socket.sock * Socket.shutdown_mode -> unit (* @ $(SML_LIB)/basis/net/socket.sml 309.5-309.12 *)
val Socket.sockDesc: ('a, 'b) Socket.sock -> Socket.sock_desc (* @ $(SML_LIB)/basis/net/socket.sml 316.5-316.12 *)
structure Socket.AF:
   sig
      type addr_family = NetHostDB.addr_family
      val fromString: string -> NetHostDB.addr_family option
      val list: unit -> (string * NetHostDB.addr_family) list
      val toString: NetHostDB.addr_family -> string
   end
   (* @ $(SML_LIB)/basis/net/socket.sml 46.11-46.12 *)
type Socket.AF.addr_family = NetHostDB.addr_family (* @ $(SML_LIB)/basis/net/socket.sml 48.12-48.22 *)
val Socket.AF.fromString: string -> NetHostDB.addr_family option (* @ $(SML_LIB)/basis/net/socket.sml 60.11-60.20 *)
val Socket.AF.list: unit -> (string * NetHostDB.addr_family) list (* @ $(SML_LIB)/basis/net/socket.sml 55.11-55.14 *)
val Socket.AF.toString: NetHostDB.addr_family -> string (* @ $(SML_LIB)/basis/net/socket.sml 56.11-56.18 *)
structure Socket.Ctl:
   sig
      val getATMARK: ('a, Socket.active Socket.stream) Socket.sock -> bool
      val getBROADCAST: ('a, 'b) Socket.sock -> bool
      val getDEBUG: ('a, 'b) Socket.sock -> bool
      val getDONTROUTE: ('a, 'b) Socket.sock -> bool
      val getERROR: ('a, 'b) Socket.sock -> bool
      val getKEEPALIVE: ('a, 'b) Socket.sock -> bool
      val getLINGER: ('a, 'b) Socket.sock -> Time.time option
      val getNREAD: ('a, 'b) Socket.sock -> int
      val getOOBINLINE: ('a, 'b) Socket.sock -> bool
      val getPeerName: ('a, 'b) Socket.sock -> 'a Socket.sock_addr
      val getRCVBUF: ('a, 'b) Socket.sock -> int
      val getREUSEADDR: ('a, 'b) Socket.sock -> bool
      val getSNDBUF: ('a, 'b) Socket.sock -> int
      val getSockName: ('a, 'b) Socket.sock -> 'a Socket.sock_addr
      val getTYPE: ('a, 'b) Socket.sock -> Socket.SOCK.sock_type
      val setBROADCAST: ('a, 'b) Socket.sock * bool -> unit
      val setDEBUG: ('a, 'b) Socket.sock * bool -> unit
      val setDONTROUTE: ('a, 'b) Socket.sock * bool -> unit
      val setKEEPALIVE: ('a, 'b) Socket.sock * bool -> unit
      val setLINGER: ('a, 'b) Socket.sock * Time.time option -> unit
      val setOOBINLINE: ('a, 'b) Socket.sock * bool -> unit
      val setRCVBUF: ('a, 'b) Socket.sock * int -> unit
      val setREUSEADDR: ('a, 'b) Socket.sock * bool -> unit
      val setSNDBUF: ('a, 'b) Socket.sock * int -> unit
   end
   (* @ $(SML_LIB)/basis/net/socket.sml 206.11-206.13 *)
val Socket.Ctl.getATMARK: ('a, Socket.active Socket.stream) Socket.sock -> bool (* @ $(SML_LIB)/basis/net/socket.sml 197.11-197.19 *)
val Socket.Ctl.getBROADCAST: ('a, 'b) Socket.sock -> bool (* @ $(SML_LIB)/basis/net/socket.sml 163.12-163.23 *)
val Socket.Ctl.getDEBUG: ('a, 'b) Socket.sock -> bool (* @ $(SML_LIB)/basis/net/socket.sml 157.12-157.19 *)
val Socket.Ctl.getDONTROUTE: ('a, 'b) Socket.sock -> bool (* @ $(SML_LIB)/basis/net/socket.sml 160.12-160.23 *)
val Socket.Ctl.getERROR: ('a, 'b) Socket.sock -> bool (* @ $(SML_LIB)/basis/net/socket.sml 210.11-210.18 *)
val Socket.Ctl.getKEEPALIVE: ('a, 'b) Socket.sock -> bool (* @ $(SML_LIB)/basis/net/socket.sml 159.12-159.23 *)
val Socket.Ctl.getLINGER: ('a, 'b) Socket.sock -> Time.time option (* @ $(SML_LIB)/basis/net/socket.sml 161.11-161.19 *)
val Socket.Ctl.getNREAD: ('a, 'b) Socket.sock -> int (* @ $(SML_LIB)/basis/net/socket.sml 190.11-190.18 *)
val Socket.Ctl.getOOBINLINE: ('a, 'b) Socket.sock -> bool (* @ $(SML_LIB)/basis/net/socket.sml 164.12-164.23 *)
val Socket.Ctl.getPeerName: ('a, 'b) Socket.sock -> 'a Socket.sock_addr (* @ $(SML_LIB)/basis/net/socket.sml 187.14-187.24 *)
val Socket.Ctl.getRCVBUF: ('a, 'b) Socket.sock -> int (* @ $(SML_LIB)/basis/net/socket.sml 166.12-166.20 *)
val Socket.Ctl.getREUSEADDR: ('a, 'b) Socket.sock -> bool (* @ $(SML_LIB)/basis/net/socket.sml 158.12-158.23 *)
val Socket.Ctl.getSNDBUF: ('a, 'b) Socket.sock -> int (* @ $(SML_LIB)/basis/net/socket.sml 165.12-165.20 *)
val Socket.Ctl.getSockName: ('a, 'b) Socket.sock -> 'a Socket.sock_addr (* @ $(SML_LIB)/basis/net/socket.sml 188.14-188.24 *)
val Socket.Ctl.getTYPE: ('a, 'b) Socket.sock -> Socket.SOCK.sock_type (* @ $(SML_LIB)/basis/net/socket.sml 167.11-167.17 *)
val Socket.Ctl.setBROADCAST: ('a, 'b) Socket.sock * bool -> unit (* @ $(SML_LIB)/basis/net/socket.sml 163.26-163.37 *)
val Socket.Ctl.setDEBUG: ('a, 'b) Socket.sock * bool -> unit (* @ $(SML_LIB)/basis/net/socket.sml 157.22-157.29 *)
val Socket.Ctl.setDONTROUTE: ('a, 'b) Socket.sock * bool -> unit (* @ $(SML_LIB)/basis/net/socket.sml 160.26-160.37 *)
val Socket.Ctl.setKEEPALIVE: ('a, 'b) Socket.sock * bool -> unit (* @ $(SML_LIB)/basis/net/socket.sml 159.26-159.37 *)
val Socket.Ctl.setLINGER: ('a, 'b) Socket.sock * Time.time option -> unit (* @ $(SML_LIB)/basis/net/socket.sml 162.11-162.19 *)
val Socket.Ctl.setOOBINLINE: ('a, 'b) Socket.sock * bool -> unit (* @ $(SML_LIB)/basis/net/socket.sml 164.26-164.37 *)
val Socket.Ctl.setRCVBUF: ('a, 'b) Socket.sock * int -> unit (* @ $(SML_LIB)/basis/net/socket.sml 166.23-166.31 *)
val Socket.Ctl.setREUSEADDR: ('a, 'b) Socket.sock * bool -> unit (* @ $(SML_LIB)/basis/net/socket.sml 158.26-158.37 *)
val Socket.Ctl.setSNDBUF: ('a, 'b) Socket.sock * int -> unit (* @ $(SML_LIB)/basis/net/socket.sml 165.23-165.31 *)
structure Socket.SOCK:
   sig
      type sock_type = Socket.SOCK.sock_type
      val dgram: Socket.SOCK.sock_type
      val fromString: string -> Socket.SOCK.sock_type option
      val list: unit -> (string * Socket.SOCK.sock_type) list
      val stream: Socket.SOCK.sock_type
      val toString: Socket.SOCK.sock_type -> string
   end
   (* @ $(SML_LIB)/basis/net/socket.sml 67.11-67.14 *)
type Socket.SOCK.sock_type = Socket.SOCK.sock_type (* @ $(SML_LIB)/basis/net/socket.sml 69.12-69.20 *)
val Socket.SOCK.dgram: Socket.SOCK.sock_type (* @ $(SML_LIB)/basis/net/socket.sml 73.11-73.15 *)
val Socket.SOCK.fromString: string -> Socket.SOCK.sock_type option (* @ $(SML_LIB)/basis/net/socket.sml 83.11-83.20 *)
val Socket.SOCK.list: unit -> (string * Socket.SOCK.sock_type) list (* @ $(SML_LIB)/basis/net/socket.sml 78.11-78.14 *)
val Socket.SOCK.stream: Socket.SOCK.sock_type (* @ $(SML_LIB)/basis/net/socket.sml 72.11-72.16 *)
val Socket.SOCK.toString: Socket.SOCK.sock_type -> string (* @ $(SML_LIB)/basis/net/socket.sml 79.11-79.18 *)
structure String: STRING where type char = char where type string = string (* @ $(SML_LIB)/basis/libs/basis-extra/top-level/basis.sml 37.17-37.22 *)
type String.char = char (* @ $(SML_LIB)/basis/text/string.sml 27.12-27.15 *)
type String.string = string (* @ $(SML_LIB)/basis/text/string.sml 28.12-28.17 *)
val String.< : string * string -> bool (* @ $(SML_LIB)/basis/util/string-comparisons.sml 12.11-12.11 *)
val String.<= : string * string -> bool (* @ $(SML_LIB)/basis/util/string-comparisons.sml 16.11-16.12 *)
val String.> : string * string -> bool (* @ $(SML_LIB)/basis/util/string-comparisons.sml 20.11-20.11 *)
val String.>= : string * string -> bool (* @ $(SML_LIB)/basis/util/string-comparisons.sml 24.11-24.12 *)
val String.^ : string * string -> string (* @ $(SML_LIB)/basis/text/string.sml 35.14-35.14 *)
val String.collate: (char * char -> order) -> string * string -> order (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 477.13-477.19 *)
val String.compare: string * string -> order (* @ $(SML_LIB)/basis/text/string.sml 52.11-52.17 *)
val String.concat: string list -> string (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 462.13-462.18 *)
val String.concatWith: string -> string list -> string (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 478.13-478.22 *)
val String.explode: string -> char list (* @ $(SML_LIB)/basis/text/string.sml 37.11-37.17 *)
val String.extract: string * int * int option -> string (* @ $(SML_LIB)/basis/text/string.sml 39.11-39.17 *)
val String.fields: (char -> bool) -> string -> string list (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 484.13-484.18 *)
val String.fromCString: string -> string option (* @ $(SML_LIB)/basis/text/string.sml 84.11-84.21 *)
val String.fromString: string -> string option (* @ $(SML_LIB)/basis/text/string.sml 77.11-77.20 *)
val String.implode: char list -> string (* @ $(SML_LIB)/basis/text/string.sml 36.11-36.17 *)
val String.isPrefix: string -> string -> bool (* @ $(SML_LIB)/basis/text/string.sml 48.13-48.20 *)
val String.isSubstring: string -> string -> bool (* @ $(SML_LIB)/basis/text/string.sml 49.13-49.23 *)
val String.isSuffix: string -> string -> bool (* @ $(SML_LIB)/basis/text/string.sml 50.13-50.20 *)
val String.map: (char -> char) -> string -> string (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 466.13-466.15 *)
val String.maxSize: int (* @ $(SML_LIB)/basis/text/string.sml 33.11-33.17 *)
val String.scan: ('a -> (char * 'a) option) -> 'a -> (string * 'a) option (* @ $(SML_LIB)/basis/text/string.sml 65.11-65.14 *)
val String.size: string -> int (* @ $(SML_LIB)/basis/text/string.sml 34.11-34.14 *)
val String.str: char -> string (* @ $(SML_LIB)/basis/text/string.sml 31.11-31.13 *)
val String.sub: string * int -> char (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 450.13-450.15 *)
val String.substring: string * int * int -> string (* @ $(SML_LIB)/basis/text/string.sml 41.11-41.19 *)
val String.toCString: string -> string (* @ $(SML_LIB)/basis/text/string.sml 63.11-63.19 *)
val String.toString: string -> string (* @ $(SML_LIB)/basis/text/string.sml 62.11-62.18 *)
val String.tokens: (char -> bool) -> string -> string list (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 483.13-483.18 *)
val String.translate: (char -> string) -> string -> string (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 482.13-482.21 *)
structure StringCvt: STRING_CVT where type cs = StringCvt.cs where type radix = StringCvt.radix where type realfmt = StringCvt.realfmt (* @ $(SML_LIB)/basis/libs/basis-extra/top-level/basis.sml 38.17-38.25 *)
type StringCvt.cs = StringCvt.cs (* @ $(SML_LIB)/basis/text/string-cvt.sml 63.12-63.13 *)
datatype StringCvt.radix = BIN | DEC | HEX | OCT (* = datatype StringCvt.radix *) (* @ $(SML_LIB)/basis/text/string-cvt.sml 15.16-15.20 *)
type ('a, 'b) StringCvt.reader = 'b -> ('a * 'b) option (* @ $(SML_LIB)/basis/text/string-cvt.sml 30.21-30.26 *)
datatype StringCvt.realfmt = EXACT | FIX of int option | GEN of int option | SCI of int option (* = datatype StringCvt.realfmt *) (* @ $(SML_LIB)/basis/text/string-cvt.sml 24.16-24.22 *)
con StringCvt.BIN: StringCvt.radix (* @ $(SML_LIB)/basis/text/string-cvt.sml 15.24-15.26 *)
con StringCvt.DEC: StringCvt.radix (* @ $(SML_LIB)/basis/text/string-cvt.sml 15.36-15.38 *)
con StringCvt.EXACT: StringCvt.realfmt (* @ $(SML_LIB)/basis/text/string-cvt.sml 28.10-28.14 *)
con StringCvt.FIX: int option -> StringCvt.realfmt (* @ $(SML_LIB)/basis/text/string-cvt.sml 26.10-26.12 *)
con StringCvt.GEN: int option -> StringCvt.realfmt (* @ $(SML_LIB)/basis/text/string-cvt.sml 27.10-27.12 *)
con StringCvt.HEX: StringCvt.radix (* @ $(SML_LIB)/basis/text/string-cvt.sml 15.42-15.44 *)
con StringCvt.OCT: StringCvt.radix (* @ $(SML_LIB)/basis/text/string-cvt.sml 15.30-15.32 *)
con StringCvt.SCI: int option -> StringCvt.realfmt (* @ $(SML_LIB)/basis/text/string-cvt.sml 25.10-25.12 *)
val StringCvt.dropl: (char -> bool) -> ('a -> (char * 'a) option) -> 'a -> 'a (* @ $(SML_LIB)/basis/text/string-cvt.sml 61.11-61.15 *)
val StringCvt.padLeft: char -> int -> string -> string (* @ $(SML_LIB)/basis/text/string-cvt.sml 44.14-44.20 *)
val StringCvt.padRight: char -> int -> string -> string (* @ $(SML_LIB)/basis/text/string-cvt.sml 45.14-45.21 *)
val StringCvt.scanString: ((StringCvt.cs -> (char * StringCvt.cs) option) -> StringCvt.cs -> ('a * StringCvt.cs) option) -> string -> 'a option (* @ $(SML_LIB)/basis/text/string-cvt.sml 70.14-70.23 *)
val StringCvt.skipWS: ('a -> (char * 'a) option) -> 'a -> 'a (* @ $(SML_LIB)/basis/text/string-cvt.sml 113.14-113.19 *)
val StringCvt.splitl: (char -> bool) -> ('a -> (char * 'a) option) -> 'a -> string * 'a (* @ $(SML_LIB)/basis/text/string-cvt.sml 48.11-48.16 *)
val StringCvt.takel: (char -> bool) -> ('a -> (char * 'a) option) -> 'a -> string (* @ $(SML_LIB)/basis/text/string-cvt.sml 60.11-60.15 *)
structure Substring: SUBSTRING where type char = char where type string = string where type substring = char VectorSlice.slice (* @ $(SML_LIB)/basis/libs/basis-extra/top-level/basis.sml 39.17-39.25 *)
type Substring.char = char (* @ $(SML_LIB)/basis/text/substring.sml 21.12-21.15 *)
type Substring.string = string (* @ $(SML_LIB)/basis/text/substring.sml 22.12-22.17 *)
type Substring.substring = char VectorSlice.slice (* @ $(SML_LIB)/basis/text/substring.sml 23.12-23.20 *)
val Substring.app: (char -> unit) -> char VectorSlice.slice -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 226.17-226.19 *)
val Substring.base: char VectorSlice.slice -> string * int * int (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 208.17-208.20 *)
val Substring.collate: (char * char -> order) -> char VectorSlice.slice * char VectorSlice.slice -> order (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 236.17-236.23 *)
val Substring.compare: char VectorSlice.slice * char VectorSlice.slice -> order (* @ $(SML_LIB)/basis/text/substring.sml 41.11-41.17 *)
val Substring.concat: char VectorSlice.slice list -> string (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 240.17-240.22 *)
val Substring.concatWith: string -> char VectorSlice.slice list -> string (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 263.17-263.26 *)
val Substring.dropl: (char -> bool) -> char VectorSlice.slice -> char VectorSlice.slice (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 407.17-407.21 *)
val Substring.dropr: (char -> bool) -> char VectorSlice.slice -> char VectorSlice.slice (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 408.17-408.21 *)
val Substring.explode: char VectorSlice.slice -> char list (* @ $(SML_LIB)/basis/text/substring.sml 32.11-32.17 *)
val Substring.extract: string * int * int option -> char VectorSlice.slice (* @ $(SML_LIB)/basis/text/substring.sml 26.11-26.17 *)
val Substring.fields: (char -> bool) -> char VectorSlice.slice -> char VectorSlice.slice list (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 437.20-437.25 *)
val Substring.first: char VectorSlice.slice -> char option (* @ $(SML_LIB)/basis/text/substring.sml 30.11-30.15 *)
val Substring.foldl: (char * 'a -> 'a) -> 'a -> char VectorSlice.slice -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 223.17-223.21 *)
val Substring.foldr: (char * 'a -> 'a) -> 'a -> char VectorSlice.slice -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 224.17-224.21 *)
val Substring.full: string -> char VectorSlice.slice (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 192.17-192.20 *)
val Substring.getc: char VectorSlice.slice -> (char * char VectorSlice.slice) option (* @ $(SML_LIB)/basis/text/substring.sml 29.11-29.14 *)
val Substring.isEmpty: char VectorSlice.slice -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 219.17-219.23 *)
val Substring.isPrefix: string -> char VectorSlice.slice -> bool (* @ $(SML_LIB)/basis/text/substring.sml 36.13-36.20 *)
val Substring.isSubstring: string -> char VectorSlice.slice -> bool (* @ $(SML_LIB)/basis/text/substring.sml 37.13-37.23 *)
val Substring.isSuffix: string -> char VectorSlice.slice -> bool (* @ $(SML_LIB)/basis/text/substring.sml 38.13-38.20 *)
val Substring.position: string -> char VectorSlice.slice -> char VectorSlice.slice * char VectorSlice.slice (* @ $(SML_LIB)/basis/text/substring.sml 39.13-39.20 *)
val Substring.size: char VectorSlice.slice -> int (* @ $(SML_LIB)/basis/text/substring.sml 25.11-25.14 *)
val Substring.slice: char VectorSlice.slice * int * int option -> char VectorSlice.slice (* @ $(SML_LIB)/basis/text/substring.sml 31.11-31.15 *)
val Substring.span: char VectorSlice.slice * char VectorSlice.slice -> char VectorSlice.slice (* @ $(SML_LIB)/basis/arrays-and-vectors/vector.sml 24.17-24.20 *)
val Substring.splitAt: char VectorSlice.slice * int -> char VectorSlice.slice * char VectorSlice.slice (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 402.17-402.23 *)
val Substring.splitl: (char -> bool) -> char VectorSlice.slice -> char VectorSlice.slice * char VectorSlice.slice (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 400.17-400.22 *)
val Substring.splitr: (char -> bool) -> char VectorSlice.slice -> char VectorSlice.slice * char VectorSlice.slice (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 401.17-401.22 *)
val Substring.string: char VectorSlice.slice -> string (* @ $(SML_LIB)/basis/text/substring.sml 28.11-28.16 *)
val Substring.sub: char VectorSlice.slice * int -> char (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 142.17-142.19 *)
val Substring.substring: string * int * int -> char VectorSlice.slice (* @ $(SML_LIB)/basis/text/substring.sml 27.11-27.19 *)
val Substring.takel: (char -> bool) -> char VectorSlice.slice -> char VectorSlice.slice (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 409.17-409.21 *)
val Substring.taker: (char -> bool) -> char VectorSlice.slice -> char VectorSlice.slice (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 410.17-410.21 *)
val Substring.tokens: (char -> bool) -> char VectorSlice.slice -> char VectorSlice.slice list (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 429.20-429.25 *)
val Substring.translate: (char -> string) -> char VectorSlice.slice -> string (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 412.17-412.25 *)
val Substring.triml: int -> char VectorSlice.slice -> char VectorSlice.slice (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 301.17-301.21 *)
val Substring.trimr: int -> char VectorSlice.slice -> char VectorSlice.slice (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 317.17-317.21 *)
structure SysWord: WORD where type word = LargeWord.word (* @ $(SML_LIB)/basis/libs/basis-extra/top-level/basis.sml 180.17-180.23 *)
type SysWord.word = LargeWord.word (* @ $(SML_LIB)/basis/primitive/prim-basis.sml 431.12-431.15 *)
val SysWord.* : LargeWord.word * LargeWord.word -> LargeWord.word (* @ $(SML_LIB)/basis/primitive/prim-word.sml 396.11-396.11 *)
val SysWord.+ : LargeWord.word * LargeWord.word -> LargeWord.word (* @ $(SML_LIB)/basis/primitive/prim-word.sml 393.11-393.11 *)
val SysWord.- : LargeWord.word * LargeWord.word -> LargeWord.word (* @ $(SML_LIB)/basis/primitive/prim-word.sml 406.11-406.11 *)
val SysWord.< : LargeWord.word * LargeWord.word -> bool (* @ $(SML_LIB)/basis/util/integral-comparisons.sml 11.11-11.11 *)
val SysWord.<< : LargeWord.word * word -> LargeWord.word (* @ $(SML_LIB)/basis/integer/word.sml 19.5-19.6 *)
val SysWord.<= : LargeWord.word * LargeWord.word -> bool (* @ $(SML_LIB)/basis/util/integral-comparisons.sml 12.11-12.12 *)
val SysWord.> : LargeWord.word * LargeWord.word -> bool (* @ $(SML_LIB)/basis/util/integral-comparisons.sml 13.11-13.11 *)
val SysWord.>= : LargeWord.word * LargeWord.word -> bool (* @ $(SML_LIB)/basis/util/integral-comparisons.sml 14.11-14.12 *)
val SysWord.>> : LargeWord.word * word -> LargeWord.word (* @ $(SML_LIB)/basis/integer/word.sml 23.5-23.6 *)
val SysWord.andb: LargeWord.word * LargeWord.word -> LargeWord.word (* @ $(SML_LIB)/basis/primitive/prim-word.sml 394.11-394.14 *)
val SysWord.compare: LargeWord.word * LargeWord.word -> order (* @ $(SML_LIB)/basis/util/integral-comparisons.sml 16.11-16.17 *)
val SysWord.div: LargeWord.word * LargeWord.word -> LargeWord.word (* @ $(SML_LIB)/basis/integer/num0.sml 97.23-97.25 *)
val SysWord.fmt: StringCvt.radix -> LargeWord.word -> string (* @ $(SML_LIB)/basis/integer/word.sml 104.8-104.10 *)
val SysWord.fromInt: int -> LargeWord.word (* @ $(SML_LIB)/basis/integer/word.sml 55.5-55.11 *)
val SysWord.fromLarge: LargeWord.word -> LargeWord.word (* @ $(SML_LIB)/basis/integer/word.sml 87.5-87.13 *)
val SysWord.fromLargeInt: LargeInt.int -> LargeWord.word (* @ $(SML_LIB)/basis/integer/word.sml 70.5-70.16 *)
val SysWord.fromLargeWord: LargeWord.word -> LargeWord.word (* @ $(SML_LIB)/basis/integer/word.sml 86.5-86.17 *)
val SysWord.fromString: string -> LargeWord.word option (* @ $(SML_LIB)/basis/integer/word.sml 209.5-209.14 *)
val SysWord.max: LargeWord.word * LargeWord.word -> LargeWord.word (* @ $(SML_LIB)/basis/util/integral-comparisons.sml 21.11-21.13 *)
val SysWord.min: LargeWord.word * LargeWord.word -> LargeWord.word (* @ $(SML_LIB)/basis/util/integral-comparisons.sml 20.11-20.13 *)
val SysWord.mod: LargeWord.word * LargeWord.word -> LargeWord.word (* @ $(SML_LIB)/basis/integer/num0.sml 98.23-98.25 *)
val SysWord.notb: LargeWord.word -> LargeWord.word (* @ $(SML_LIB)/basis/primitive/prim-word.sml 398.11-398.14 *)
val SysWord.orb: LargeWord.word * LargeWord.word -> LargeWord.word (* @ $(SML_LIB)/basis/primitive/prim-word.sml 399.11-399.13 *)
val SysWord.scan: StringCvt.radix -> ('a -> (char * 'a) option) -> 'a -> (LargeWord.word * 'a) option (* @ $(SML_LIB)/basis/integer/word.sml 146.5-146.8 *)
val SysWord.toInt: LargeWord.word -> int (* @ $(SML_LIB)/basis/integer/word.sml 57.5-57.9 *)
val SysWord.toIntX: LargeWord.word -> int (* @ $(SML_LIB)/basis/integer/word.sml 56.5-56.10 *)
val SysWord.toLarge: LargeWord.word -> LargeWord.word (* @ $(SML_LIB)/basis/integer/word.sml 91.5-91.11 *)
val SysWord.toLargeInt: LargeWord.word -> LargeInt.int (* @ $(SML_LIB)/basis/integer/word.sml 72.5-72.14 *)
val SysWord.toLargeIntX: LargeWord.word -> LargeInt.int (* @ $(SML_LIB)/basis/integer/word.sml 71.5-71.15 *)
val SysWord.toLargeWord: LargeWord.word -> LargeWord.word (* @ $(SML_LIB)/basis/integer/word.sml 90.5-90.15 *)
val SysWord.toLargeWordX: LargeWord.word -> LargeWord.word (* @ $(SML_LIB)/basis/integer/word.sml 88.5-88.16 *)
val SysWord.toLargeX: LargeWord.word -> LargeWord.word (* @ $(SML_LIB)/basis/integer/word.sml 89.5-89.12 *)
val SysWord.toString: LargeWord.word -> string (* @ $(SML_LIB)/basis/integer/word.sml 144.5-144.12 *)
val SysWord.wordSize: int (* @ $(SML_LIB)/basis/integer/word.sml 16.5-16.12 *)
val SysWord.xorb: LargeWord.word * LargeWord.word -> LargeWord.word (* @ $(SML_LIB)/basis/primitive/prim-word.sml 407.11-407.14 *)
val SysWord.~ : LargeWord.word -> LargeWord.word (* @ $(SML_LIB)/basis/primitive/prim-word.sml 397.11-397.11 *)
val SysWord.~>> : LargeWord.word * word -> LargeWord.word (* @ $(SML_LIB)/basis/integer/word.sml 27.5-27.7 *)
structure Text: TEXT where type Char.char = char where type Char.string = string where type CharArray.array = CharArray.array where type CharArraySlice.slice = CharArraySlice.slice where type CharArraySlice.vector_slice = char VectorSlice.slice where type Substring.substring = char VectorSlice.slice (* @ $(SML_LIB)/basis/libs/basis-extra/top-level/basis.sml 40.17-40.20 *)
structure Text.Char: CHAR where type char = char where type string = string (* @ $(SML_LIB)/basis/text/text.sml 10.17-10.20 *)
type Text.Char.char = char (* @ $(SML_LIB)/basis/primitive/prim-basis.sml 57.12-57.15 *)
type Text.Char.string = string (* @ $(SML_LIB)/basis/text/char.sml 25.12-25.17 *)
val Text.Char.< : char * char -> bool (* @ $(SML_LIB)/basis/util/integral-comparisons.sml 11.11-11.11 *)
val Text.Char.<= : char * char -> bool (* @ $(SML_LIB)/basis/util/integral-comparisons.sml 12.11-12.12 *)
val Text.Char.> : char * char -> bool (* @ $(SML_LIB)/basis/util/integral-comparisons.sml 13.11-13.11 *)
val Text.Char.>= : char * char -> bool (* @ $(SML_LIB)/basis/util/integral-comparisons.sml 14.11-14.12 *)
val Text.Char.chr: int -> char (* @ $(SML_LIB)/basis/text/char.sml 50.11-50.13 *)
val Text.Char.compare: char * char -> order (* @ $(SML_LIB)/basis/util/integral-comparisons.sml 16.11-16.17 *)
val Text.Char.contains: string -> char -> bool (* @ $(SML_LIB)/basis/text/char.sml 59.11-59.18 *)
val Text.Char.fromCString: string -> char option (* @ $(SML_LIB)/basis/text/char.sml 272.11-272.21 *)
val Text.Char.fromString: string -> char option (* @ $(SML_LIB)/basis/text/char.sml 217.11-217.20 *)
val Text.Char.isAlpha: char -> bool (* @ $(SML_LIB)/basis/text/char.sml 90.11-90.17 *)
val Text.Char.isAlphaNum: char -> bool (* @ $(SML_LIB)/basis/text/char.sml 91.11-91.20 *)
val Text.Char.isAscii: char -> bool (* @ $(SML_LIB)/basis/text/char.sml 87.11-87.17 *)
val Text.Char.isCntrl: char -> bool (* @ $(SML_LIB)/basis/text/char.sml 86.11-86.17 *)
val Text.Char.isDigit: char -> bool (* @ $(SML_LIB)/basis/text/char.sml 83.11-83.17 *)
val Text.Char.isGraph: char -> bool (* @ $(SML_LIB)/basis/text/char.sml 84.11-84.17 *)
val Text.Char.isHexDigit: char -> bool (* @ $(SML_LIB)/basis/text/char.sml 96.11-96.20 *)
val Text.Char.isLower: char -> bool (* @ $(SML_LIB)/basis/text/char.sml 81.11-81.17 *)
val Text.Char.isPrint: char -> bool (* @ $(SML_LIB)/basis/text/char.sml 85.11-85.17 *)
val Text.Char.isPunct: char -> bool (* @ $(SML_LIB)/basis/text/char.sml 102.11-102.17 *)
val Text.Char.isSpace: char -> bool (* @ $(SML_LIB)/basis/text/char.sml 101.11-101.17 *)
val Text.Char.isUpper: char -> bool (* @ $(SML_LIB)/basis/text/char.sml 82.11-82.17 *)
val Text.Char.maxChar: char (* @ $(SML_LIB)/basis/text/char0.sml 57.44-57.50 *)
val Text.Char.maxOrd: int (* @ $(SML_LIB)/basis/text/char.sml 26.11-26.16 *)
val Text.Char.minChar: char (* @ $(SML_LIB)/basis/text/char0.sml 57.35-57.41 *)
val Text.Char.notContains: string -> char -> bool (* @ $(SML_LIB)/basis/text/char.sml 74.11-74.21 *)
val Text.Char.ord: char -> int (* @ $(SML_LIB)/basis/text/char0.sml 57.30-57.32 *)
val Text.Char.pred: char -> char (* @ $(SML_LIB)/basis/text/char.sml 38.11-38.14 *)
val Text.Char.scan: ('a -> (char * 'a) option) -> 'a -> (char * 'a) option (* @ $(SML_LIB)/basis/text/char.sml 160.14-160.17 *)
val Text.Char.succ: char -> char (* @ $(SML_LIB)/basis/text/char.sml 32.11-32.14 *)
val Text.Char.toCString: char -> string (* @ $(SML_LIB)/basis/text/char.sml 324.11-324.19 *)
val Text.Char.toLower: char -> char (* @ $(SML_LIB)/basis/text/char.sml 109.14-109.20 *)
val Text.Char.toString: char -> string (* @ $(SML_LIB)/basis/text/char.sml 292.11-292.18 *)
val Text.Char.toUpper: char -> char (* @ $(SML_LIB)/basis/text/char.sml 110.14-110.20 *)
structure Text.CharArray: MONO_ARRAY where type array = CharArray.array where type elem = char where type vector = string (* @ $(SML_LIB)/basis/text/text.sml 11.17-11.25 *)
type Text.CharArray.array = CharArray.array (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array.fun 23.12-23.16 *)
type Text.CharArray.elem = char (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array.fun 22.12-22.15 *)
type Text.CharArray.vector = string (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array.fun 24.12-24.17 *)
val Text.CharArray.all: (char -> bool) -> CharArray.array -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 476.13-476.15 *)
val Text.CharArray.app: (char -> unit) -> CharArray.array -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 464.13-464.15 *)
val Text.CharArray.appi: (int * char -> unit) -> CharArray.array -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 463.13-463.16 *)
val Text.CharArray.array: int * char -> CharArray.array (* @ $(SML_LIB)/basis/arrays-and-vectors/array.sml 34.11-34.15 *)
val Text.CharArray.collate: (char * char -> order) -> CharArray.array * CharArray.array -> order (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 477.13-477.19 *)
val Text.CharArray.copy: {di: int, dst: CharArray.array, src: CharArray.array} -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 457.13-457.16 *)
val Text.CharArray.copyVec: {di: int, dst: CharArray.array, src: string} -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array.sml 37.11-37.17 *)
val Text.CharArray.exists: (char -> bool) -> CharArray.array -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 474.13-474.18 *)
val Text.CharArray.find: (char -> bool) -> CharArray.array -> char option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 472.13-472.16 *)
val Text.CharArray.findi: (int * char -> bool) -> CharArray.array -> (int * char) option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 471.13-471.17 *)
val Text.CharArray.foldl: (char * 'a -> 'a) -> 'a -> CharArray.array -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 468.13-468.17 *)
val Text.CharArray.foldli: (int * char * 'a -> 'a) -> 'a -> CharArray.array -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 467.13-467.18 *)
val Text.CharArray.foldr: (char * 'a -> 'a) -> 'a -> CharArray.array -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 470.13-470.17 *)
val Text.CharArray.foldri: (int * char * 'a -> 'a) -> 'a -> CharArray.array -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 469.13-469.18 *)
val Text.CharArray.fromList: char list -> CharArray.array (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 122.11-122.18 *)
val Text.CharArray.length: CharArray.array -> int (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 90.11-90.16 *)
val Text.CharArray.maxLen: int (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 88.11-88.16 *)
val Text.CharArray.modify: (char -> char) -> CharArray.array -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array.sml 40.11-40.16 *)
val Text.CharArray.modifyi: (int * char -> char) -> CharArray.array -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array.sml 39.11-39.17 *)
val Text.CharArray.sub: CharArray.array * int -> char (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 450.13-450.15 *)
val Text.CharArray.tabulate: int * (int -> char) -> CharArray.array (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 114.11-114.18 *)
val Text.CharArray.update: CharArray.array * int * char -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 452.13-452.18 *)
val Text.CharArray.vector: CharArray.array -> string (* @ $(SML_LIB)/basis/arrays-and-vectors/array.sml 36.11-36.16 *)
structure Text.CharArraySlice: MONO_ARRAY_SLICE where type array = CharArray.array where type elem = char where type slice = CharArraySlice.slice where type vector = string where type vector_slice = char VectorSlice.slice (* @ $(SML_LIB)/basis/text/text.sml 12.17-12.30 *)
type Text.CharArraySlice.array = CharArray.array (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array.fun 35.18-35.22 *)
type Text.CharArraySlice.elem = char (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array.fun 34.18-34.21 *)
type Text.CharArraySlice.slice = CharArraySlice.slice (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array.fun 36.18-36.22 *)
type Text.CharArraySlice.vector = string (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array.fun 37.18-37.23 *)
type Text.CharArraySlice.vector_slice = char VectorSlice.slice (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array.fun 38.18-38.29 *)
val Text.CharArraySlice.all: (char -> bool) -> CharArraySlice.slice -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 235.17-235.19 *)
val Text.CharArraySlice.app: (char -> unit) -> CharArraySlice.slice -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 226.17-226.19 *)
val Text.CharArraySlice.appi: (int * char -> unit) -> CharArraySlice.slice -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 225.17-225.20 *)
val Text.CharArraySlice.base: CharArraySlice.slice -> CharArray.array * int * int (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 208.17-208.20 *)
val Text.CharArraySlice.collate: (char * char -> order) -> CharArraySlice.slice * CharArraySlice.slice -> order (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 236.17-236.23 *)
val Text.CharArraySlice.copy: {di: int, dst: CharArray.array, src: CharArraySlice.slice} -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 185.17-185.20 *)
val Text.CharArraySlice.copyVec: {di: int, dst: CharArray.array, src: char VectorSlice.slice} -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array.sml 28.17-28.23 *)
val Text.CharArraySlice.exists: (char -> bool) -> CharArraySlice.slice -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 233.17-233.22 *)
val Text.CharArraySlice.find: (char -> bool) -> CharArraySlice.slice -> char option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 231.17-231.20 *)
val Text.CharArraySlice.findi: (int * char -> bool) -> CharArraySlice.slice -> (int * char) option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 229.17-229.21 *)
val Text.CharArraySlice.foldl: (char * 'a -> 'a) -> 'a -> CharArraySlice.slice -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 223.17-223.21 *)
val Text.CharArraySlice.foldli: (int * char * 'a -> 'a) -> 'a -> CharArraySlice.slice -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 221.17-221.22 *)
val Text.CharArraySlice.foldr: (char * 'a -> 'a) -> 'a -> CharArraySlice.slice -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 224.17-224.21 *)
val Text.CharArraySlice.foldri: (int * char * 'a -> 'a) -> 'a -> CharArraySlice.slice -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 222.17-222.22 *)
val Text.CharArraySlice.full: CharArray.array -> CharArraySlice.slice (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 192.17-192.20 *)
val Text.CharArraySlice.getItem: CharArraySlice.slice -> (char * CharArraySlice.slice) option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 220.17-220.23 *)
val Text.CharArraySlice.isEmpty: CharArraySlice.slice -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 219.17-219.23 *)
val Text.CharArraySlice.length: CharArraySlice.slice -> int (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 134.17-134.22 *)
val Text.CharArraySlice.modify: (char -> char) -> CharArraySlice.slice -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array.sml 31.17-31.22 *)
val Text.CharArraySlice.modifyi: (int * char -> char) -> CharArraySlice.slice -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array.sml 30.17-30.23 *)
val Text.CharArraySlice.slice: CharArray.array * int * int option -> CharArraySlice.slice (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 206.17-206.21 *)
val Text.CharArraySlice.sub: CharArraySlice.slice * int -> char (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 142.17-142.19 *)
val Text.CharArraySlice.subslice: CharArraySlice.slice * int * int option -> CharArraySlice.slice (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 199.17-199.24 *)
val Text.CharArraySlice.update: CharArraySlice.slice * int * char -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 155.17-155.22 *)
val Text.CharArraySlice.vector: CharArraySlice.slice -> string (* @ $(SML_LIB)/basis/arrays-and-vectors/array.sml 27.17-27.22 *)
structure Text.CharVector: MONO_VECTOR where type elem = char where type vector = string (* @ $(SML_LIB)/basis/text/text.sml 13.17-13.26 *)
type Text.CharVector.elem = char (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-vector.fun 35.12-35.15 *)
type Text.CharVector.vector = string (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-vector.fun 36.12-36.17 *)
val Text.CharVector.all: (char -> bool) -> string -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 476.13-476.15 *)
val Text.CharVector.app: (char -> unit) -> string -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 464.13-464.15 *)
val Text.CharVector.appi: (int * char -> unit) -> string -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 463.13-463.16 *)
val Text.CharVector.collate: (char * char -> order) -> string * string -> order (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 477.13-477.19 *)
val Text.CharVector.concat: string list -> string (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 462.13-462.18 *)
val Text.CharVector.exists: (char -> bool) -> string -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 474.13-474.18 *)
val Text.CharVector.find: (char -> bool) -> string -> char option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 472.13-472.16 *)
val Text.CharVector.findi: (int * char -> bool) -> string -> (int * char) option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 471.13-471.17 *)
val Text.CharVector.foldl: (char * 'a -> 'a) -> 'a -> string -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 468.13-468.17 *)
val Text.CharVector.foldli: (int * char * 'a -> 'a) -> 'a -> string -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 467.13-467.18 *)
val Text.CharVector.foldr: (char * 'a -> 'a) -> 'a -> string -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 470.13-470.17 *)
val Text.CharVector.foldri: (int * char * 'a -> 'a) -> 'a -> string -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 469.13-469.18 *)
val Text.CharVector.fromList: char list -> string (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 122.11-122.18 *)
val Text.CharVector.length: string -> int (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 90.11-90.16 *)
val Text.CharVector.map: (char -> char) -> string -> string (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 466.13-466.15 *)
val Text.CharVector.mapi: (int * char -> char) -> string -> string (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 465.13-465.16 *)
val Text.CharVector.maxLen: int (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 88.11-88.16 *)
val Text.CharVector.sub: string * int -> char (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 450.13-450.15 *)
val Text.CharVector.tabulate: int * (int -> char) -> string (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 114.11-114.18 *)
val Text.CharVector.update: string * int * char -> string (* @ $(SML_LIB)/basis/arrays-and-vectors/vector.sml 30.11-30.16 *)
structure Text.CharVectorSlice: MONO_VECTOR_SLICE where type elem = char where type slice = char VectorSlice.slice where type vector = string (* @ $(SML_LIB)/basis/text/text.sml 14.17-14.31 *)
type Text.CharVectorSlice.elem = char (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-vector.fun 43.18-43.21 *)
type Text.CharVectorSlice.slice = char VectorSlice.slice (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-vector.fun 45.18-45.22 *)
type Text.CharVectorSlice.vector = string (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-vector.fun 44.18-44.23 *)
val Text.CharVectorSlice.all: (char -> bool) -> char VectorSlice.slice -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 235.17-235.19 *)
val Text.CharVectorSlice.app: (char -> unit) -> char VectorSlice.slice -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 226.17-226.19 *)
val Text.CharVectorSlice.appi: (int * char -> unit) -> char VectorSlice.slice -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 225.17-225.20 *)
val Text.CharVectorSlice.base: char VectorSlice.slice -> string * int * int (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 208.17-208.20 *)
val Text.CharVectorSlice.collate: (char * char -> order) -> char VectorSlice.slice * char VectorSlice.slice -> order (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 236.17-236.23 *)
val Text.CharVectorSlice.concat: char VectorSlice.slice list -> string (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 240.17-240.22 *)
val Text.CharVectorSlice.exists: (char -> bool) -> char VectorSlice.slice -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 233.17-233.22 *)
val Text.CharVectorSlice.find: (char -> bool) -> char VectorSlice.slice -> char option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 231.17-231.20 *)
val Text.CharVectorSlice.findi: (int * char -> bool) -> char VectorSlice.slice -> (int * char) option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 229.17-229.21 *)
val Text.CharVectorSlice.foldl: (char * 'a -> 'a) -> 'a -> char VectorSlice.slice -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 223.17-223.21 *)
val Text.CharVectorSlice.foldli: (int * char * 'a -> 'a) -> 'a -> char VectorSlice.slice -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 221.17-221.22 *)
val Text.CharVectorSlice.foldr: (char * 'a -> 'a) -> 'a -> char VectorSlice.slice -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 224.17-224.21 *)
val Text.CharVectorSlice.foldri: (int * char * 'a -> 'a) -> 'a -> char VectorSlice.slice -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 222.17-222.22 *)
val Text.CharVectorSlice.full: string -> char VectorSlice.slice (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 192.17-192.20 *)
val Text.CharVectorSlice.getItem: char VectorSlice.slice -> (char * char VectorSlice.slice) option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 220.17-220.23 *)
val Text.CharVectorSlice.isEmpty: char VectorSlice.slice -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 219.17-219.23 *)
val Text.CharVectorSlice.length: char VectorSlice.slice -> int (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 134.17-134.22 *)
val Text.CharVectorSlice.map: (char -> char) -> char VectorSlice.slice -> string (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 228.17-228.19 *)
val Text.CharVectorSlice.mapi: (int * char -> char) -> char VectorSlice.slice -> string (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 227.17-227.20 *)
val Text.CharVectorSlice.slice: string * int * int option -> char VectorSlice.slice (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 206.17-206.21 *)
val Text.CharVectorSlice.sub: char VectorSlice.slice * int -> char (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 142.17-142.19 *)
val Text.CharVectorSlice.subslice: char VectorSlice.slice * int * int option -> char VectorSlice.slice (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 199.17-199.24 *)
val Text.CharVectorSlice.vector: char VectorSlice.slice -> string (* @ $(SML_LIB)/basis/arrays-and-vectors/vector.sml 21.17-21.22 *)
structure Text.String: STRING where type char = char where type string = string (* @ $(SML_LIB)/basis/text/text.sml 15.17-15.22 *)
type Text.String.char = char (* @ $(SML_LIB)/basis/text/string.sml 27.12-27.15 *)
type Text.String.string = string (* @ $(SML_LIB)/basis/text/string.sml 28.12-28.17 *)
val Text.String.< : string * string -> bool (* @ $(SML_LIB)/basis/util/string-comparisons.sml 12.11-12.11 *)
val Text.String.<= : string * string -> bool (* @ $(SML_LIB)/basis/util/string-comparisons.sml 16.11-16.12 *)
val Text.String.> : string * string -> bool (* @ $(SML_LIB)/basis/util/string-comparisons.sml 20.11-20.11 *)
val Text.String.>= : string * string -> bool (* @ $(SML_LIB)/basis/util/string-comparisons.sml 24.11-24.12 *)
val Text.String.^ : string * string -> string (* @ $(SML_LIB)/basis/text/string.sml 35.14-35.14 *)
val Text.String.collate: (char * char -> order) -> string * string -> order (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 477.13-477.19 *)
val Text.String.compare: string * string -> order (* @ $(SML_LIB)/basis/text/string.sml 52.11-52.17 *)
val Text.String.concat: string list -> string (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 462.13-462.18 *)
val Text.String.concatWith: string -> string list -> string (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 478.13-478.22 *)
val Text.String.explode: string -> char list (* @ $(SML_LIB)/basis/text/string.sml 37.11-37.17 *)
val Text.String.extract: string * int * int option -> string (* @ $(SML_LIB)/basis/text/string.sml 39.11-39.17 *)
val Text.String.fields: (char -> bool) -> string -> string list (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 484.13-484.18 *)
val Text.String.fromCString: string -> string option (* @ $(SML_LIB)/basis/text/string.sml 84.11-84.21 *)
val Text.String.fromString: string -> string option (* @ $(SML_LIB)/basis/text/string.sml 77.11-77.20 *)
val Text.String.implode: char list -> string (* @ $(SML_LIB)/basis/text/string.sml 36.11-36.17 *)
val Text.String.isPrefix: string -> string -> bool (* @ $(SML_LIB)/basis/text/string.sml 48.13-48.20 *)
val Text.String.isSubstring: string -> string -> bool (* @ $(SML_LIB)/basis/text/string.sml 49.13-49.23 *)
val Text.String.isSuffix: string -> string -> bool (* @ $(SML_LIB)/basis/text/string.sml 50.13-50.20 *)
val Text.String.map: (char -> char) -> string -> string (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 466.13-466.15 *)
val Text.String.maxSize: int (* @ $(SML_LIB)/basis/text/string.sml 33.11-33.17 *)
val Text.String.scan: ('a -> (char * 'a) option) -> 'a -> (string * 'a) option (* @ $(SML_LIB)/basis/text/string.sml 65.11-65.14 *)
val Text.String.size: string -> int (* @ $(SML_LIB)/basis/text/string.sml 34.11-34.14 *)
val Text.String.str: char -> string (* @ $(SML_LIB)/basis/text/string.sml 31.11-31.13 *)
val Text.String.sub: string * int -> char (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 450.13-450.15 *)
val Text.String.substring: string * int * int -> string (* @ $(SML_LIB)/basis/text/string.sml 41.11-41.19 *)
val Text.String.toCString: string -> string (* @ $(SML_LIB)/basis/text/string.sml 63.11-63.19 *)
val Text.String.toString: string -> string (* @ $(SML_LIB)/basis/text/string.sml 62.11-62.18 *)
val Text.String.tokens: (char -> bool) -> string -> string list (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 483.13-483.18 *)
val Text.String.translate: (char -> string) -> string -> string (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 482.13-482.21 *)
structure Text.Substring: SUBSTRING where type char = char where type string = string where type substring = char VectorSlice.slice (* @ $(SML_LIB)/basis/text/text.sml 16.17-16.25 *)
type Text.Substring.char = char (* @ $(SML_LIB)/basis/text/substring.sml 21.12-21.15 *)
type Text.Substring.string = string (* @ $(SML_LIB)/basis/text/substring.sml 22.12-22.17 *)
type Text.Substring.substring = char VectorSlice.slice (* @ $(SML_LIB)/basis/text/substring.sml 23.12-23.20 *)
val Text.Substring.app: (char -> unit) -> char VectorSlice.slice -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 226.17-226.19 *)
val Text.Substring.base: char VectorSlice.slice -> string * int * int (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 208.17-208.20 *)
val Text.Substring.collate: (char * char -> order) -> char VectorSlice.slice * char VectorSlice.slice -> order (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 236.17-236.23 *)
val Text.Substring.compare: char VectorSlice.slice * char VectorSlice.slice -> order (* @ $(SML_LIB)/basis/text/substring.sml 41.11-41.17 *)
val Text.Substring.concat: char VectorSlice.slice list -> string (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 240.17-240.22 *)
val Text.Substring.concatWith: string -> char VectorSlice.slice list -> string (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 263.17-263.26 *)
val Text.Substring.dropl: (char -> bool) -> char VectorSlice.slice -> char VectorSlice.slice (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 407.17-407.21 *)
val Text.Substring.dropr: (char -> bool) -> char VectorSlice.slice -> char VectorSlice.slice (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 408.17-408.21 *)
val Text.Substring.explode: char VectorSlice.slice -> char list (* @ $(SML_LIB)/basis/text/substring.sml 32.11-32.17 *)
val Text.Substring.extract: string * int * int option -> char VectorSlice.slice (* @ $(SML_LIB)/basis/text/substring.sml 26.11-26.17 *)
val Text.Substring.fields: (char -> bool) -> char VectorSlice.slice -> char VectorSlice.slice list (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 437.20-437.25 *)
val Text.Substring.first: char VectorSlice.slice -> char option (* @ $(SML_LIB)/basis/text/substring.sml 30.11-30.15 *)
val Text.Substring.foldl: (char * 'a -> 'a) -> 'a -> char VectorSlice.slice -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 223.17-223.21 *)
val Text.Substring.foldr: (char * 'a -> 'a) -> 'a -> char VectorSlice.slice -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 224.17-224.21 *)
val Text.Substring.full: string -> char VectorSlice.slice (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 192.17-192.20 *)
val Text.Substring.getc: char VectorSlice.slice -> (char * char VectorSlice.slice) option (* @ $(SML_LIB)/basis/text/substring.sml 29.11-29.14 *)
val Text.Substring.isEmpty: char VectorSlice.slice -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 219.17-219.23 *)
val Text.Substring.isPrefix: string -> char VectorSlice.slice -> bool (* @ $(SML_LIB)/basis/text/substring.sml 36.13-36.20 *)
val Text.Substring.isSubstring: string -> char VectorSlice.slice -> bool (* @ $(SML_LIB)/basis/text/substring.sml 37.13-37.23 *)
val Text.Substring.isSuffix: string -> char VectorSlice.slice -> bool (* @ $(SML_LIB)/basis/text/substring.sml 38.13-38.20 *)
val Text.Substring.position: string -> char VectorSlice.slice -> char VectorSlice.slice * char VectorSlice.slice (* @ $(SML_LIB)/basis/text/substring.sml 39.13-39.20 *)
val Text.Substring.size: char VectorSlice.slice -> int (* @ $(SML_LIB)/basis/text/substring.sml 25.11-25.14 *)
val Text.Substring.slice: char VectorSlice.slice * int * int option -> char VectorSlice.slice (* @ $(SML_LIB)/basis/text/substring.sml 31.11-31.15 *)
val Text.Substring.span: char VectorSlice.slice * char VectorSlice.slice -> char VectorSlice.slice (* @ $(SML_LIB)/basis/arrays-and-vectors/vector.sml 24.17-24.20 *)
val Text.Substring.splitAt: char VectorSlice.slice * int -> char VectorSlice.slice * char VectorSlice.slice (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 402.17-402.23 *)
val Text.Substring.splitl: (char -> bool) -> char VectorSlice.slice -> char VectorSlice.slice * char VectorSlice.slice (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 400.17-400.22 *)
val Text.Substring.splitr: (char -> bool) -> char VectorSlice.slice -> char VectorSlice.slice * char VectorSlice.slice (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 401.17-401.22 *)
val Text.Substring.string: char VectorSlice.slice -> string (* @ $(SML_LIB)/basis/text/substring.sml 28.11-28.16 *)
val Text.Substring.sub: char VectorSlice.slice * int -> char (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 142.17-142.19 *)
val Text.Substring.substring: string * int * int -> char VectorSlice.slice (* @ $(SML_LIB)/basis/text/substring.sml 27.11-27.19 *)
val Text.Substring.takel: (char -> bool) -> char VectorSlice.slice -> char VectorSlice.slice (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 409.17-409.21 *)
val Text.Substring.taker: (char -> bool) -> char VectorSlice.slice -> char VectorSlice.slice (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 410.17-410.21 *)
val Text.Substring.tokens: (char -> bool) -> char VectorSlice.slice -> char VectorSlice.slice list (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 429.20-429.25 *)
val Text.Substring.translate: (char -> string) -> char VectorSlice.slice -> string (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 412.17-412.25 *)
val Text.Substring.triml: int -> char VectorSlice.slice -> char VectorSlice.slice (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 301.17-301.21 *)
val Text.Substring.trimr: int -> char VectorSlice.slice -> char VectorSlice.slice (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 317.17-317.21 *)
structure TextIO: TEXT_IO where type StreamIO.instream = TextIO.StreamIO.instream where type StreamIO.out_pos = TextIO.StreamIO.out_pos where type StreamIO.outstream = TextIO.StreamIO.outstream where type instream = TextIO.instream where type outstream = TextIO.outstream (* @ $(SML_LIB)/basis/libs/basis-extra/top-level/basis.sml 41.17-41.22 *)
type TextIO.elem = char (* @ $(SML_LIB)/basis/io/imperative-io.fun 73.6-73.9 *)
type TextIO.instream = TextIO.instream (* @ $(SML_LIB)/basis/io/imperative-io.fun 213.10-213.17 *)
type TextIO.outstream = TextIO.outstream (* @ $(SML_LIB)/basis/io/imperative-io.fun 100.6-100.14 *)
type TextIO.vector = string (* @ $(SML_LIB)/basis/io/imperative-io.fun 74.6-74.11 *)
val TextIO.canInput: TextIO.instream * int -> int option (* @ $(SML_LIB)/basis/io/imperative-io.fun 515.5-515.12 *)
val TextIO.closeIn: TextIO.instream -> unit (* @ $(SML_LIB)/basis/io/imperative-io.fun 718.5-718.11 *)
val TextIO.closeOut: TextIO.outstream -> unit (* @ $(SML_LIB)/basis/io/imperative-io.fun 105.5-105.12 *)
val TextIO.endOfStream: TextIO.instream -> bool (* @ $(SML_LIB)/basis/io/imperative-io.fun 601.5-601.15 *)
val TextIO.flushOut: TextIO.outstream -> unit (* @ $(SML_LIB)/basis/io/imperative-io.fun 104.5-104.12 *)
val TextIO.getInstream: TextIO.instream -> TextIO.StreamIO.instream (* @ $(SML_LIB)/basis/io/imperative-io.fun 646.5-646.15 *)
val TextIO.getOutstream: TextIO.outstream -> TextIO.StreamIO.outstream (* @ $(SML_LIB)/basis/io/imperative-io.fun 107.5-107.16 *)
val TextIO.getPosOut: TextIO.outstream -> TextIO.StreamIO.out_pos (* @ $(SML_LIB)/basis/io/imperative-io.fun 109.5-109.13 *)
val TextIO.input: TextIO.instream -> string (* @ $(SML_LIB)/basis/io/imperative-io.fun 285.5-285.9 *)
val TextIO.input1: TextIO.instream -> char option (* @ $(SML_LIB)/basis/io/imperative-io.fun 316.5-316.10 *)
val TextIO.inputAll: TextIO.instream -> string (* @ $(SML_LIB)/basis/io/imperative-io.fun 413.5-413.12 *)
val TextIO.inputLine: TextIO.instream -> string option (* @ $(SML_LIB)/basis/io/imperative-io.fun 450.5-450.13 *)
val TextIO.inputN: TextIO.instream * int -> string (* @ $(SML_LIB)/basis/io/imperative-io.fun 350.5-350.10 *)
val TextIO.lookahead: TextIO.instream -> char option (* @ $(SML_LIB)/basis/io/imperative-io.fun 569.5-569.13 *)
val TextIO.mkInstream: TextIO.StreamIO.instream -> TextIO.instream (* @ $(SML_LIB)/basis/io/imperative-io.fun 227.8-227.17 *)
val TextIO.mkOutstream: TextIO.StreamIO.outstream -> TextIO.outstream (* @ $(SML_LIB)/basis/io/imperative-io.fun 106.5-106.15 *)
val TextIO.openAppend: string -> TextIO.outstream (* @ $(SML_LIB)/basis/io/imperative-io.fun 181.8-181.17 *)
val TextIO.openIn: string -> TextIO.instream (* @ $(SML_LIB)/basis/io/imperative-io.fun 745.5-745.10 *)
val TextIO.openOut: string -> TextIO.outstream (* @ $(SML_LIB)/basis/io/imperative-io.fun 168.8-168.14 *)
val TextIO.openString: string -> TextIO.instream (* @ $(SML_LIB)/basis/io/text-io.sml 38.11-38.20 *)
val TextIO.output: TextIO.outstream * string -> unit (* @ $(SML_LIB)/basis/io/imperative-io.fun 101.5-101.10 *)
val TextIO.output1: TextIO.outstream * char -> unit (* @ $(SML_LIB)/basis/io/imperative-io.fun 102.5-102.11 *)
val TextIO.outputSubstr: TextIO.outstream * char VectorSlice.slice -> unit (* @ $(SML_LIB)/basis/io/text-io.sml 36.11-36.22 *)
val TextIO.print: string -> unit (* @ $(SML_LIB)/basis/io/text-io.sml 40.11-40.15 *)
val TextIO.scanStream: ((TextIO.StreamIO.instream -> (char * TextIO.StreamIO.instream) option) -> TextIO.StreamIO.instream -> ('a * TextIO.StreamIO.instream) option) -> TextIO.instream -> 'a option (* @ $(SML_LIB)/basis/io/imperative-io.fun 713.5-713.14 *)
val TextIO.setInstream: TextIO.instream * TextIO.StreamIO.instream -> unit (* @ $(SML_LIB)/basis/io/imperative-io.fun 235.5-235.15 *)
val TextIO.setOutstream: TextIO.outstream * TextIO.StreamIO.outstream -> unit (* @ $(SML_LIB)/basis/io/imperative-io.fun 108.5-108.16 *)
val TextIO.setPosOut: TextIO.outstream * TextIO.StreamIO.out_pos -> unit (* @ $(SML_LIB)/basis/io/imperative-io.fun 110.5-110.13 *)
val TextIO.stdErr: TextIO.outstream (* @ $(SML_LIB)/basis/io/imperative-io.fun 129.5-129.10 *)
val TextIO.stdIn: TextIO.instream (* @ $(SML_LIB)/basis/io/imperative-io.fun 743.5-743.9 *)
val TextIO.stdOut: TextIO.outstream (* @ $(SML_LIB)/basis/io/imperative-io.fun 144.5-144.10 *)
structure TextIO.StreamIO: TEXT_STREAM_IO where type instream = TextIO.StreamIO.instream where type out_pos = TextIO.StreamIO.out_pos where type outstream = TextIO.StreamIO.outstream where type pos = Int64.int where type reader = TextPrimIO.reader where type writer = TextPrimIO.writer (* @ $(SML_LIB)/basis/io/text-io.sml 29.17-29.24 *)
type TextIO.StreamIO.elem = char (* @ $(SML_LIB)/basis/io/stream-io.fun 51.12-51.15 *)
type TextIO.StreamIO.instream = TextIO.StreamIO.instream (* @ $(SML_LIB)/basis/io/stream-io.fun 389.16-389.23 *)
type TextIO.StreamIO.out_pos = TextIO.StreamIO.out_pos (* @ $(SML_LIB)/basis/io/stream-io.fun 357.16-357.22 *)
type TextIO.StreamIO.outstream = TextIO.StreamIO.outstream (* @ $(SML_LIB)/basis/io/stream-io.fun 83.16-83.24 *)
type TextIO.StreamIO.pos = Int64.int (* @ $(SML_LIB)/basis/io/stream-io.fun 56.12-56.14 *)
type TextIO.StreamIO.reader = TextPrimIO.reader (* @ $(SML_LIB)/basis/io/stream-io.fun 54.12-54.17 *)
type TextIO.StreamIO.vector = string (* @ $(SML_LIB)/basis/io/stream-io.fun 52.12-52.17 *)
type TextIO.StreamIO.writer = TextPrimIO.writer (* @ $(SML_LIB)/basis/io/stream-io.fun 55.12-55.17 *)
val TextIO.StreamIO.canInput: TextIO.StreamIO.instream * int -> int option (* @ $(SML_LIB)/basis/io/stream-io.fun 649.11-649.18 *)
val TextIO.StreamIO.closeIn: TextIO.StreamIO.instream -> unit (* @ $(SML_LIB)/basis/io/stream-io.fun 953.11-953.17 *)
val TextIO.StreamIO.closeOut: TextIO.StreamIO.outstream -> unit (* @ $(SML_LIB)/basis/io/stream-io.fun 896.11-896.18 *)
val TextIO.StreamIO.endOfStream: TextIO.StreamIO.instream -> bool (* @ $(SML_LIB)/basis/io/stream-io.fun 724.11-724.21 *)
val TextIO.StreamIO.filePosIn: TextIO.StreamIO.instream -> Int64.int (* @ $(SML_LIB)/basis/io/stream-io.fun 784.11-784.19 *)
val TextIO.StreamIO.filePosOut: TextIO.StreamIO.out_pos -> Int64.int (* @ $(SML_LIB)/basis/io/stream-io.fun 374.11-374.20 *)
val TextIO.StreamIO.flushOut: TextIO.StreamIO.outstream -> unit (* @ $(SML_LIB)/basis/io/stream-io.fun 267.11-267.18 *)
val TextIO.StreamIO.getBufferMode: TextIO.StreamIO.outstream -> IO.buffer_mode (* @ $(SML_LIB)/basis/io/stream-io.fun 299.11-299.23 *)
val TextIO.StreamIO.getPosOut: TextIO.StreamIO.outstream -> TextIO.StreamIO.out_pos (* @ $(SML_LIB)/basis/io/stream-io.fun 360.11-360.19 *)
val TextIO.StreamIO.getReader: TextIO.StreamIO.instream -> TextPrimIO.reader * string (* @ $(SML_LIB)/basis/io/stream-io.fun 776.11-776.19 *)
val TextIO.StreamIO.getWriter: TextIO.StreamIO.outstream -> TextPrimIO.writer * IO.buffer_mode (* @ $(SML_LIB)/basis/io/stream-io.fun 345.11-345.19 *)
val TextIO.StreamIO.input: TextIO.StreamIO.instream -> string * TextIO.StreamIO.instream (* @ $(SML_LIB)/basis/io/stream-io.fun 471.11-471.15 *)
val TextIO.StreamIO.input1: TextIO.StreamIO.instream -> (char * TextIO.StreamIO.instream) option (* @ $(SML_LIB)/basis/io/stream-io.fun 554.11-554.16 *)
val TextIO.StreamIO.inputAll: TextIO.StreamIO.instream -> string * TextIO.StreamIO.instream (* @ $(SML_LIB)/basis/io/stream-io.fun 559.11-559.18 *)
val TextIO.StreamIO.inputLine: TextIO.StreamIO.instream -> (string * TextIO.StreamIO.instream) option (* @ $(SML_LIB)/basis/io/stream-io.fun 572.11-572.19 *)
val TextIO.StreamIO.inputN: TextIO.StreamIO.instream * int -> string * TextIO.StreamIO.instream (* @ $(SML_LIB)/basis/io/stream-io.fun 486.11-486.16 *)
val TextIO.StreamIO.mkInstream: TextPrimIO.reader * string -> TextIO.StreamIO.instream (* @ $(SML_LIB)/basis/io/stream-io.fun 947.11-947.20 *)
val TextIO.StreamIO.mkOutstream: TextPrimIO.writer * IO.buffer_mode -> TextIO.StreamIO.outstream (* @ $(SML_LIB)/basis/io/stream-io.fun 891.11-891.21 *)
val TextIO.StreamIO.output: TextIO.StreamIO.outstream * string -> unit (* @ $(SML_LIB)/basis/io/stream-io.fun 139.11-139.16 *)
val TextIO.StreamIO.output1: TextIO.StreamIO.outstream * char -> unit (* @ $(SML_LIB)/basis/io/stream-io.fun 185.14-185.20 *)
val TextIO.StreamIO.outputSubstr: TextIO.StreamIO.outstream * char VectorSlice.slice -> unit (* @ $(SML_LIB)/basis/io/text-io.sml 33.17-33.28 *)
val TextIO.StreamIO.setBufferMode: TextIO.StreamIO.outstream * IO.buffer_mode -> unit (* @ $(SML_LIB)/basis/io/stream-io.fun 305.11-305.23 *)
val TextIO.StreamIO.setPosOut: TextIO.StreamIO.out_pos -> TextIO.StreamIO.outstream (* @ $(SML_LIB)/basis/io/stream-io.fun 367.11-367.19 *)
structure TextPrimIO: PRIM_IO where type array = CharArray.array where type array_slice = CharArraySlice.slice where type elem = char where type pos = Int64.int where type reader = TextPrimIO.reader where type vector = string where type vector_slice = char VectorSlice.slice where type writer = TextPrimIO.writer (* @ $(SML_LIB)/basis/libs/basis-extra/top-level/basis.sml 42.17-42.26 *)
type TextPrimIO.array = CharArray.array (* @ $(SML_LIB)/basis/io/prim-io.fun 39.12-39.16 *)
type TextPrimIO.array_slice = CharArraySlice.slice (* @ $(SML_LIB)/basis/io/prim-io.fun 40.12-40.22 *)
type TextPrimIO.elem = char (* @ $(SML_LIB)/basis/io/prim-io.fun 36.12-36.15 *)
type TextPrimIO.pos = Int64.int (* @ $(SML_LIB)/basis/io/prim-io.fun 41.12-41.14 *)
datatype TextPrimIO.reader = RD of {avail: unit -> int option, block: (unit -> unit) option, canInput: (unit -> bool) option, chunkSize: int, close: unit -> unit, endPos: (unit -> Int64.int) option, getPos: (unit -> Int64.int) option, ioDesc: OS.IO.iodesc option, name: string, readArr: (CharArraySlice.slice -> int) option, readArrNB: (CharArraySlice.slice -> int option) option, readVec: (int -> string) option, readVecNB: (int -> string option) option, setPos: (Int64.int -> unit) option, verifyPos: (unit -> Int64.int) option} (* = datatype TextPrimIO.reader *) (* @ $(SML_LIB)/basis/io/prim-io.fun 44.16-44.21 *)
type TextPrimIO.vector = string (* @ $(SML_LIB)/basis/io/prim-io.fun 37.12-37.17 *)
type TextPrimIO.vector_slice = char VectorSlice.slice (* @ $(SML_LIB)/basis/io/prim-io.fun 38.12-38.23 *)
datatype TextPrimIO.writer = WR of {block: (unit -> unit) option, canOutput: (unit -> bool) option, chunkSize: int, close: unit -> unit, endPos: (unit -> Int64.int) option, getPos: (unit -> Int64.int) option, ioDesc: OS.IO.iodesc option, name: string, setPos: (Int64.int -> unit) option, verifyPos: (unit -> Int64.int) option, writeArr: (CharArraySlice.slice -> int) option, writeArrNB: (CharArraySlice.slice -> int option) option, writeVec: (char VectorSlice.slice -> int) option, writeVecNB: (char VectorSlice.slice -> int option) option} (* = datatype TextPrimIO.writer *) (* @ $(SML_LIB)/basis/io/prim-io.fun 61.16-61.21 *)
con TextPrimIO.RD: {avail: unit -> int option, block: (unit -> unit) option, canInput: (unit -> bool) option, chunkSize: int, close: unit -> unit, endPos: (unit -> Int64.int) option, getPos: (unit -> Int64.int) option, ioDesc: OS.IO.iodesc option, name: string, readArr: (CharArraySlice.slice -> int) option, readArrNB: (CharArraySlice.slice -> int option) option, readVec: (int -> string) option, readVecNB: (int -> string option) option, setPos: (Int64.int -> unit) option, verifyPos: (unit -> Int64.int) option} -> TextPrimIO.reader (* @ $(SML_LIB)/basis/io/prim-io.fun 45.10-45.11 *)
con TextPrimIO.WR: {block: (unit -> unit) option, canOutput: (unit -> bool) option, chunkSize: int, close: unit -> unit, endPos: (unit -> Int64.int) option, getPos: (unit -> Int64.int) option, ioDesc: OS.IO.iodesc option, name: string, setPos: (Int64.int -> unit) option, verifyPos: (unit -> Int64.int) option, writeArr: (CharArraySlice.slice -> int) option, writeArrNB: (CharArraySlice.slice -> int option) option, writeVec: (char VectorSlice.slice -> int) option, writeVecNB: (char VectorSlice.slice -> int option) option} -> TextPrimIO.writer (* @ $(SML_LIB)/basis/io/prim-io.fun 62.10-62.11 *)
val TextPrimIO.augmentReader: TextPrimIO.reader -> TextPrimIO.reader (* @ $(SML_LIB)/basis/io/prim-io.fun 187.11-187.23 *)
val TextPrimIO.augmentWriter: TextPrimIO.writer -> TextPrimIO.writer (* @ $(SML_LIB)/basis/io/prim-io.fun 271.11-271.23 *)
val TextPrimIO.compare: Int64.int * Int64.int -> order (* @ $(SML_LIB)/basis/io/prim-io.fun 42.11-42.17 *)
val TextPrimIO.nullRd: unit -> TextPrimIO.reader (* @ $(SML_LIB)/basis/io/prim-io.fun 129.11-129.16 *)
val TextPrimIO.nullWr: unit -> TextPrimIO.writer (* @ $(SML_LIB)/basis/io/prim-io.fun 156.11-156.16 *)
val TextPrimIO.openVector: string -> TextPrimIO.reader (* @ $(SML_LIB)/basis/io/prim-io.fun 82.11-82.20 *)
structure Time: TIME where type time = Time.time (* @ $(SML_LIB)/basis/libs/basis-extra/top-level/basis.sml 43.17-43.20 *)
type Time.time = Time.time (* @ $(SML_LIB)/basis/system/time.sml 17.10-17.13 *)
val Time.+ : Time.time * Time.time -> Time.time (* @ $(SML_LIB)/basis/system/time.sml 173.8-173.8 *)
val Time.- : Time.time * Time.time -> Time.time (* @ $(SML_LIB)/basis/system/time.sml 174.8-174.8 *)
val Time.< : Time.time * Time.time -> bool (* @ $(SML_LIB)/basis/system/time.sml 53.11-53.11 *)
val Time.<= : Time.time * Time.time -> bool (* @ $(SML_LIB)/basis/system/time.sml 54.11-54.12 *)
val Time.> : Time.time * Time.time -> bool (* @ $(SML_LIB)/basis/system/time.sml 55.11-55.11 *)
val Time.>= : Time.time * Time.time -> bool (* @ $(SML_LIB)/basis/system/time.sml 56.11-56.12 *)
exn Time.Time: exn (* @ $(SML_LIB)/basis/system/time.sml 21.11-21.14 *)
val Time.compare: Time.time * Time.time -> order (* @ $(SML_LIB)/basis/system/time.sml 52.8-52.14 *)
val Time.fmt: int -> Time.time -> string (* @ $(SML_LIB)/basis/system/time.sml 94.5-94.7 *)
val Time.fromMicroseconds: LargeInt.int -> Time.time (* @ $(SML_LIB)/basis/system/time.sml 45.9-45.24 *)
val Time.fromMilliseconds: LargeInt.int -> Time.time (* @ $(SML_LIB)/basis/system/time.sml 44.9-44.24 *)
val Time.fromNanoseconds: LargeInt.int -> Time.time (* @ $(SML_LIB)/basis/system/time.sml 46.9-46.23 *)
val Time.fromReal: real -> Time.time (* @ $(SML_LIB)/basis/system/time.sml 25.5-25.12 *)
val Time.fromSeconds: LargeInt.int -> Time.time (* @ $(SML_LIB)/basis/system/time.sml 43.9-43.19 *)
val Time.fromString: string -> Time.time option (* @ $(SML_LIB)/basis/system/time.sml 171.5-171.14 *)
val Time.now: unit -> Time.time (* @ $(SML_LIB)/basis/system/time.sml 83.8-83.10 *)
val Time.scan: ('a -> (char * 'a) option) -> 'a -> (Time.time * 'a) option (* @ $(SML_LIB)/basis/system/time.sml 105.5-105.8 *)
val Time.toMicroseconds: Time.time -> LargeInt.int (* @ $(SML_LIB)/basis/system/time.sml 45.27-45.40 *)
val Time.toMilliseconds: Time.time -> LargeInt.int (* @ $(SML_LIB)/basis/system/time.sml 44.27-44.40 *)
val Time.toNanoseconds: Time.time -> LargeInt.int (* @ $(SML_LIB)/basis/system/time.sml 46.26-46.38 *)
val Time.toReal: Time.time -> real (* @ $(SML_LIB)/basis/system/time.sml 30.5-30.10 *)
val Time.toSeconds: Time.time -> LargeInt.int (* @ $(SML_LIB)/basis/system/time.sml 43.22-43.30 *)
val Time.toString: Time.time -> string (* @ $(SML_LIB)/basis/system/time.sml 97.5-97.12 *)
val Time.zeroTime: Time.time (* @ $(SML_LIB)/basis/system/time.sml 23.5-23.12 *)
structure Timer: TIMER where type cpu_timer = Timer.cpu_timer where type real_timer = Timer.real_timer (* @ $(SML_LIB)/basis/libs/basis-extra/top-level/basis.sml 44.17-44.21 *)
type Timer.cpu_timer = Timer.cpu_timer (* @ $(SML_LIB)/basis/system/timer.sml 22.12-22.20 *)
type Timer.real_timer = Timer.real_timer (* @ $(SML_LIB)/basis/system/timer.sml 61.12-61.21 *)
val Timer.checkCPUTimer: Timer.cpu_timer -> {sys: Time.time, usr: Time.time} (* @ $(SML_LIB)/basis/system/timer.sml 44.11-44.23 *)
val Timer.checkCPUTimes: Timer.cpu_timer -> {gc: {sys: Time.time, usr: Time.time}, nongc: {sys: Time.time, usr: Time.time}} (* @ $(SML_LIB)/basis/system/timer.sml 34.11-34.23 *)
val Timer.checkGCTime: Timer.cpu_timer -> Time.time (* @ $(SML_LIB)/basis/system/timer.sml 59.11-59.21 *)
val Timer.checkRealTimer: Timer.real_timer -> Time.time (* @ $(SML_LIB)/basis/system/timer.sml 65.11-65.24 *)
val Timer.startCPUTimer: unit -> Timer.cpu_timer (* @ $(SML_LIB)/basis/system/timer.sml 24.11-24.23 *)
val Timer.startRealTimer: unit -> Timer.real_timer (* @ $(SML_LIB)/basis/system/timer.sml 63.11-63.24 *)
val Timer.totalCPUTimer: unit -> Timer.cpu_timer (* @ $(SML_LIB)/basis/system/timer.sml 52.11-52.23 *)
val Timer.totalRealTimer: unit -> Timer.real_timer (* @ $(SML_LIB)/basis/system/timer.sml 68.11-68.24 *)
structure Unix: UNIX where type exit_status = Unix.exit_status where type ('a, 'b) proc = ('a, 'b) Unix.proc where type signal = Unix.signal (* @ $(SML_LIB)/basis/libs/basis-extra/top-level/basis.sml 181.17-181.20 *)
datatype Unix.exit_status = W_EXITED | W_EXITSTATUS of Word8.word | W_SIGNALED of Unix.signal | W_STOPPED of Unix.signal (* = datatype Unix.exit_status *) (* @ $(SML_LIB)/basis/system/unix.sml 25.10-25.20 *)
type ('a, 'b) Unix.proc = ('a, 'b) Unix.proc (* @ $(SML_LIB)/basis/system/unix.sml 29.18-29.21 *)
type Unix.signal = Unix.signal (* @ $(SML_LIB)/basis/system/unix.sml 24.6-24.11 *)
con Unix.W_EXITED: Unix.exit_status (* @ $(SML_LIB)/basis/posix/process.sml 74.10-74.17 *)
con Unix.W_EXITSTATUS: Word8.word -> Unix.exit_status (* @ $(SML_LIB)/basis/posix/process.sml 75.10-75.21 *)
con Unix.W_SIGNALED: Unix.signal -> Unix.exit_status (* @ $(SML_LIB)/basis/posix/process.sml 76.10-76.19 *)
con Unix.W_STOPPED: Unix.signal -> Unix.exit_status (* @ $(SML_LIB)/basis/posix/process.sml 77.10-77.18 *)
val Unix.binInstreamOf: (BinIO.instream, 'a) Unix.proc -> BinIO.instream (* @ $(SML_LIB)/basis/system/unix.sml 46.5-46.17 *)
val Unix.binOutstreamOf: ('a, BinIO.outstream) Unix.proc -> BinIO.outstream (* @ $(SML_LIB)/basis/system/unix.sml 47.5-47.18 *)
val Unix.execute: string * string list -> ('a, 'b) Unix.proc (* @ $(SML_LIB)/basis/system/unix.sml 40.8-40.14 *)
val Unix.executeInEnv: string * string list * string list -> ('a, 'b) Unix.proc (* @ $(SML_LIB)/basis/system/unix.sml 42.8-42.19 *)
val Unix.exit: Word8.word -> 'a (* @ $(SML_LIB)/basis/system/unix.sml 57.5-57.8 *)
val Unix.fromStatus: OS.Process.status -> Unix.exit_status (* @ $(SML_LIB)/basis/system/unix.sml 27.5-27.14 *)
val Unix.kill: ('a, 'b) Unix.proc * Unix.signal -> unit (* @ $(SML_LIB)/basis/system/unix.sml 53.5-53.8 *)
val Unix.reap: ('a, 'b) Unix.proc -> OS.Process.status (* @ $(SML_LIB)/basis/system/unix.sml 55.5-55.8 *)
val Unix.streamsOf: (TextIO.instream, TextIO.outstream) Unix.proc -> TextIO.instream * TextIO.outstream (* @ $(SML_LIB)/basis/system/unix.sml 51.5-51.13 *)
val Unix.textInstreamOf: (TextIO.instream, 'a) Unix.proc -> TextIO.instream (* @ $(SML_LIB)/basis/system/unix.sml 48.5-48.18 *)
val Unix.textOutstreamOf: ('a, TextIO.outstream) Unix.proc -> TextIO.outstream (* @ $(SML_LIB)/basis/system/unix.sml 49.5-49.19 *)
structure UnixSock: UNIX_SOCK where type unix = UnixSock.unix (* @ $(SML_LIB)/basis/libs/basis-extra/top-level/basis.sml 182.17-182.24 *)
type UnixSock.dgram_sock = (UnixSock.unix, Socket.dgram) Socket.sock (* @ $(SML_LIB)/basis/net/unix-sock.sml 15.12-15.21 *)
type 'a UnixSock.sock = (UnixSock.unix, 'a) Socket.sock (* @ $(SML_LIB)/basis/net/unix-sock.sml 13.23-13.26 *)
type UnixSock.sock_addr = UnixSock.unix Socket.sock_addr (* @ $(SML_LIB)/basis/net/unix-sock.sml 16.12-16.20 *)
type 'a UnixSock.stream_sock = (UnixSock.unix, 'a Socket.stream) Socket.sock (* @ $(SML_LIB)/basis/net/unix-sock.sml 14.18-14.28 *)
type UnixSock.unix = UnixSock.unix (* @ $(SML_LIB)/basis/net/unix-sock.sml 12.16-12.19 *)
val UnixSock.fromAddr: UnixSock.unix Socket.sock_addr -> string (* @ $(SML_LIB)/basis/net/unix-sock.sml 29.11-29.18 *)
val UnixSock.toAddr: string -> UnixSock.unix Socket.sock_addr (* @ $(SML_LIB)/basis/net/unix-sock.sml 19.11-19.16 *)
val UnixSock.unixAF: NetHostDB.addr_family (* @ $(SML_LIB)/basis/net/unix-sock.sml 17.11-17.16 *)
structure UnixSock.DGrm:
   sig
      val socket: unit -> (UnixSock.unix, Socket.dgram) Socket.sock
      val socketPair: unit -> (UnixSock.unix, Socket.dgram) Socket.sock * (UnixSock.unix, Socket.dgram) Socket.sock
   end
   (* @ $(SML_LIB)/basis/net/unix-sock.sml 44.17-44.20 *)
val UnixSock.DGrm.socket: unit -> (UnixSock.unix, Socket.dgram) Socket.sock (* @ $(SML_LIB)/basis/net/unix-sock.sml 46.17-46.22 *)
val UnixSock.DGrm.socketPair: unit -> (UnixSock.unix, Socket.dgram) Socket.sock * (UnixSock.unix, Socket.dgram) Socket.sock (* @ $(SML_LIB)/basis/net/unix-sock.sml 47.17-47.26 *)
structure UnixSock.Strm:
   sig
      val socket: unit -> (UnixSock.unix, 'a Socket.stream) Socket.sock
      val socketPair: unit -> (UnixSock.unix, 'a Socket.stream) Socket.sock * (UnixSock.unix, 'a Socket.stream) Socket.sock
   end
   (* @ $(SML_LIB)/basis/net/unix-sock.sml 39.17-39.20 *)
val UnixSock.Strm.socket: unit -> (UnixSock.unix, 'a Socket.stream) Socket.sock (* @ $(SML_LIB)/basis/net/unix-sock.sml 41.17-41.22 *)
val UnixSock.Strm.socketPair: unit -> (UnixSock.unix, 'a Socket.stream) Socket.sock * (UnixSock.unix, 'a Socket.stream) Socket.sock (* @ $(SML_LIB)/basis/net/unix-sock.sml 42.17-42.26 *)
structure Unsafe: UNSAFE where type 'a Array.Raw.rawarr = 'a Unsafe.Array.Raw.rawarr where type BoolArray.array = BoolArray.array where type BoolArray.elem = bool where type BoolVector.elem = bool where type BoolVector.vector = BoolVector.vector where type CharArray.array = CharArray.array where type CharArray.elem = char where type CharVector.elem = char where type CharVector.vector = string where type Int16Array.array = Int16Array.array where type Int16Array.elem = Int16.int where type Int16Vector.elem = Int16.int where type Int16Vector.vector = Int16Vector.vector where type Int32Array.array = Int32Array.array where type Int32Array.elem = int where type Int32Vector.elem = int where type Int32Vector.vector = Int32Vector.vector where type Int64Array.array = Int64Array.array where type Int64Array.elem = Int64.int where type Int64Vector.elem = Int64.int where type Int64Vector.vector = Int64Vector.vector where type Int8Array.array = Int8Array.array where type Int8Array.elem = Int8.int where type Int8Vector.elem = Int8.int where type Int8Vector.vector = Int8Vector.vector where type IntArray.array = IntArray.array where type IntArray.elem = int where type IntInfArray.array = Unsafe.IntInfArray.array where type IntInfArray.elem = Unsafe.IntInfArray.elem where type IntInfVector.elem = Unsafe.IntInfVector.elem where type IntInfVector.vector = Unsafe.IntInfVector.vector where type IntVector.elem = int where type IntVector.vector = IntVector.vector where type LargeIntArray.array = LargeIntArray.array where type LargeIntArray.elem = LargeInt.int where type LargeIntVector.elem = LargeInt.int where type LargeIntVector.vector = LargeIntVector.vector where type LargeRealArray.array = LargeRealArray.array where type LargeRealArray.elem = real where type LargeRealVector.elem = real where type LargeRealVector.vector = LargeRealVector.vector where type LargeWordArray.array = LargeWordArray.array where type LargeWordArray.elem = LargeWord.word where type LargeWordVector.elem = LargeWord.word where type LargeWordVector.vector = LargeWordVector.vector where type PackReal32Big.real = Real32.real where type PackReal32Little.real = Real32.real where type PackReal64Big.real = real where type PackReal64Little.real = real where type PackRealBig.real = real where type PackRealLittle.real = real where type Real32Array.array = Real32Array.array where type Real32Array.elem = Real32.real where type Real32Vector.elem = Real32.real where type Real32Vector.vector = Real32Vector.vector where type Real64Array.array = Real64Array.array where type Real64Array.elem = real where type Real64Vector.elem = real where type Real64Vector.vector = Real64Vector.vector where type RealArray.array = RealArray.array where type RealArray.elem = real where type RealVector.elem = real where type RealVector.vector = RealVector.vector where type Word16Array.array = Word16Array.array where type Word16Array.elem = Word16.word where type Word16Vector.elem = Word16.word where type Word16Vector.vector = Word16Vector.vector where type Word32Array.array = Word32Array.array where type Word32Array.elem = word where type Word32Vector.elem = word where type Word32Vector.vector = Word32Vector.vector where type Word64Array.array = Word64Array.array where type Word64Array.elem = LargeWord.word where type Word64Vector.elem = LargeWord.word where type Word64Vector.vector = Word64Vector.vector where type Word8Array.array = Word8Array.array where type Word8Array.elem = Word8.word where type Word8Vector.elem = Word8.word where type Word8Vector.vector = Word8Vector.vector where type WordArray.array = WordArray.array where type WordArray.elem = word where type WordVector.elem = word where type WordVector.vector = WordVector.vector (* @ $(SML_LIB)/basis/unsafe.mlb 19.17-19.22 *)
structure Unsafe.Array:
   sig
      val alloc: int -> 'a array
      val create: int * 'a -> 'a array
      val sub: 'a array * int -> 'a
      val uninit: 'a array * int -> unit
      val uninitIsNop: 'a array -> bool
      val update: 'a array * int * 'a -> unit
      structure Raw:
         sig
            type 'a rawarr = 'a Unsafe.Array.Raw.rawarr
            val alloc: int -> 'a Unsafe.Array.Raw.rawarr
            val toArray: 'a Unsafe.Array.Raw.rawarr -> 'a array
            val uninit: 'a Unsafe.Array.Raw.rawarr * int -> unit
            val uninitIsNop: 'a Unsafe.Array.Raw.rawarr -> bool
         end
   end
   (* @ $(SML_LIB)/basis/sml-nj/unsafe.sml 47.17-47.21 *)
val Unsafe.Array.alloc: int -> 'a array (* @ $(SML_LIB)/basis/sml-nj/unsafe.sml 49.17-49.21 *)
val Unsafe.Array.create: int * 'a -> 'a array (* @ $(SML_LIB)/basis/sml-nj/unsafe.sml 54.17-54.22 *)
val Unsafe.Array.sub: 'a array * int -> 'a (* @ $(SML_LIB)/basis/sml-nj/unsafe.sml 50.17-50.19 *)
val Unsafe.Array.uninit: 'a array * int -> unit (* @ $(SML_LIB)/basis/sml-nj/unsafe.sml 52.17-52.22 *)
val Unsafe.Array.uninitIsNop: 'a array -> bool (* @ $(SML_LIB)/basis/sml-nj/unsafe.sml 51.17-51.27 *)
val Unsafe.Array.update: 'a array * int * 'a -> unit (* @ $(SML_LIB)/basis/sml-nj/unsafe.sml 53.17-53.22 *)
structure Unsafe.Array.Raw:
   sig
      type 'a rawarr = 'a Unsafe.Array.Raw.rawarr
      val alloc: int -> 'a Unsafe.Array.Raw.rawarr
      val toArray: 'a Unsafe.Array.Raw.rawarr -> 'a array
      val uninit: 'a Unsafe.Array.Raw.rawarr * int -> unit
      val uninitIsNop: 'a Unsafe.Array.Raw.rawarr -> bool
   end
   (* @ $(SML_LIB)/basis/sml-nj/unsafe.sml 56.23-56.25 *)
type 'a Unsafe.Array.Raw.rawarr = 'a Unsafe.Array.Raw.rawarr (* @ $(SML_LIB)/basis/sml-nj/unsafe.sml 58.27-58.32 *)
val Unsafe.Array.Raw.alloc: int -> 'a Unsafe.Array.Raw.rawarr (* @ $(SML_LIB)/basis/sml-nj/unsafe.sml 59.23-59.27 *)
val Unsafe.Array.Raw.toArray: 'a Unsafe.Array.Raw.rawarr -> 'a array (* @ $(SML_LIB)/basis/sml-nj/unsafe.sml 60.23-60.29 *)
val Unsafe.Array.Raw.uninit: 'a Unsafe.Array.Raw.rawarr * int -> unit (* @ $(SML_LIB)/basis/sml-nj/unsafe.sml 62.23-62.28 *)
val Unsafe.Array.Raw.uninitIsNop: 'a Unsafe.Array.Raw.rawarr -> bool (* @ $(SML_LIB)/basis/sml-nj/unsafe.sml 61.23-61.33 *)
structure Unsafe.BoolArray:
   sig
      type array = BoolArray.array
      type elem = bool
      val create: int -> BoolArray.array
      val sub: BoolArray.array * int -> bool
      val update: BoolArray.array * int * bool -> unit
   end
   (* @ $(SML_LIB)/basis/sml-nj/unsafe.sml 65.17-65.25 *)
type Unsafe.BoolArray.array = BoolArray.array (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array.fun 23.12-23.16 *)
type Unsafe.BoolArray.elem = bool (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array.fun 22.12-22.15 *)
val Unsafe.BoolArray.create: int -> BoolArray.array (* @ $(SML_LIB)/basis/sml-nj/unsafe.sml 16.11-16.16 *)
val Unsafe.BoolArray.sub: BoolArray.array * int -> bool (* @ $(SML_LIB)/basis/sml-nj/unsafe.sml 14.11-14.13 *)
val Unsafe.BoolArray.update: BoolArray.array * int * bool -> unit (* @ $(SML_LIB)/basis/sml-nj/unsafe.sml 15.11-15.16 *)
structure Unsafe.BoolVector:
   sig
      type elem = bool
      type vector = BoolVector.vector
      val sub: BoolVector.vector * int -> bool
   end
   (* @ $(SML_LIB)/basis/sml-nj/unsafe.sml 66.17-66.26 *)
type Unsafe.BoolVector.elem = bool (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-vector.fun 35.12-35.15 *)
type Unsafe.BoolVector.vector = BoolVector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-vector.fun 36.12-36.17 *)
val Unsafe.BoolVector.sub: BoolVector.vector * int -> bool (* @ $(SML_LIB)/basis/sml-nj/unsafe.sml 23.11-23.13 *)
structure Unsafe.CharArray:
   sig
      type array = CharArray.array
      type elem = char
      val create: int -> CharArray.array
      val sub: CharArray.array * int -> char
      val update: CharArray.array * int * char -> unit
   end
   (* @ $(SML_LIB)/basis/sml-nj/unsafe.sml 67.17-67.25 *)
type Unsafe.CharArray.array = CharArray.array (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array.fun 23.12-23.16 *)
type Unsafe.CharArray.elem = char (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array.fun 22.12-22.15 *)
val Unsafe.CharArray.create: int -> CharArray.array (* @ $(SML_LIB)/basis/sml-nj/unsafe.sml 16.11-16.16 *)
val Unsafe.CharArray.sub: CharArray.array * int -> char (* @ $(SML_LIB)/basis/sml-nj/unsafe.sml 14.11-14.13 *)
val Unsafe.CharArray.update: CharArray.array * int * char -> unit (* @ $(SML_LIB)/basis/sml-nj/unsafe.sml 15.11-15.16 *)
structure Unsafe.CharVector:
   sig
      type elem = char
      type vector = string
      val sub: string * int -> char
   end
   (* @ $(SML_LIB)/basis/sml-nj/unsafe.sml 68.17-68.26 *)
type Unsafe.CharVector.elem = char (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-vector.fun 35.12-35.15 *)
type Unsafe.CharVector.vector = string (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-vector.fun 36.12-36.17 *)
val Unsafe.CharVector.sub: string * int -> char (* @ $(SML_LIB)/basis/sml-nj/unsafe.sml 23.11-23.13 *)
structure Unsafe.Int16Array:
   sig
      type array = Int16Array.array
      type elem = Int16.int
      val create: int -> Int16Array.array
      val sub: Int16Array.array * int -> Int16.int
      val update: Int16Array.array * int * Int16.int -> unit
   end
   (* @ $(SML_LIB)/basis/sml-nj/unsafe.sml 73.17-73.26 *)
type Unsafe.Int16Array.array = Int16Array.array (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array.fun 23.12-23.16 *)
type Unsafe.Int16Array.elem = Int16.int (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array.fun 22.12-22.15 *)
val Unsafe.Int16Array.create: int -> Int16Array.array (* @ $(SML_LIB)/basis/sml-nj/unsafe.sml 16.11-16.16 *)
val Unsafe.Int16Array.sub: Int16Array.array * int -> Int16.int (* @ $(SML_LIB)/basis/sml-nj/unsafe.sml 14.11-14.13 *)
val Unsafe.Int16Array.update: Int16Array.array * int * Int16.int -> unit (* @ $(SML_LIB)/basis/sml-nj/unsafe.sml 15.11-15.16 *)
structure Unsafe.Int16Vector:
   sig
      type elem = Int16.int
      type vector = Int16Vector.vector
      val sub: Int16Vector.vector * int -> Int16.int
   end
   (* @ $(SML_LIB)/basis/sml-nj/unsafe.sml 74.17-74.27 *)
type Unsafe.Int16Vector.elem = Int16.int (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-vector.fun 35.12-35.15 *)
type Unsafe.Int16Vector.vector = Int16Vector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-vector.fun 36.12-36.17 *)
val Unsafe.Int16Vector.sub: Int16Vector.vector * int -> Int16.int (* @ $(SML_LIB)/basis/sml-nj/unsafe.sml 23.11-23.13 *)
structure Unsafe.Int32Array:
   sig
      type array = Int32Array.array
      type elem = int
      val create: int -> Int32Array.array
      val sub: Int32Array.array * int -> int
      val update: Int32Array.array * int * int -> unit
   end
   (* @ $(SML_LIB)/basis/sml-nj/unsafe.sml 75.17-75.26 *)
type Unsafe.Int32Array.array = Int32Array.array (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array.fun 23.12-23.16 *)
type Unsafe.Int32Array.elem = int (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array.fun 22.12-22.15 *)
val Unsafe.Int32Array.create: int -> Int32Array.array (* @ $(SML_LIB)/basis/sml-nj/unsafe.sml 16.11-16.16 *)
val Unsafe.Int32Array.sub: Int32Array.array * int -> int (* @ $(SML_LIB)/basis/sml-nj/unsafe.sml 14.11-14.13 *)
val Unsafe.Int32Array.update: Int32Array.array * int * int -> unit (* @ $(SML_LIB)/basis/sml-nj/unsafe.sml 15.11-15.16 *)
structure Unsafe.Int32Vector:
   sig
      type elem = int
      type vector = Int32Vector.vector
      val sub: Int32Vector.vector * int -> int
   end
   (* @ $(SML_LIB)/basis/sml-nj/unsafe.sml 76.17-76.27 *)
type Unsafe.Int32Vector.elem = int (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-vector.fun 35.12-35.15 *)
type Unsafe.Int32Vector.vector = Int32Vector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-vector.fun 36.12-36.17 *)
val Unsafe.Int32Vector.sub: Int32Vector.vector * int -> int (* @ $(SML_LIB)/basis/sml-nj/unsafe.sml 23.11-23.13 *)
structure Unsafe.Int64Array:
   sig
      type array = Int64Array.array
      type elem = Int64.int
      val create: int -> Int64Array.array
      val sub: Int64Array.array * int -> Int64.int
      val update: Int64Array.array * int * Int64.int -> unit
   end
   (* @ $(SML_LIB)/basis/sml-nj/unsafe.sml 77.17-77.26 *)
type Unsafe.Int64Array.array = Int64Array.array (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array.fun 23.12-23.16 *)
type Unsafe.Int64Array.elem = Int64.int (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array.fun 22.12-22.15 *)
val Unsafe.Int64Array.create: int -> Int64Array.array (* @ $(SML_LIB)/basis/sml-nj/unsafe.sml 16.11-16.16 *)
val Unsafe.Int64Array.sub: Int64Array.array * int -> Int64.int (* @ $(SML_LIB)/basis/sml-nj/unsafe.sml 14.11-14.13 *)
val Unsafe.Int64Array.update: Int64Array.array * int * Int64.int -> unit (* @ $(SML_LIB)/basis/sml-nj/unsafe.sml 15.11-15.16 *)
structure Unsafe.Int64Vector:
   sig
      type elem = Int64.int
      type vector = Int64Vector.vector
      val sub: Int64Vector.vector * int -> Int64.int
   end
   (* @ $(SML_LIB)/basis/sml-nj/unsafe.sml 78.17-78.27 *)
type Unsafe.Int64Vector.elem = Int64.int (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-vector.fun 35.12-35.15 *)
type Unsafe.Int64Vector.vector = Int64Vector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-vector.fun 36.12-36.17 *)
val Unsafe.Int64Vector.sub: Int64Vector.vector * int -> Int64.int (* @ $(SML_LIB)/basis/sml-nj/unsafe.sml 23.11-23.13 *)
structure Unsafe.Int8Array:
   sig
      type array = Int8Array.array
      type elem = Int8.int
      val create: int -> Int8Array.array
      val sub: Int8Array.array * int -> Int8.int
      val update: Int8Array.array * int * Int8.int -> unit
   end
   (* @ $(SML_LIB)/basis/sml-nj/unsafe.sml 71.17-71.25 *)
type Unsafe.Int8Array.array = Int8Array.array (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array.fun 23.12-23.16 *)
type Unsafe.Int8Array.elem = Int8.int (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array.fun 22.12-22.15 *)
val Unsafe.Int8Array.create: int -> Int8Array.array (* @ $(SML_LIB)/basis/sml-nj/unsafe.sml 16.11-16.16 *)
val Unsafe.Int8Array.sub: Int8Array.array * int -> Int8.int (* @ $(SML_LIB)/basis/sml-nj/unsafe.sml 14.11-14.13 *)
val Unsafe.Int8Array.update: Int8Array.array * int * Int8.int -> unit (* @ $(SML_LIB)/basis/sml-nj/unsafe.sml 15.11-15.16 *)
structure Unsafe.Int8Vector:
   sig
      type elem = Int8.int
      type vector = Int8Vector.vector
      val sub: Int8Vector.vector * int -> Int8.int
   end
   (* @ $(SML_LIB)/basis/sml-nj/unsafe.sml 72.17-72.26 *)
type Unsafe.Int8Vector.elem = Int8.int (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-vector.fun 35.12-35.15 *)
type Unsafe.Int8Vector.vector = Int8Vector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-vector.fun 36.12-36.17 *)
val Unsafe.Int8Vector.sub: Int8Vector.vector * int -> Int8.int (* @ $(SML_LIB)/basis/sml-nj/unsafe.sml 23.11-23.13 *)
structure Unsafe.IntArray:
   sig
      type array = IntArray.array
      type elem = int
      val create: int -> IntArray.array
      val sub: IntArray.array * int -> int
      val update: IntArray.array * int * int -> unit
   end
   (* @ $(SML_LIB)/basis/sml-nj/unsafe.sml 69.17-69.24 *)
type Unsafe.IntArray.array = IntArray.array (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array.fun 23.12-23.16 *)
type Unsafe.IntArray.elem = int (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array.fun 22.12-22.15 *)
val Unsafe.IntArray.create: int -> IntArray.array (* @ $(SML_LIB)/basis/sml-nj/unsafe.sml 16.11-16.16 *)
val Unsafe.IntArray.sub: IntArray.array * int -> int (* @ $(SML_LIB)/basis/sml-nj/unsafe.sml 14.11-14.13 *)
val Unsafe.IntArray.update: IntArray.array * int * int -> unit (* @ $(SML_LIB)/basis/sml-nj/unsafe.sml 15.11-15.16 *)
structure Unsafe.IntInfArray:
   sig
      type array = Unsafe.IntInfArray.array
      type elem = Unsafe.IntInfArray.elem
      val create: int -> Unsafe.IntInfArray.array
      val sub: Unsafe.IntInfArray.array * int -> Unsafe.IntInfArray.elem
      val update: Unsafe.IntInfArray.array * int * Unsafe.IntInfArray.elem -> unit
   end
   (* @ $(SML_LIB)/basis/sml-nj/unsafe.sml 79.17-79.27 *)
type Unsafe.IntInfArray.array = Unsafe.IntInfArray.array (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array.fun 23.12-23.16 *)
type Unsafe.IntInfArray.elem = Unsafe.IntInfArray.elem (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array.fun 22.12-22.15 *)
val Unsafe.IntInfArray.create: int -> Unsafe.IntInfArray.array (* @ $(SML_LIB)/basis/sml-nj/unsafe.sml 16.11-16.16 *)
val Unsafe.IntInfArray.sub: Unsafe.IntInfArray.array * int -> Unsafe.IntInfArray.elem (* @ $(SML_LIB)/basis/sml-nj/unsafe.sml 14.11-14.13 *)
val Unsafe.IntInfArray.update: Unsafe.IntInfArray.array * int * Unsafe.IntInfArray.elem -> unit (* @ $(SML_LIB)/basis/sml-nj/unsafe.sml 15.11-15.16 *)
structure Unsafe.IntInfVector:
   sig
      type elem = Unsafe.IntInfVector.elem
      type vector = Unsafe.IntInfVector.vector
      val sub: Unsafe.IntInfVector.vector * int -> Unsafe.IntInfVector.elem
   end
   (* @ $(SML_LIB)/basis/sml-nj/unsafe.sml 80.17-80.28 *)
type Unsafe.IntInfVector.elem = Unsafe.IntInfVector.elem (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-vector.fun 35.12-35.15 *)
type Unsafe.IntInfVector.vector = Unsafe.IntInfVector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-vector.fun 36.12-36.17 *)
val Unsafe.IntInfVector.sub: Unsafe.IntInfVector.vector * int -> Unsafe.IntInfVector.elem (* @ $(SML_LIB)/basis/sml-nj/unsafe.sml 23.11-23.13 *)
structure Unsafe.IntVector:
   sig
      type elem = int
      type vector = IntVector.vector
      val sub: IntVector.vector * int -> int
   end
   (* @ $(SML_LIB)/basis/sml-nj/unsafe.sml 70.17-70.25 *)
type Unsafe.IntVector.elem = int (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-vector.fun 35.12-35.15 *)
type Unsafe.IntVector.vector = IntVector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-vector.fun 36.12-36.17 *)
val Unsafe.IntVector.sub: IntVector.vector * int -> int (* @ $(SML_LIB)/basis/sml-nj/unsafe.sml 23.11-23.13 *)
structure Unsafe.LargeIntArray:
   sig
      type array = LargeIntArray.array
      type elem = LargeInt.int
      val create: int -> LargeIntArray.array
      val sub: LargeIntArray.array * int -> LargeInt.int
      val update: LargeIntArray.array * int * LargeInt.int -> unit
   end
   (* @ $(SML_LIB)/basis/sml-nj/unsafe.sml 81.17-81.29 *)
type Unsafe.LargeIntArray.array = LargeIntArray.array (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array.fun 23.12-23.16 *)
type Unsafe.LargeIntArray.elem = LargeInt.int (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array.fun 22.12-22.15 *)
val Unsafe.LargeIntArray.create: int -> LargeIntArray.array (* @ $(SML_LIB)/basis/sml-nj/unsafe.sml 16.11-16.16 *)
val Unsafe.LargeIntArray.sub: LargeIntArray.array * int -> LargeInt.int (* @ $(SML_LIB)/basis/sml-nj/unsafe.sml 14.11-14.13 *)
val Unsafe.LargeIntArray.update: LargeIntArray.array * int * LargeInt.int -> unit (* @ $(SML_LIB)/basis/sml-nj/unsafe.sml 15.11-15.16 *)
structure Unsafe.LargeIntVector:
   sig
      type elem = LargeInt.int
      type vector = LargeIntVector.vector
      val sub: LargeIntVector.vector * int -> LargeInt.int
   end
   (* @ $(SML_LIB)/basis/sml-nj/unsafe.sml 82.17-82.30 *)
type Unsafe.LargeIntVector.elem = LargeInt.int (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-vector.fun 35.12-35.15 *)
type Unsafe.LargeIntVector.vector = LargeIntVector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-vector.fun 36.12-36.17 *)
val Unsafe.LargeIntVector.sub: LargeIntVector.vector * int -> LargeInt.int (* @ $(SML_LIB)/basis/sml-nj/unsafe.sml 23.11-23.13 *)
structure Unsafe.LargeRealArray:
   sig
      type array = LargeRealArray.array
      type elem = real
      val create: int -> LargeRealArray.array
      val sub: LargeRealArray.array * int -> real
      val update: LargeRealArray.array * int * real -> unit
   end
   (* @ $(SML_LIB)/basis/sml-nj/unsafe.sml 83.17-83.30 *)
type Unsafe.LargeRealArray.array = LargeRealArray.array (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array.fun 23.12-23.16 *)
type Unsafe.LargeRealArray.elem = real (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array.fun 22.12-22.15 *)
val Unsafe.LargeRealArray.create: int -> LargeRealArray.array (* @ $(SML_LIB)/basis/sml-nj/unsafe.sml 16.11-16.16 *)
val Unsafe.LargeRealArray.sub: LargeRealArray.array * int -> real (* @ $(SML_LIB)/basis/sml-nj/unsafe.sml 14.11-14.13 *)
val Unsafe.LargeRealArray.update: LargeRealArray.array * int * real -> unit (* @ $(SML_LIB)/basis/sml-nj/unsafe.sml 15.11-15.16 *)
structure Unsafe.LargeRealVector:
   sig
      type elem = real
      type vector = LargeRealVector.vector
      val sub: LargeRealVector.vector * int -> real
   end
   (* @ $(SML_LIB)/basis/sml-nj/unsafe.sml 84.17-84.31 *)
type Unsafe.LargeRealVector.elem = real (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-vector.fun 15.12-15.15 *)
type Unsafe.LargeRealVector.vector = LargeRealVector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-vector.fun 16.12-16.17 *)
val Unsafe.LargeRealVector.sub: LargeRealVector.vector * int -> real (* @ $(SML_LIB)/basis/sml-nj/unsafe.sml 23.11-23.13 *)
structure Unsafe.LargeWordArray:
   sig
      type array = LargeWordArray.array
      type elem = LargeWord.word
      val create: int -> LargeWordArray.array
      val sub: LargeWordArray.array * int -> LargeWord.word
      val update: LargeWordArray.array * int * LargeWord.word -> unit
   end
   (* @ $(SML_LIB)/basis/sml-nj/unsafe.sml 85.17-85.30 *)
type Unsafe.LargeWordArray.array = LargeWordArray.array (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array.fun 23.12-23.16 *)
type Unsafe.LargeWordArray.elem = LargeWord.word (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array.fun 22.12-22.15 *)
val Unsafe.LargeWordArray.create: int -> LargeWordArray.array (* @ $(SML_LIB)/basis/sml-nj/unsafe.sml 16.11-16.16 *)
val Unsafe.LargeWordArray.sub: LargeWordArray.array * int -> LargeWord.word (* @ $(SML_LIB)/basis/sml-nj/unsafe.sml 14.11-14.13 *)
val Unsafe.LargeWordArray.update: LargeWordArray.array * int * LargeWord.word -> unit (* @ $(SML_LIB)/basis/sml-nj/unsafe.sml 15.11-15.16 *)
structure Unsafe.LargeWordVector:
   sig
      type elem = LargeWord.word
      type vector = LargeWordVector.vector
      val sub: LargeWordVector.vector * int -> LargeWord.word
   end
   (* @ $(SML_LIB)/basis/sml-nj/unsafe.sml 86.17-86.31 *)
type Unsafe.LargeWordVector.elem = LargeWord.word (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-vector.fun 35.12-35.15 *)
type Unsafe.LargeWordVector.vector = LargeWordVector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-vector.fun 36.12-36.17 *)
val Unsafe.LargeWordVector.sub: LargeWordVector.vector * int -> LargeWord.word (* @ $(SML_LIB)/basis/sml-nj/unsafe.sml 23.11-23.13 *)
structure Unsafe.PackReal32Big: PACK_REAL where type real = Real32.real (* @ $(SML_LIB)/basis/sml-nj/unsafe.sml 107.17-107.29 *)
type Unsafe.PackReal32Big.real = Real32.real (* @ $(SML_LIB)/basis/primitive/prim-pack-real.sml 17.12-17.15 *)
val Unsafe.PackReal32Big.bytesPerElem: int (* @ $(SML_LIB)/basis/real/pack-real.sml 192.5-192.16 *)
val Unsafe.PackReal32Big.fromBytes: Word8Vector.vector -> Real32.real (* @ $(SML_LIB)/basis/real/pack-real.sml 261.5-261.13 *)
val Unsafe.PackReal32Big.isBigEndian: bool (* @ $(SML_LIB)/basis/real/pack-real.sml 268.18-268.28 *)
val Unsafe.PackReal32Big.subArr: Word8Array.array * int -> Real32.real (* @ $(SML_LIB)/basis/sml-nj/unsafe.sml 40.11-40.16 *)
val Unsafe.PackReal32Big.subVec: Word8Vector.vector * int -> Real32.real (* @ $(SML_LIB)/basis/sml-nj/unsafe.sml 39.11-39.16 *)
val Unsafe.PackReal32Big.toBytes: Real32.real -> Word8Vector.vector (* @ $(SML_LIB)/basis/real/pack-real.sml 253.5-253.11 *)
val Unsafe.PackReal32Big.update: Word8Array.array * int * Real32.real -> unit (* @ $(SML_LIB)/basis/sml-nj/unsafe.sml 41.11-41.16 *)
structure Unsafe.PackReal32Little: PACK_REAL where type real = Real32.real (* @ $(SML_LIB)/basis/sml-nj/unsafe.sml 108.17-108.32 *)
type Unsafe.PackReal32Little.real = Real32.real (* @ $(SML_LIB)/basis/primitive/prim-pack-real.sml 17.12-17.15 *)
val Unsafe.PackReal32Little.bytesPerElem: int (* @ $(SML_LIB)/basis/real/pack-real.sml 192.5-192.16 *)
val Unsafe.PackReal32Little.fromBytes: Word8Vector.vector -> Real32.real (* @ $(SML_LIB)/basis/real/pack-real.sml 261.5-261.13 *)
val Unsafe.PackReal32Little.isBigEndian: bool (* @ $(SML_LIB)/basis/real/pack-real.sml 272.18-272.28 *)
val Unsafe.PackReal32Little.subArr: Word8Array.array * int -> Real32.real (* @ $(SML_LIB)/basis/sml-nj/unsafe.sml 40.11-40.16 *)
val Unsafe.PackReal32Little.subVec: Word8Vector.vector * int -> Real32.real (* @ $(SML_LIB)/basis/sml-nj/unsafe.sml 39.11-39.16 *)
val Unsafe.PackReal32Little.toBytes: Real32.real -> Word8Vector.vector (* @ $(SML_LIB)/basis/real/pack-real.sml 253.5-253.11 *)
val Unsafe.PackReal32Little.update: Word8Array.array * int * Real32.real -> unit (* @ $(SML_LIB)/basis/sml-nj/unsafe.sml 41.11-41.16 *)
structure Unsafe.PackReal64Big: PACK_REAL where type real = real (* @ $(SML_LIB)/basis/sml-nj/unsafe.sml 109.17-109.29 *)
type Unsafe.PackReal64Big.real = real (* @ $(SML_LIB)/basis/primitive/prim-pack-real.sml 26.12-26.15 *)
val Unsafe.PackReal64Big.bytesPerElem: int (* @ $(SML_LIB)/basis/real/pack-real.sml 192.5-192.16 *)
val Unsafe.PackReal64Big.fromBytes: Word8Vector.vector -> real (* @ $(SML_LIB)/basis/real/pack-real.sml 261.5-261.13 *)
val Unsafe.PackReal64Big.isBigEndian: bool (* @ $(SML_LIB)/basis/real/pack-real.sml 280.18-280.28 *)
val Unsafe.PackReal64Big.subArr: Word8Array.array * int -> real (* @ $(SML_LIB)/basis/sml-nj/unsafe.sml 40.11-40.16 *)
val Unsafe.PackReal64Big.subVec: Word8Vector.vector * int -> real (* @ $(SML_LIB)/basis/sml-nj/unsafe.sml 39.11-39.16 *)
val Unsafe.PackReal64Big.toBytes: real -> Word8Vector.vector (* @ $(SML_LIB)/basis/real/pack-real.sml 253.5-253.11 *)
val Unsafe.PackReal64Big.update: Word8Array.array * int * real -> unit (* @ $(SML_LIB)/basis/sml-nj/unsafe.sml 41.11-41.16 *)
structure Unsafe.PackReal64Little: PACK_REAL where type real = real (* @ $(SML_LIB)/basis/sml-nj/unsafe.sml 110.17-110.32 *)
type Unsafe.PackReal64Little.real = real (* @ $(SML_LIB)/basis/primitive/prim-pack-real.sml 26.12-26.15 *)
val Unsafe.PackReal64Little.bytesPerElem: int (* @ $(SML_LIB)/basis/real/pack-real.sml 192.5-192.16 *)
val Unsafe.PackReal64Little.fromBytes: Word8Vector.vector -> real (* @ $(SML_LIB)/basis/real/pack-real.sml 261.5-261.13 *)
val Unsafe.PackReal64Little.isBigEndian: bool (* @ $(SML_LIB)/basis/real/pack-real.sml 284.18-284.28 *)
val Unsafe.PackReal64Little.subArr: Word8Array.array * int -> real (* @ $(SML_LIB)/basis/sml-nj/unsafe.sml 40.11-40.16 *)
val Unsafe.PackReal64Little.subVec: Word8Vector.vector * int -> real (* @ $(SML_LIB)/basis/sml-nj/unsafe.sml 39.11-39.16 *)
val Unsafe.PackReal64Little.toBytes: real -> Word8Vector.vector (* @ $(SML_LIB)/basis/real/pack-real.sml 253.5-253.11 *)
val Unsafe.PackReal64Little.update: Word8Array.array * int * real -> unit (* @ $(SML_LIB)/basis/sml-nj/unsafe.sml 41.11-41.16 *)
structure Unsafe.PackRealBig: PACK_REAL where type real = real (* @ $(SML_LIB)/basis/sml-nj/unsafe.sml 111.17-111.27 *)
type Unsafe.PackRealBig.real = real (* @ $(SML_LIB)/basis/real/pack-real.sml 44.12-44.15 *)
val Unsafe.PackRealBig.bytesPerElem: int (* @ $(SML_LIB)/basis/real/pack-real.sml 192.5-192.16 *)
val Unsafe.PackRealBig.fromBytes: Word8Vector.vector -> real (* @ $(SML_LIB)/basis/real/pack-real.sml 261.5-261.13 *)
val Unsafe.PackRealBig.isBigEndian: bool (* @ $(SML_LIB)/basis/real/pack-real.sml 292.18-292.28 *)
val Unsafe.PackRealBig.subArr: Word8Array.array * int -> real (* @ $(SML_LIB)/basis/sml-nj/unsafe.sml 40.11-40.16 *)
val Unsafe.PackRealBig.subVec: Word8Vector.vector * int -> real (* @ $(SML_LIB)/basis/sml-nj/unsafe.sml 39.11-39.16 *)
val Unsafe.PackRealBig.toBytes: real -> Word8Vector.vector (* @ $(SML_LIB)/basis/real/pack-real.sml 253.5-253.11 *)
val Unsafe.PackRealBig.update: Word8Array.array * int * real -> unit (* @ $(SML_LIB)/basis/sml-nj/unsafe.sml 41.11-41.16 *)
structure Unsafe.PackRealLittle: PACK_REAL where type real = real (* @ $(SML_LIB)/basis/sml-nj/unsafe.sml 112.17-112.30 *)
type Unsafe.PackRealLittle.real = real (* @ $(SML_LIB)/basis/real/pack-real.sml 44.12-44.15 *)
val Unsafe.PackRealLittle.bytesPerElem: int (* @ $(SML_LIB)/basis/real/pack-real.sml 192.5-192.16 *)
val Unsafe.PackRealLittle.fromBytes: Word8Vector.vector -> real (* @ $(SML_LIB)/basis/real/pack-real.sml 261.5-261.13 *)
val Unsafe.PackRealLittle.isBigEndian: bool (* @ $(SML_LIB)/basis/real/pack-real.sml 296.18-296.28 *)
val Unsafe.PackRealLittle.subArr: Word8Array.array * int -> real (* @ $(SML_LIB)/basis/sml-nj/unsafe.sml 40.11-40.16 *)
val Unsafe.PackRealLittle.subVec: Word8Vector.vector * int -> real (* @ $(SML_LIB)/basis/sml-nj/unsafe.sml 39.11-39.16 *)
val Unsafe.PackRealLittle.toBytes: real -> Word8Vector.vector (* @ $(SML_LIB)/basis/real/pack-real.sml 253.5-253.11 *)
val Unsafe.PackRealLittle.update: Word8Array.array * int * real -> unit (* @ $(SML_LIB)/basis/sml-nj/unsafe.sml 41.11-41.16 *)
structure Unsafe.PackWord16Big: PACK_WORD (* @ $(SML_LIB)/basis/sml-nj/unsafe.sml 113.17-113.29 *)
val Unsafe.PackWord16Big.bytesPerElem: int (* @ $(SML_LIB)/basis/integer/pack-word.sml 25.5-25.16 *)
val Unsafe.PackWord16Big.isBigEndian: bool (* @ $(SML_LIB)/basis/integer/pack-word.sml 108.18-108.28 *)
val Unsafe.PackWord16Big.subArr: Word8Array.array * int -> LargeWord.word (* @ $(SML_LIB)/basis/sml-nj/unsafe.sml 31.11-31.16 *)
val Unsafe.PackWord16Big.subArrX: Word8Array.array * int -> LargeWord.word (* @ $(SML_LIB)/basis/sml-nj/unsafe.sml 32.11-32.17 *)
val Unsafe.PackWord16Big.subVec: Word8Vector.vector * int -> LargeWord.word (* @ $(SML_LIB)/basis/sml-nj/unsafe.sml 29.11-29.16 *)
val Unsafe.PackWord16Big.subVecX: Word8Vector.vector * int -> LargeWord.word (* @ $(SML_LIB)/basis/sml-nj/unsafe.sml 30.11-30.17 *)
val Unsafe.PackWord16Big.update: Word8Array.array * int * LargeWord.word -> unit (* @ $(SML_LIB)/basis/sml-nj/unsafe.sml 33.11-33.16 *)
structure Unsafe.PackWord16Little: PACK_WORD (* @ $(SML_LIB)/basis/sml-nj/unsafe.sml 114.17-114.32 *)
val Unsafe.PackWord16Little.bytesPerElem: int (* @ $(SML_LIB)/basis/integer/pack-word.sml 25.5-25.16 *)
val Unsafe.PackWord16Little.isBigEndian: bool (* @ $(SML_LIB)/basis/integer/pack-word.sml 112.18-112.28 *)
val Unsafe.PackWord16Little.subArr: Word8Array.array * int -> LargeWord.word (* @ $(SML_LIB)/basis/sml-nj/unsafe.sml 31.11-31.16 *)
val Unsafe.PackWord16Little.subArrX: Word8Array.array * int -> LargeWord.word (* @ $(SML_LIB)/basis/sml-nj/unsafe.sml 32.11-32.17 *)
val Unsafe.PackWord16Little.subVec: Word8Vector.vector * int -> LargeWord.word (* @ $(SML_LIB)/basis/sml-nj/unsafe.sml 29.11-29.16 *)
val Unsafe.PackWord16Little.subVecX: Word8Vector.vector * int -> LargeWord.word (* @ $(SML_LIB)/basis/sml-nj/unsafe.sml 30.11-30.17 *)
val Unsafe.PackWord16Little.update: Word8Array.array * int * LargeWord.word -> unit (* @ $(SML_LIB)/basis/sml-nj/unsafe.sml 33.11-33.16 *)
structure Unsafe.PackWord32Big: PACK_WORD (* @ $(SML_LIB)/basis/sml-nj/unsafe.sml 115.17-115.29 *)
val Unsafe.PackWord32Big.bytesPerElem: int (* @ $(SML_LIB)/basis/integer/pack-word.sml 25.5-25.16 *)
val Unsafe.PackWord32Big.isBigEndian: bool (* @ $(SML_LIB)/basis/integer/pack-word.sml 120.18-120.28 *)
val Unsafe.PackWord32Big.subArr: Word8Array.array * int -> LargeWord.word (* @ $(SML_LIB)/basis/sml-nj/unsafe.sml 31.11-31.16 *)
val Unsafe.PackWord32Big.subArrX: Word8Array.array * int -> LargeWord.word (* @ $(SML_LIB)/basis/sml-nj/unsafe.sml 32.11-32.17 *)
val Unsafe.PackWord32Big.subVec: Word8Vector.vector * int -> LargeWord.word (* @ $(SML_LIB)/basis/sml-nj/unsafe.sml 29.11-29.16 *)
val Unsafe.PackWord32Big.subVecX: Word8Vector.vector * int -> LargeWord.word (* @ $(SML_LIB)/basis/sml-nj/unsafe.sml 30.11-30.17 *)
val Unsafe.PackWord32Big.update: Word8Array.array * int * LargeWord.word -> unit (* @ $(SML_LIB)/basis/sml-nj/unsafe.sml 33.11-33.16 *)
structure Unsafe.PackWord32Little: PACK_WORD (* @ $(SML_LIB)/basis/sml-nj/unsafe.sml 116.17-116.32 *)
val Unsafe.PackWord32Little.bytesPerElem: int (* @ $(SML_LIB)/basis/integer/pack-word.sml 25.5-25.16 *)
val Unsafe.PackWord32Little.isBigEndian: bool (* @ $(SML_LIB)/basis/integer/pack-word.sml 124.18-124.28 *)
val Unsafe.PackWord32Little.subArr: Word8Array.array * int -> LargeWord.word (* @ $(SML_LIB)/basis/sml-nj/unsafe.sml 31.11-31.16 *)
val Unsafe.PackWord32Little.subArrX: Word8Array.array * int -> LargeWord.word (* @ $(SML_LIB)/basis/sml-nj/unsafe.sml 32.11-32.17 *)
val Unsafe.PackWord32Little.subVec: Word8Vector.vector * int -> LargeWord.word (* @ $(SML_LIB)/basis/sml-nj/unsafe.sml 29.11-29.16 *)
val Unsafe.PackWord32Little.subVecX: Word8Vector.vector * int -> LargeWord.word (* @ $(SML_LIB)/basis/sml-nj/unsafe.sml 30.11-30.17 *)
val Unsafe.PackWord32Little.update: Word8Array.array * int * LargeWord.word -> unit (* @ $(SML_LIB)/basis/sml-nj/unsafe.sml 33.11-33.16 *)
structure Unsafe.PackWord64Big: PACK_WORD (* @ $(SML_LIB)/basis/sml-nj/unsafe.sml 117.17-117.29 *)
val Unsafe.PackWord64Big.bytesPerElem: int (* @ $(SML_LIB)/basis/integer/pack-word.sml 25.5-25.16 *)
val Unsafe.PackWord64Big.isBigEndian: bool (* @ $(SML_LIB)/basis/integer/pack-word.sml 132.18-132.28 *)
val Unsafe.PackWord64Big.subArr: Word8Array.array * int -> LargeWord.word (* @ $(SML_LIB)/basis/sml-nj/unsafe.sml 31.11-31.16 *)
val Unsafe.PackWord64Big.subArrX: Word8Array.array * int -> LargeWord.word (* @ $(SML_LIB)/basis/sml-nj/unsafe.sml 32.11-32.17 *)
val Unsafe.PackWord64Big.subVec: Word8Vector.vector * int -> LargeWord.word (* @ $(SML_LIB)/basis/sml-nj/unsafe.sml 29.11-29.16 *)
val Unsafe.PackWord64Big.subVecX: Word8Vector.vector * int -> LargeWord.word (* @ $(SML_LIB)/basis/sml-nj/unsafe.sml 30.11-30.17 *)
val Unsafe.PackWord64Big.update: Word8Array.array * int * LargeWord.word -> unit (* @ $(SML_LIB)/basis/sml-nj/unsafe.sml 33.11-33.16 *)
structure Unsafe.PackWord64Little: PACK_WORD (* @ $(SML_LIB)/basis/sml-nj/unsafe.sml 118.17-118.32 *)
val Unsafe.PackWord64Little.bytesPerElem: int (* @ $(SML_LIB)/basis/integer/pack-word.sml 25.5-25.16 *)
val Unsafe.PackWord64Little.isBigEndian: bool (* @ $(SML_LIB)/basis/integer/pack-word.sml 136.18-136.28 *)
val Unsafe.PackWord64Little.subArr: Word8Array.array * int -> LargeWord.word (* @ $(SML_LIB)/basis/sml-nj/unsafe.sml 31.11-31.16 *)
val Unsafe.PackWord64Little.subArrX: Word8Array.array * int -> LargeWord.word (* @ $(SML_LIB)/basis/sml-nj/unsafe.sml 32.11-32.17 *)
val Unsafe.PackWord64Little.subVec: Word8Vector.vector * int -> LargeWord.word (* @ $(SML_LIB)/basis/sml-nj/unsafe.sml 29.11-29.16 *)
val Unsafe.PackWord64Little.subVecX: Word8Vector.vector * int -> LargeWord.word (* @ $(SML_LIB)/basis/sml-nj/unsafe.sml 30.11-30.17 *)
val Unsafe.PackWord64Little.update: Word8Array.array * int * LargeWord.word -> unit (* @ $(SML_LIB)/basis/sml-nj/unsafe.sml 33.11-33.16 *)
structure Unsafe.Real32Array:
   sig
      type array = Real32Array.array
      type elem = Real32.real
      val create: int -> Real32Array.array
      val sub: Real32Array.array * int -> Real32.real
      val update: Real32Array.array * int * Real32.real -> unit
   end
   (* @ $(SML_LIB)/basis/sml-nj/unsafe.sml 89.17-89.27 *)
type Unsafe.Real32Array.array = Real32Array.array (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array.fun 23.12-23.16 *)
type Unsafe.Real32Array.elem = Real32.real (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array.fun 22.12-22.15 *)
val Unsafe.Real32Array.create: int -> Real32Array.array (* @ $(SML_LIB)/basis/sml-nj/unsafe.sml 16.11-16.16 *)
val Unsafe.Real32Array.sub: Real32Array.array * int -> Real32.real (* @ $(SML_LIB)/basis/sml-nj/unsafe.sml 14.11-14.13 *)
val Unsafe.Real32Array.update: Real32Array.array * int * Real32.real -> unit (* @ $(SML_LIB)/basis/sml-nj/unsafe.sml 15.11-15.16 *)
structure Unsafe.Real32Vector:
   sig
      type elem = Real32.real
      type vector = Real32Vector.vector
      val sub: Real32Vector.vector * int -> Real32.real
   end
   (* @ $(SML_LIB)/basis/sml-nj/unsafe.sml 90.17-90.28 *)
type Unsafe.Real32Vector.elem = Real32.real (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-vector.fun 15.12-15.15 *)
type Unsafe.Real32Vector.vector = Real32Vector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-vector.fun 16.12-16.17 *)
val Unsafe.Real32Vector.sub: Real32Vector.vector * int -> Real32.real (* @ $(SML_LIB)/basis/sml-nj/unsafe.sml 23.11-23.13 *)
structure Unsafe.Real64Array:
   sig
      type array = Real64Array.array
      type elem = real
      val create: int -> Real64Array.array
      val sub: Real64Array.array * int -> real
      val update: Real64Array.array * int * real -> unit
   end
   (* @ $(SML_LIB)/basis/sml-nj/unsafe.sml 91.17-91.27 *)
type Unsafe.Real64Array.array = Real64Array.array (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array.fun 23.12-23.16 *)
type Unsafe.Real64Array.elem = real (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array.fun 22.12-22.15 *)
val Unsafe.Real64Array.create: int -> Real64Array.array (* @ $(SML_LIB)/basis/sml-nj/unsafe.sml 16.11-16.16 *)
val Unsafe.Real64Array.sub: Real64Array.array * int -> real (* @ $(SML_LIB)/basis/sml-nj/unsafe.sml 14.11-14.13 *)
val Unsafe.Real64Array.update: Real64Array.array * int * real -> unit (* @ $(SML_LIB)/basis/sml-nj/unsafe.sml 15.11-15.16 *)
structure Unsafe.Real64Vector:
   sig
      type elem = real
      type vector = Real64Vector.vector
      val sub: Real64Vector.vector * int -> real
   end
   (* @ $(SML_LIB)/basis/sml-nj/unsafe.sml 92.17-92.28 *)
type Unsafe.Real64Vector.elem = real (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-vector.fun 15.12-15.15 *)
type Unsafe.Real64Vector.vector = Real64Vector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-vector.fun 16.12-16.17 *)
val Unsafe.Real64Vector.sub: Real64Vector.vector * int -> real (* @ $(SML_LIB)/basis/sml-nj/unsafe.sml 23.11-23.13 *)
structure Unsafe.RealArray:
   sig
      type array = RealArray.array
      type elem = real
      val create: int -> RealArray.array
      val sub: RealArray.array * int -> real
      val update: RealArray.array * int * real -> unit
   end
   (* @ $(SML_LIB)/basis/sml-nj/unsafe.sml 87.17-87.25 *)
type Unsafe.RealArray.array = RealArray.array (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array.fun 23.12-23.16 *)
type Unsafe.RealArray.elem = real (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array.fun 22.12-22.15 *)
val Unsafe.RealArray.create: int -> RealArray.array (* @ $(SML_LIB)/basis/sml-nj/unsafe.sml 16.11-16.16 *)
val Unsafe.RealArray.sub: RealArray.array * int -> real (* @ $(SML_LIB)/basis/sml-nj/unsafe.sml 14.11-14.13 *)
val Unsafe.RealArray.update: RealArray.array * int * real -> unit (* @ $(SML_LIB)/basis/sml-nj/unsafe.sml 15.11-15.16 *)
structure Unsafe.RealVector:
   sig
      type elem = real
      type vector = RealVector.vector
      val sub: RealVector.vector * int -> real
   end
   (* @ $(SML_LIB)/basis/sml-nj/unsafe.sml 88.17-88.26 *)
type Unsafe.RealVector.elem = real (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-vector.fun 15.12-15.15 *)
type Unsafe.RealVector.vector = RealVector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-vector.fun 16.12-16.17 *)
val Unsafe.RealVector.sub: RealVector.vector * int -> real (* @ $(SML_LIB)/basis/sml-nj/unsafe.sml 23.11-23.13 *)
structure Unsafe.Vector:
   sig
      val sub: 'a vector * int -> 'a
   end
   (* @ $(SML_LIB)/basis/sml-nj/unsafe.sml 93.17-93.22 *)
val Unsafe.Vector.sub: 'a vector * int -> 'a (* @ $(SML_LIB)/basis/sml-nj/unsafe.sml 95.17-95.19 *)
structure Unsafe.Word16Array:
   sig
      type array = Word16Array.array
      type elem = Word16.word
      val create: int -> Word16Array.array
      val sub: Word16Array.array * int -> Word16.word
      val update: Word16Array.array * int * Word16.word -> unit
   end
   (* @ $(SML_LIB)/basis/sml-nj/unsafe.sml 101.17-101.27 *)
type Unsafe.Word16Array.array = Word16Array.array (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array.fun 23.12-23.16 *)
type Unsafe.Word16Array.elem = Word16.word (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array.fun 22.12-22.15 *)
val Unsafe.Word16Array.create: int -> Word16Array.array (* @ $(SML_LIB)/basis/sml-nj/unsafe.sml 16.11-16.16 *)
val Unsafe.Word16Array.sub: Word16Array.array * int -> Word16.word (* @ $(SML_LIB)/basis/sml-nj/unsafe.sml 14.11-14.13 *)
val Unsafe.Word16Array.update: Word16Array.array * int * Word16.word -> unit (* @ $(SML_LIB)/basis/sml-nj/unsafe.sml 15.11-15.16 *)
structure Unsafe.Word16Vector:
   sig
      type elem = Word16.word
      type vector = Word16Vector.vector
      val sub: Word16Vector.vector * int -> Word16.word
   end
   (* @ $(SML_LIB)/basis/sml-nj/unsafe.sml 102.17-102.28 *)
type Unsafe.Word16Vector.elem = Word16.word (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-vector.fun 35.12-35.15 *)
type Unsafe.Word16Vector.vector = Word16Vector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-vector.fun 36.12-36.17 *)
val Unsafe.Word16Vector.sub: Word16Vector.vector * int -> Word16.word (* @ $(SML_LIB)/basis/sml-nj/unsafe.sml 23.11-23.13 *)
structure Unsafe.Word32Array:
   sig
      type array = Word32Array.array
      type elem = word
      val create: int -> Word32Array.array
      val sub: Word32Array.array * int -> word
      val update: Word32Array.array * int * word -> unit
   end
   (* @ $(SML_LIB)/basis/sml-nj/unsafe.sml 103.17-103.27 *)
type Unsafe.Word32Array.array = Word32Array.array (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array.fun 23.12-23.16 *)
type Unsafe.Word32Array.elem = word (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array.fun 22.12-22.15 *)
val Unsafe.Word32Array.create: int -> Word32Array.array (* @ $(SML_LIB)/basis/sml-nj/unsafe.sml 16.11-16.16 *)
val Unsafe.Word32Array.sub: Word32Array.array * int -> word (* @ $(SML_LIB)/basis/sml-nj/unsafe.sml 14.11-14.13 *)
val Unsafe.Word32Array.update: Word32Array.array * int * word -> unit (* @ $(SML_LIB)/basis/sml-nj/unsafe.sml 15.11-15.16 *)
structure Unsafe.Word32Vector:
   sig
      type elem = word
      type vector = Word32Vector.vector
      val sub: Word32Vector.vector * int -> word
   end
   (* @ $(SML_LIB)/basis/sml-nj/unsafe.sml 104.17-104.28 *)
type Unsafe.Word32Vector.elem = word (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-vector.fun 35.12-35.15 *)
type Unsafe.Word32Vector.vector = Word32Vector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-vector.fun 36.12-36.17 *)
val Unsafe.Word32Vector.sub: Word32Vector.vector * int -> word (* @ $(SML_LIB)/basis/sml-nj/unsafe.sml 23.11-23.13 *)
structure Unsafe.Word64Array:
   sig
      type array = Word64Array.array
      type elem = LargeWord.word
      val create: int -> Word64Array.array
      val sub: Word64Array.array * int -> LargeWord.word
      val update: Word64Array.array * int * LargeWord.word -> unit
   end
   (* @ $(SML_LIB)/basis/sml-nj/unsafe.sml 105.17-105.27 *)
type Unsafe.Word64Array.array = Word64Array.array (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array.fun 23.12-23.16 *)
type Unsafe.Word64Array.elem = LargeWord.word (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array.fun 22.12-22.15 *)
val Unsafe.Word64Array.create: int -> Word64Array.array (* @ $(SML_LIB)/basis/sml-nj/unsafe.sml 16.11-16.16 *)
val Unsafe.Word64Array.sub: Word64Array.array * int -> LargeWord.word (* @ $(SML_LIB)/basis/sml-nj/unsafe.sml 14.11-14.13 *)
val Unsafe.Word64Array.update: Word64Array.array * int * LargeWord.word -> unit (* @ $(SML_LIB)/basis/sml-nj/unsafe.sml 15.11-15.16 *)
structure Unsafe.Word64Vector:
   sig
      type elem = LargeWord.word
      type vector = Word64Vector.vector
      val sub: Word64Vector.vector * int -> LargeWord.word
   end
   (* @ $(SML_LIB)/basis/sml-nj/unsafe.sml 106.17-106.28 *)
type Unsafe.Word64Vector.elem = LargeWord.word (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-vector.fun 35.12-35.15 *)
type Unsafe.Word64Vector.vector = Word64Vector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-vector.fun 36.12-36.17 *)
val Unsafe.Word64Vector.sub: Word64Vector.vector * int -> LargeWord.word (* @ $(SML_LIB)/basis/sml-nj/unsafe.sml 23.11-23.13 *)
structure Unsafe.Word8Array:
   sig
      type array = Word8Array.array
      type elem = Word8.word
      val create: int -> Word8Array.array
      val sub: Word8Array.array * int -> Word8.word
      val update: Word8Array.array * int * Word8.word -> unit
   end
   (* @ $(SML_LIB)/basis/sml-nj/unsafe.sml 99.17-99.26 *)
type Unsafe.Word8Array.array = Word8Array.array (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array.fun 23.12-23.16 *)
type Unsafe.Word8Array.elem = Word8.word (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array.fun 22.12-22.15 *)
val Unsafe.Word8Array.create: int -> Word8Array.array (* @ $(SML_LIB)/basis/sml-nj/unsafe.sml 16.11-16.16 *)
val Unsafe.Word8Array.sub: Word8Array.array * int -> Word8.word (* @ $(SML_LIB)/basis/sml-nj/unsafe.sml 14.11-14.13 *)
val Unsafe.Word8Array.update: Word8Array.array * int * Word8.word -> unit (* @ $(SML_LIB)/basis/sml-nj/unsafe.sml 15.11-15.16 *)
structure Unsafe.Word8Vector:
   sig
      type elem = Word8.word
      type vector = Word8Vector.vector
      val sub: Word8Vector.vector * int -> Word8.word
   end
   (* @ $(SML_LIB)/basis/sml-nj/unsafe.sml 100.17-100.27 *)
type Unsafe.Word8Vector.elem = Word8.word (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-vector.fun 35.12-35.15 *)
type Unsafe.Word8Vector.vector = Word8Vector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-vector.fun 36.12-36.17 *)
val Unsafe.Word8Vector.sub: Word8Vector.vector * int -> Word8.word (* @ $(SML_LIB)/basis/sml-nj/unsafe.sml 23.11-23.13 *)
structure Unsafe.WordArray:
   sig
      type array = WordArray.array
      type elem = word
      val create: int -> WordArray.array
      val sub: WordArray.array * int -> word
      val update: WordArray.array * int * word -> unit
   end
   (* @ $(SML_LIB)/basis/sml-nj/unsafe.sml 97.17-97.25 *)
type Unsafe.WordArray.array = WordArray.array (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array.fun 23.12-23.16 *)
type Unsafe.WordArray.elem = word (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array.fun 22.12-22.15 *)
val Unsafe.WordArray.create: int -> WordArray.array (* @ $(SML_LIB)/basis/sml-nj/unsafe.sml 16.11-16.16 *)
val Unsafe.WordArray.sub: WordArray.array * int -> word (* @ $(SML_LIB)/basis/sml-nj/unsafe.sml 14.11-14.13 *)
val Unsafe.WordArray.update: WordArray.array * int * word -> unit (* @ $(SML_LIB)/basis/sml-nj/unsafe.sml 15.11-15.16 *)
structure Unsafe.WordVector:
   sig
      type elem = word
      type vector = WordVector.vector
      val sub: WordVector.vector * int -> word
   end
   (* @ $(SML_LIB)/basis/sml-nj/unsafe.sml 98.17-98.26 *)
type Unsafe.WordVector.elem = word (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-vector.fun 35.12-35.15 *)
type Unsafe.WordVector.vector = WordVector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-vector.fun 36.12-36.17 *)
val Unsafe.WordVector.sub: WordVector.vector * int -> word (* @ $(SML_LIB)/basis/sml-nj/unsafe.sml 23.11-23.13 *)
structure Vector: VECTOR (* @ $(SML_LIB)/basis/libs/basis-2002/top-level/top-level.sml 75.11-75.16 *)
type 'a Vector.vector = 'a vector (* @ $(SML_LIB)/basis/arrays-and-vectors/vector.sml 15.15-15.20 *)
val Vector.all: ('a -> bool) -> 'a vector -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 476.13-476.15 *)
val Vector.app: ('a -> unit) -> 'a vector -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 464.13-464.15 *)
val Vector.appi: (int * 'a -> unit) -> 'a vector -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 463.13-463.16 *)
val Vector.collate: ('a * 'a -> order) -> 'a vector * 'a vector -> order (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 477.13-477.19 *)
val Vector.concat: 'a vector list -> 'a vector (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 462.13-462.18 *)
val Vector.exists: ('a -> bool) -> 'a vector -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 474.13-474.18 *)
val Vector.find: ('a -> bool) -> 'a vector -> 'a option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 472.13-472.16 *)
val Vector.findi: (int * 'a -> bool) -> 'a vector -> (int * 'a) option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 471.13-471.17 *)
val Vector.foldl: ('a * 'b -> 'b) -> 'b -> 'a vector -> 'b (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 468.13-468.17 *)
val Vector.foldli: (int * 'a * 'b -> 'b) -> 'b -> 'a vector -> 'b (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 467.13-467.18 *)
val Vector.foldr: ('a * 'b -> 'b) -> 'b -> 'a vector -> 'b (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 470.13-470.17 *)
val Vector.foldri: (int * 'a * 'b -> 'b) -> 'b -> 'a vector -> 'b (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 469.13-469.18 *)
val Vector.fromList: 'a list -> 'a vector (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 122.11-122.18 *)
val Vector.length: 'a vector -> int (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 90.11-90.16 *)
val Vector.map: ('a -> 'b) -> 'a vector -> 'b vector (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 466.13-466.15 *)
val Vector.mapi: (int * 'a -> 'b) -> 'a vector -> 'b vector (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 465.13-465.16 *)
val Vector.maxLen: int (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 88.11-88.16 *)
val Vector.sub: 'a vector * int -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 450.13-450.15 *)
val Vector.tabulate: int * (int -> 'a) -> 'a vector (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 114.11-114.18 *)
val Vector.update: 'a vector * int * 'a -> 'a vector (* @ $(SML_LIB)/basis/arrays-and-vectors/vector.sml 30.11-30.16 *)
structure VectorSlice: VECTOR_SLICE where type 'a slice = 'a VectorSlice.slice (* @ $(SML_LIB)/basis/libs/basis-extra/top-level/basis.sml 46.17-46.27 *)
type 'a VectorSlice.slice = 'a VectorSlice.slice (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 132.21-132.25 *)
val VectorSlice.all: ('a -> bool) -> 'a VectorSlice.slice -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 235.17-235.19 *)
val VectorSlice.app: ('a -> unit) -> 'a VectorSlice.slice -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 226.17-226.19 *)
val VectorSlice.appi: (int * 'a -> unit) -> 'a VectorSlice.slice -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 225.17-225.20 *)
val VectorSlice.base: 'a VectorSlice.slice -> 'a vector * int * int (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 208.17-208.20 *)
val VectorSlice.collate: ('a * 'a -> order) -> 'a VectorSlice.slice * 'a VectorSlice.slice -> order (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 236.17-236.23 *)
val VectorSlice.concat: 'a VectorSlice.slice list -> 'a vector (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 240.17-240.22 *)
val VectorSlice.exists: ('a -> bool) -> 'a VectorSlice.slice -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 233.17-233.22 *)
val VectorSlice.find: ('a -> bool) -> 'a VectorSlice.slice -> 'a option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 231.17-231.20 *)
val VectorSlice.findi: (int * 'a -> bool) -> 'a VectorSlice.slice -> (int * 'a) option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 229.17-229.21 *)
val VectorSlice.foldl: ('a * 'b -> 'b) -> 'b -> 'a VectorSlice.slice -> 'b (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 223.17-223.21 *)
val VectorSlice.foldli: (int * 'a * 'b -> 'b) -> 'b -> 'a VectorSlice.slice -> 'b (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 221.17-221.22 *)
val VectorSlice.foldr: ('a * 'b -> 'b) -> 'b -> 'a VectorSlice.slice -> 'b (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 224.17-224.21 *)
val VectorSlice.foldri: (int * 'a * 'b -> 'b) -> 'b -> 'a VectorSlice.slice -> 'b (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 222.17-222.22 *)
val VectorSlice.full: 'a vector -> 'a VectorSlice.slice (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 192.17-192.20 *)
val VectorSlice.getItem: 'a VectorSlice.slice -> ('a * 'a VectorSlice.slice) option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 220.17-220.23 *)
val VectorSlice.isEmpty: 'a VectorSlice.slice -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 219.17-219.23 *)
val VectorSlice.length: 'a VectorSlice.slice -> int (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 134.17-134.22 *)
val VectorSlice.map: ('a -> 'b) -> 'a VectorSlice.slice -> 'b vector (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 228.17-228.19 *)
val VectorSlice.mapi: (int * 'a -> 'b) -> 'a VectorSlice.slice -> 'b vector (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 227.17-227.20 *)
val VectorSlice.slice: 'a vector * int * int option -> 'a VectorSlice.slice (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 206.17-206.21 *)
val VectorSlice.sub: 'a VectorSlice.slice * int -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 142.17-142.19 *)
val VectorSlice.subslice: 'a VectorSlice.slice * int * int option -> 'a VectorSlice.slice (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 199.17-199.24 *)
val VectorSlice.vector: 'a VectorSlice.slice -> 'a vector (* @ $(SML_LIB)/basis/arrays-and-vectors/vector.sml 21.17-21.22 *)
structure WideChar: CHAR where type char = WideSubstring.char where type string = WideSubstring.char vector (* @ $(SML_LIB)/basis/libs/basis-extra/top-level/basis.sml 183.17-183.24 *)
type WideChar.char = WideSubstring.char (* @ $(SML_LIB)/basis/primitive/prim-basis.sml 67.12-67.15 *)
type WideChar.string = WideSubstring.char vector (* @ $(SML_LIB)/basis/text/char.sml 25.12-25.17 *)
val WideChar.< : WideSubstring.char * WideSubstring.char -> bool (* @ $(SML_LIB)/basis/util/integral-comparisons.sml 11.11-11.11 *)
val WideChar.<= : WideSubstring.char * WideSubstring.char -> bool (* @ $(SML_LIB)/basis/util/integral-comparisons.sml 12.11-12.12 *)
val WideChar.> : WideSubstring.char * WideSubstring.char -> bool (* @ $(SML_LIB)/basis/util/integral-comparisons.sml 13.11-13.11 *)
val WideChar.>= : WideSubstring.char * WideSubstring.char -> bool (* @ $(SML_LIB)/basis/util/integral-comparisons.sml 14.11-14.12 *)
val WideChar.chr: int -> WideSubstring.char (* @ $(SML_LIB)/basis/text/char.sml 50.11-50.13 *)
val WideChar.compare: WideSubstring.char * WideSubstring.char -> order (* @ $(SML_LIB)/basis/util/integral-comparisons.sml 16.11-16.17 *)
val WideChar.contains: WideSubstring.char vector -> WideSubstring.char -> bool (* @ $(SML_LIB)/basis/text/char.sml 59.11-59.18 *)
val WideChar.fromCString: string -> WideSubstring.char option (* @ $(SML_LIB)/basis/text/char.sml 272.11-272.21 *)
val WideChar.fromString: string -> WideSubstring.char option (* @ $(SML_LIB)/basis/text/char.sml 217.11-217.20 *)
val WideChar.isAlpha: WideSubstring.char -> bool (* @ $(SML_LIB)/basis/text/char.sml 90.11-90.17 *)
val WideChar.isAlphaNum: WideSubstring.char -> bool (* @ $(SML_LIB)/basis/text/char.sml 91.11-91.20 *)
val WideChar.isAscii: WideSubstring.char -> bool (* @ $(SML_LIB)/basis/text/char.sml 87.11-87.17 *)
val WideChar.isCntrl: WideSubstring.char -> bool (* @ $(SML_LIB)/basis/text/char.sml 86.11-86.17 *)
val WideChar.isDigit: WideSubstring.char -> bool (* @ $(SML_LIB)/basis/text/char.sml 83.11-83.17 *)
val WideChar.isGraph: WideSubstring.char -> bool (* @ $(SML_LIB)/basis/text/char.sml 84.11-84.17 *)
val WideChar.isHexDigit: WideSubstring.char -> bool (* @ $(SML_LIB)/basis/text/char.sml 96.11-96.20 *)
val WideChar.isLower: WideSubstring.char -> bool (* @ $(SML_LIB)/basis/text/char.sml 81.11-81.17 *)
val WideChar.isPrint: WideSubstring.char -> bool (* @ $(SML_LIB)/basis/text/char.sml 85.11-85.17 *)
val WideChar.isPunct: WideSubstring.char -> bool (* @ $(SML_LIB)/basis/text/char.sml 102.11-102.17 *)
val WideChar.isSpace: WideSubstring.char -> bool (* @ $(SML_LIB)/basis/text/char.sml 101.11-101.17 *)
val WideChar.isUpper: WideSubstring.char -> bool (* @ $(SML_LIB)/basis/text/char.sml 82.11-82.17 *)
val WideChar.maxChar: WideSubstring.char (* @ $(SML_LIB)/basis/text/char0.sml 72.44-72.50 *)
val WideChar.maxOrd: int (* @ $(SML_LIB)/basis/text/char.sml 26.11-26.16 *)
val WideChar.minChar: WideSubstring.char (* @ $(SML_LIB)/basis/text/char0.sml 72.35-72.41 *)
val WideChar.notContains: WideSubstring.char vector -> WideSubstring.char -> bool (* @ $(SML_LIB)/basis/text/char.sml 74.11-74.21 *)
val WideChar.ord: WideSubstring.char -> int (* @ $(SML_LIB)/basis/text/char0.sml 72.30-72.32 *)
val WideChar.pred: WideSubstring.char -> WideSubstring.char (* @ $(SML_LIB)/basis/text/char.sml 38.11-38.14 *)
val WideChar.scan: ('a -> (char * 'a) option) -> 'a -> (WideSubstring.char * 'a) option (* @ $(SML_LIB)/basis/text/char.sml 160.14-160.17 *)
val WideChar.succ: WideSubstring.char -> WideSubstring.char (* @ $(SML_LIB)/basis/text/char.sml 32.11-32.14 *)
val WideChar.toCString: WideSubstring.char -> string (* @ $(SML_LIB)/basis/text/char.sml 324.11-324.19 *)
val WideChar.toLower: WideSubstring.char -> WideSubstring.char (* @ $(SML_LIB)/basis/text/char.sml 109.14-109.20 *)
val WideChar.toString: WideSubstring.char -> string (* @ $(SML_LIB)/basis/text/char.sml 292.11-292.18 *)
val WideChar.toUpper: WideSubstring.char -> WideSubstring.char (* @ $(SML_LIB)/basis/text/char.sml 110.14-110.20 *)
structure WideCharArray: MONO_ARRAY where type array = WideCharArraySlice.array where type elem = WideSubstring.char where type vector = WideSubstring.char vector (* @ $(SML_LIB)/basis/libs/basis-extra/top-level/basis.sml 184.17-184.29 *)
type WideCharArray.array = WideCharArraySlice.array (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array.fun 23.12-23.16 *)
type WideCharArray.elem = WideSubstring.char (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array.fun 22.12-22.15 *)
type WideCharArray.vector = WideSubstring.char vector (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array.fun 24.12-24.17 *)
val WideCharArray.all: (WideSubstring.char -> bool) -> WideCharArraySlice.array -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 476.13-476.15 *)
val WideCharArray.app: (WideSubstring.char -> unit) -> WideCharArraySlice.array -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 464.13-464.15 *)
val WideCharArray.appi: (int * WideSubstring.char -> unit) -> WideCharArraySlice.array -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 463.13-463.16 *)
val WideCharArray.array: int * WideSubstring.char -> WideCharArraySlice.array (* @ $(SML_LIB)/basis/arrays-and-vectors/array.sml 34.11-34.15 *)
val WideCharArray.collate: (WideSubstring.char * WideSubstring.char -> order) -> WideCharArraySlice.array * WideCharArraySlice.array -> order (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 477.13-477.19 *)
val WideCharArray.copy: {di: int, dst: WideCharArraySlice.array, src: WideCharArraySlice.array} -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 457.13-457.16 *)
val WideCharArray.copyVec: {di: int, dst: WideCharArraySlice.array, src: WideSubstring.char vector} -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array.sml 37.11-37.17 *)
val WideCharArray.exists: (WideSubstring.char -> bool) -> WideCharArraySlice.array -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 474.13-474.18 *)
val WideCharArray.find: (WideSubstring.char -> bool) -> WideCharArraySlice.array -> WideSubstring.char option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 472.13-472.16 *)
val WideCharArray.findi: (int * WideSubstring.char -> bool) -> WideCharArraySlice.array -> (int * WideSubstring.char) option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 471.13-471.17 *)
val WideCharArray.foldl: (WideSubstring.char * 'a -> 'a) -> 'a -> WideCharArraySlice.array -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 468.13-468.17 *)
val WideCharArray.foldli: (int * WideSubstring.char * 'a -> 'a) -> 'a -> WideCharArraySlice.array -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 467.13-467.18 *)
val WideCharArray.foldr: (WideSubstring.char * 'a -> 'a) -> 'a -> WideCharArraySlice.array -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 470.13-470.17 *)
val WideCharArray.foldri: (int * WideSubstring.char * 'a -> 'a) -> 'a -> WideCharArraySlice.array -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 469.13-469.18 *)
val WideCharArray.fromList: WideSubstring.char list -> WideCharArraySlice.array (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 122.11-122.18 *)
val WideCharArray.length: WideCharArraySlice.array -> int (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 90.11-90.16 *)
val WideCharArray.maxLen: int (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 88.11-88.16 *)
val WideCharArray.modify: (WideSubstring.char -> WideSubstring.char) -> WideCharArraySlice.array -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array.sml 40.11-40.16 *)
val WideCharArray.modifyi: (int * WideSubstring.char -> WideSubstring.char) -> WideCharArraySlice.array -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array.sml 39.11-39.17 *)
val WideCharArray.sub: WideCharArraySlice.array * int -> WideSubstring.char (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 450.13-450.15 *)
val WideCharArray.tabulate: int * (int -> WideSubstring.char) -> WideCharArraySlice.array (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 114.11-114.18 *)
val WideCharArray.update: WideCharArraySlice.array * int * WideSubstring.char -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 452.13-452.18 *)
val WideCharArray.vector: WideCharArraySlice.array -> WideSubstring.char vector (* @ $(SML_LIB)/basis/arrays-and-vectors/array.sml 36.11-36.16 *)
structure WideCharArray2: MONO_ARRAY2 where type array = WideCharArray2.array where type elem = WideSubstring.char where type vector = WideSubstring.char vector (* @ $(SML_LIB)/basis/libs/basis-extra/top-level/basis.sml 185.17-185.30 *)
type WideCharArray2.array = WideCharArray2.array (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array2.fun 18.12-18.16 *)
type WideCharArray2.elem = WideSubstring.char (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array2.fun 15.12-15.15 *)
type WideCharArray2.region = {base: WideCharArray2.array, col: int, ncols: int option, nrows: int option, row: int} (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array2.fun 19.12-19.17 *)
datatype WideCharArray2.traversal = ColMajor | RowMajor (* = datatype Array2.traversal *) (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 106.16-106.24 *)
type WideCharArray2.vector = WideSubstring.char vector (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array2.fun 16.12-16.17 *)
con WideCharArray2.ColMajor: Array2.traversal (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 106.39-106.46 *)
con WideCharArray2.RowMajor: Array2.traversal (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 106.28-106.35 *)
val WideCharArray2.app: Array2.traversal -> (WideSubstring.char -> unit) -> WideCharArray2.array -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 294.11-294.13 *)
val WideCharArray2.appi: Array2.traversal -> (int * int * WideSubstring.char -> unit) -> {base: WideCharArray2.array, col: int, ncols: int option, nrows: int option, row: int} -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 291.11-291.14 *)
val WideCharArray2.array: int * int * WideSubstring.char -> WideCharArray2.array (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 140.14-140.18 *)
val WideCharArray2.column: WideCharArray2.array * int -> WideSubstring.char vector (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 237.11-237.16 *)
val WideCharArray2.copy: {dst: WideCharArray2.array, dst_col: int, dst_row: int, src: {base: WideCharArray2.array, col: int, ncols: int option, nrows: int option, row: int}} -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 309.11-309.14 *)
val WideCharArray2.dimensions: WideCharArray2.array -> int * int (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 33.11-33.20 *)
val WideCharArray2.fold: Array2.traversal -> (WideSubstring.char * 'a -> 'a) -> 'a -> WideCharArray2.array -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 288.11-288.14 *)
val WideCharArray2.foldi: Array2.traversal -> (int * int * WideSubstring.char * 'a -> 'a) -> 'a -> {base: WideCharArray2.array, col: int, ncols: int option, nrows: int option, row: int} -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 283.11-283.15 *)
val WideCharArray2.fromList: WideSubstring.char list list -> WideCharArray2.array (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 188.14-188.21 *)
val WideCharArray2.modify: Array2.traversal -> (WideSubstring.char -> WideSubstring.char) -> WideCharArray2.array -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 299.11-299.16 *)
val WideCharArray2.modifyi: Array2.traversal -> (int * int * WideSubstring.char -> WideSubstring.char) -> {base: WideCharArray2.array, col: int, ncols: int option, nrows: int option, row: int} -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 296.11-296.17 *)
val WideCharArray2.nCols: WideCharArray2.array -> int (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 38.11-38.15 *)
val WideCharArray2.nRows: WideCharArray2.array -> int (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 36.11-36.15 *)
val WideCharArray2.row: WideCharArray2.array * int -> WideSubstring.char vector (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 222.11-222.13 *)
val WideCharArray2.sub: WideCharArray2.array * int * int -> WideSubstring.char (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 182.14-182.16 *)
val WideCharArray2.tabulate: Array2.traversal -> int * int * (int * int -> WideSubstring.char) -> WideCharArray2.array (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 301.11-301.18 *)
val WideCharArray2.update: WideCharArray2.array * int * int * WideSubstring.char -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 184.14-184.19 *)
structure WideCharArraySlice: MONO_ARRAY_SLICE where type array = WideCharArraySlice.array where type elem = WideSubstring.char where type slice = WideCharArraySlice.slice where type vector = WideSubstring.char vector where type vector_slice = WideSubstring.substring (* @ $(SML_LIB)/basis/libs/basis-extra/top-level/basis.sml 186.17-186.34 *)
type WideCharArraySlice.array = WideCharArraySlice.array (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array.fun 35.18-35.22 *)
type WideCharArraySlice.elem = WideSubstring.char (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array.fun 34.18-34.21 *)
type WideCharArraySlice.slice = WideCharArraySlice.slice (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array.fun 36.18-36.22 *)
type WideCharArraySlice.vector = WideSubstring.char vector (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array.fun 37.18-37.23 *)
type WideCharArraySlice.vector_slice = WideSubstring.substring (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array.fun 38.18-38.29 *)
val WideCharArraySlice.all: (WideSubstring.char -> bool) -> WideCharArraySlice.slice -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 235.17-235.19 *)
val WideCharArraySlice.app: (WideSubstring.char -> unit) -> WideCharArraySlice.slice -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 226.17-226.19 *)
val WideCharArraySlice.appi: (int * WideSubstring.char -> unit) -> WideCharArraySlice.slice -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 225.17-225.20 *)
val WideCharArraySlice.base: WideCharArraySlice.slice -> WideCharArraySlice.array * int * int (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 208.17-208.20 *)
val WideCharArraySlice.collate: (WideSubstring.char * WideSubstring.char -> order) -> WideCharArraySlice.slice * WideCharArraySlice.slice -> order (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 236.17-236.23 *)
val WideCharArraySlice.copy: {di: int, dst: WideCharArraySlice.array, src: WideCharArraySlice.slice} -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 185.17-185.20 *)
val WideCharArraySlice.copyVec: {di: int, dst: WideCharArraySlice.array, src: WideSubstring.substring} -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array.sml 28.17-28.23 *)
val WideCharArraySlice.exists: (WideSubstring.char -> bool) -> WideCharArraySlice.slice -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 233.17-233.22 *)
val WideCharArraySlice.find: (WideSubstring.char -> bool) -> WideCharArraySlice.slice -> WideSubstring.char option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 231.17-231.20 *)
val WideCharArraySlice.findi: (int * WideSubstring.char -> bool) -> WideCharArraySlice.slice -> (int * WideSubstring.char) option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 229.17-229.21 *)
val WideCharArraySlice.foldl: (WideSubstring.char * 'a -> 'a) -> 'a -> WideCharArraySlice.slice -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 223.17-223.21 *)
val WideCharArraySlice.foldli: (int * WideSubstring.char * 'a -> 'a) -> 'a -> WideCharArraySlice.slice -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 221.17-221.22 *)
val WideCharArraySlice.foldr: (WideSubstring.char * 'a -> 'a) -> 'a -> WideCharArraySlice.slice -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 224.17-224.21 *)
val WideCharArraySlice.foldri: (int * WideSubstring.char * 'a -> 'a) -> 'a -> WideCharArraySlice.slice -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 222.17-222.22 *)
val WideCharArraySlice.full: WideCharArraySlice.array -> WideCharArraySlice.slice (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 192.17-192.20 *)
val WideCharArraySlice.getItem: WideCharArraySlice.slice -> (WideSubstring.char * WideCharArraySlice.slice) option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 220.17-220.23 *)
val WideCharArraySlice.isEmpty: WideCharArraySlice.slice -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 219.17-219.23 *)
val WideCharArraySlice.length: WideCharArraySlice.slice -> int (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 134.17-134.22 *)
val WideCharArraySlice.modify: (WideSubstring.char -> WideSubstring.char) -> WideCharArraySlice.slice -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array.sml 31.17-31.22 *)
val WideCharArraySlice.modifyi: (int * WideSubstring.char -> WideSubstring.char) -> WideCharArraySlice.slice -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array.sml 30.17-30.23 *)
val WideCharArraySlice.slice: WideCharArraySlice.array * int * int option -> WideCharArraySlice.slice (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 206.17-206.21 *)
val WideCharArraySlice.sub: WideCharArraySlice.slice * int -> WideSubstring.char (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 142.17-142.19 *)
val WideCharArraySlice.subslice: WideCharArraySlice.slice * int * int option -> WideCharArraySlice.slice (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 199.17-199.24 *)
val WideCharArraySlice.update: WideCharArraySlice.slice * int * WideSubstring.char -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 155.17-155.22 *)
val WideCharArraySlice.vector: WideCharArraySlice.slice -> WideSubstring.char vector (* @ $(SML_LIB)/basis/arrays-and-vectors/array.sml 27.17-27.22 *)
structure WideCharVector: MONO_VECTOR where type elem = WideSubstring.char where type vector = WideSubstring.char vector (* @ $(SML_LIB)/basis/libs/basis-extra/top-level/basis.sml 187.17-187.30 *)
type WideCharVector.elem = WideSubstring.char (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-vector.fun 35.12-35.15 *)
type WideCharVector.vector = WideSubstring.char vector (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-vector.fun 36.12-36.17 *)
val WideCharVector.all: (WideSubstring.char -> bool) -> WideSubstring.char vector -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 476.13-476.15 *)
val WideCharVector.app: (WideSubstring.char -> unit) -> WideSubstring.char vector -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 464.13-464.15 *)
val WideCharVector.appi: (int * WideSubstring.char -> unit) -> WideSubstring.char vector -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 463.13-463.16 *)
val WideCharVector.collate: (WideSubstring.char * WideSubstring.char -> order) -> WideSubstring.char vector * WideSubstring.char vector -> order (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 477.13-477.19 *)
val WideCharVector.concat: WideSubstring.char vector list -> WideSubstring.char vector (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 462.13-462.18 *)
val WideCharVector.exists: (WideSubstring.char -> bool) -> WideSubstring.char vector -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 474.13-474.18 *)
val WideCharVector.find: (WideSubstring.char -> bool) -> WideSubstring.char vector -> WideSubstring.char option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 472.13-472.16 *)
val WideCharVector.findi: (int * WideSubstring.char -> bool) -> WideSubstring.char vector -> (int * WideSubstring.char) option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 471.13-471.17 *)
val WideCharVector.foldl: (WideSubstring.char * 'a -> 'a) -> 'a -> WideSubstring.char vector -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 468.13-468.17 *)
val WideCharVector.foldli: (int * WideSubstring.char * 'a -> 'a) -> 'a -> WideSubstring.char vector -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 467.13-467.18 *)
val WideCharVector.foldr: (WideSubstring.char * 'a -> 'a) -> 'a -> WideSubstring.char vector -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 470.13-470.17 *)
val WideCharVector.foldri: (int * WideSubstring.char * 'a -> 'a) -> 'a -> WideSubstring.char vector -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 469.13-469.18 *)
val WideCharVector.fromList: WideSubstring.char list -> WideSubstring.char vector (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 122.11-122.18 *)
val WideCharVector.length: WideSubstring.char vector -> int (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 90.11-90.16 *)
val WideCharVector.map: (WideSubstring.char -> WideSubstring.char) -> WideSubstring.char vector -> WideSubstring.char vector (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 466.13-466.15 *)
val WideCharVector.mapi: (int * WideSubstring.char -> WideSubstring.char) -> WideSubstring.char vector -> WideSubstring.char vector (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 465.13-465.16 *)
val WideCharVector.maxLen: int (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 88.11-88.16 *)
val WideCharVector.sub: WideSubstring.char vector * int -> WideSubstring.char (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 450.13-450.15 *)
val WideCharVector.tabulate: int * (int -> WideSubstring.char) -> WideSubstring.char vector (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 114.11-114.18 *)
val WideCharVector.update: WideSubstring.char vector * int * WideSubstring.char -> WideSubstring.char vector (* @ $(SML_LIB)/basis/arrays-and-vectors/vector.sml 30.11-30.16 *)
structure WideCharVectorSlice: MONO_VECTOR_SLICE where type elem = WideSubstring.char where type slice = WideSubstring.substring where type vector = WideSubstring.char vector (* @ $(SML_LIB)/basis/libs/basis-extra/top-level/basis.sml 188.17-188.35 *)
type WideCharVectorSlice.elem = WideSubstring.char (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-vector.fun 43.18-43.21 *)
type WideCharVectorSlice.slice = WideSubstring.substring (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-vector.fun 45.18-45.22 *)
type WideCharVectorSlice.vector = WideSubstring.char vector (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-vector.fun 44.18-44.23 *)
val WideCharVectorSlice.all: (WideSubstring.char -> bool) -> WideSubstring.substring -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 235.17-235.19 *)
val WideCharVectorSlice.app: (WideSubstring.char -> unit) -> WideSubstring.substring -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 226.17-226.19 *)
val WideCharVectorSlice.appi: (int * WideSubstring.char -> unit) -> WideSubstring.substring -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 225.17-225.20 *)
val WideCharVectorSlice.base: WideSubstring.substring -> WideSubstring.char vector * int * int (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 208.17-208.20 *)
val WideCharVectorSlice.collate: (WideSubstring.char * WideSubstring.char -> order) -> WideSubstring.substring * WideSubstring.substring -> order (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 236.17-236.23 *)
val WideCharVectorSlice.concat: WideSubstring.substring list -> WideSubstring.char vector (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 240.17-240.22 *)
val WideCharVectorSlice.exists: (WideSubstring.char -> bool) -> WideSubstring.substring -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 233.17-233.22 *)
val WideCharVectorSlice.find: (WideSubstring.char -> bool) -> WideSubstring.substring -> WideSubstring.char option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 231.17-231.20 *)
val WideCharVectorSlice.findi: (int * WideSubstring.char -> bool) -> WideSubstring.substring -> (int * WideSubstring.char) option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 229.17-229.21 *)
val WideCharVectorSlice.foldl: (WideSubstring.char * 'a -> 'a) -> 'a -> WideSubstring.substring -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 223.17-223.21 *)
val WideCharVectorSlice.foldli: (int * WideSubstring.char * 'a -> 'a) -> 'a -> WideSubstring.substring -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 221.17-221.22 *)
val WideCharVectorSlice.foldr: (WideSubstring.char * 'a -> 'a) -> 'a -> WideSubstring.substring -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 224.17-224.21 *)
val WideCharVectorSlice.foldri: (int * WideSubstring.char * 'a -> 'a) -> 'a -> WideSubstring.substring -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 222.17-222.22 *)
val WideCharVectorSlice.full: WideSubstring.char vector -> WideSubstring.substring (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 192.17-192.20 *)
val WideCharVectorSlice.getItem: WideSubstring.substring -> (WideSubstring.char * WideSubstring.substring) option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 220.17-220.23 *)
val WideCharVectorSlice.isEmpty: WideSubstring.substring -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 219.17-219.23 *)
val WideCharVectorSlice.length: WideSubstring.substring -> int (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 134.17-134.22 *)
val WideCharVectorSlice.map: (WideSubstring.char -> WideSubstring.char) -> WideSubstring.substring -> WideSubstring.char vector (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 228.17-228.19 *)
val WideCharVectorSlice.mapi: (int * WideSubstring.char -> WideSubstring.char) -> WideSubstring.substring -> WideSubstring.char vector (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 227.17-227.20 *)
val WideCharVectorSlice.slice: WideSubstring.char vector * int * int option -> WideSubstring.substring (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 206.17-206.21 *)
val WideCharVectorSlice.sub: WideSubstring.substring * int -> WideSubstring.char (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 142.17-142.19 *)
val WideCharVectorSlice.subslice: WideSubstring.substring * int * int option -> WideSubstring.substring (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 199.17-199.24 *)
val WideCharVectorSlice.vector: WideSubstring.substring -> WideSubstring.char vector (* @ $(SML_LIB)/basis/arrays-and-vectors/vector.sml 21.17-21.22 *)
structure WideString: STRING where type char = WideSubstring.char where type string = WideSubstring.char vector (* @ $(SML_LIB)/basis/libs/basis-extra/top-level/basis.sml 189.17-189.26 *)
type WideString.char = WideSubstring.char (* @ $(SML_LIB)/basis/text/string.sml 27.12-27.15 *)
type WideString.string = WideSubstring.char vector (* @ $(SML_LIB)/basis/text/string.sml 28.12-28.17 *)
val WideString.< : WideSubstring.char vector * WideSubstring.char vector -> bool (* @ $(SML_LIB)/basis/util/string-comparisons.sml 12.11-12.11 *)
val WideString.<= : WideSubstring.char vector * WideSubstring.char vector -> bool (* @ $(SML_LIB)/basis/util/string-comparisons.sml 16.11-16.12 *)
val WideString.> : WideSubstring.char vector * WideSubstring.char vector -> bool (* @ $(SML_LIB)/basis/util/string-comparisons.sml 20.11-20.11 *)
val WideString.>= : WideSubstring.char vector * WideSubstring.char vector -> bool (* @ $(SML_LIB)/basis/util/string-comparisons.sml 24.11-24.12 *)
val WideString.^ : WideSubstring.char vector * WideSubstring.char vector -> WideSubstring.char vector (* @ $(SML_LIB)/basis/text/string.sml 35.14-35.14 *)
val WideString.collate: (WideSubstring.char * WideSubstring.char -> order) -> WideSubstring.char vector * WideSubstring.char vector -> order (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 477.13-477.19 *)
val WideString.compare: WideSubstring.char vector * WideSubstring.char vector -> order (* @ $(SML_LIB)/basis/text/string.sml 52.11-52.17 *)
val WideString.concat: WideSubstring.char vector list -> WideSubstring.char vector (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 462.13-462.18 *)
val WideString.concatWith: WideSubstring.char vector -> WideSubstring.char vector list -> WideSubstring.char vector (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 478.13-478.22 *)
val WideString.explode: WideSubstring.char vector -> WideSubstring.char list (* @ $(SML_LIB)/basis/text/string.sml 37.11-37.17 *)
val WideString.extract: WideSubstring.char vector * int * int option -> WideSubstring.char vector (* @ $(SML_LIB)/basis/text/string.sml 39.11-39.17 *)
val WideString.fields: (WideSubstring.char -> bool) -> WideSubstring.char vector -> WideSubstring.char vector list (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 484.13-484.18 *)
val WideString.fromCString: string -> WideSubstring.char vector option (* @ $(SML_LIB)/basis/text/string.sml 84.11-84.21 *)
val WideString.fromString: string -> WideSubstring.char vector option (* @ $(SML_LIB)/basis/text/string.sml 77.11-77.20 *)
val WideString.implode: WideSubstring.char list -> WideSubstring.char vector (* @ $(SML_LIB)/basis/text/string.sml 36.11-36.17 *)
val WideString.isPrefix: WideSubstring.char vector -> WideSubstring.char vector -> bool (* @ $(SML_LIB)/basis/text/string.sml 48.13-48.20 *)
val WideString.isSubstring: WideSubstring.char vector -> WideSubstring.char vector -> bool (* @ $(SML_LIB)/basis/text/string.sml 49.13-49.23 *)
val WideString.isSuffix: WideSubstring.char vector -> WideSubstring.char vector -> bool (* @ $(SML_LIB)/basis/text/string.sml 50.13-50.20 *)
val WideString.map: (WideSubstring.char -> WideSubstring.char) -> WideSubstring.char vector -> WideSubstring.char vector (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 466.13-466.15 *)
val WideString.maxSize: int (* @ $(SML_LIB)/basis/text/string.sml 33.11-33.17 *)
val WideString.scan: ('a -> (char * 'a) option) -> 'a -> (WideSubstring.char vector * 'a) option (* @ $(SML_LIB)/basis/text/string.sml 65.11-65.14 *)
val WideString.size: WideSubstring.char vector -> int (* @ $(SML_LIB)/basis/text/string.sml 34.11-34.14 *)
val WideString.str: WideSubstring.char -> WideSubstring.char vector (* @ $(SML_LIB)/basis/text/string.sml 31.11-31.13 *)
val WideString.sub: WideSubstring.char vector * int -> WideSubstring.char (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 450.13-450.15 *)
val WideString.substring: WideSubstring.char vector * int * int -> WideSubstring.char vector (* @ $(SML_LIB)/basis/text/string.sml 41.11-41.19 *)
val WideString.toCString: WideSubstring.char vector -> string (* @ $(SML_LIB)/basis/text/string.sml 63.11-63.19 *)
val WideString.toString: WideSubstring.char vector -> string (* @ $(SML_LIB)/basis/text/string.sml 62.11-62.18 *)
val WideString.tokens: (WideSubstring.char -> bool) -> WideSubstring.char vector -> WideSubstring.char vector list (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 483.13-483.18 *)
val WideString.translate: (WideSubstring.char -> WideSubstring.char vector) -> WideSubstring.char vector -> WideSubstring.char vector (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 482.13-482.21 *)
structure WideSubstring: SUBSTRING where type char = WideSubstring.char where type string = WideSubstring.char vector where type substring = WideSubstring.substring (* @ $(SML_LIB)/basis/libs/basis-extra/top-level/basis.sml 190.17-190.29 *)
type WideSubstring.char = WideSubstring.char (* @ $(SML_LIB)/basis/text/substring.sml 21.12-21.15 *)
type WideSubstring.string = WideSubstring.char vector (* @ $(SML_LIB)/basis/text/substring.sml 22.12-22.17 *)
type WideSubstring.substring = WideSubstring.substring (* @ $(SML_LIB)/basis/text/substring.sml 23.12-23.20 *)
val WideSubstring.app: (WideSubstring.char -> unit) -> WideSubstring.substring -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 226.17-226.19 *)
val WideSubstring.base: WideSubstring.substring -> WideSubstring.char vector * int * int (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 208.17-208.20 *)
val WideSubstring.collate: (WideSubstring.char * WideSubstring.char -> order) -> WideSubstring.substring * WideSubstring.substring -> order (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 236.17-236.23 *)
val WideSubstring.compare: WideSubstring.substring * WideSubstring.substring -> order (* @ $(SML_LIB)/basis/text/substring.sml 41.11-41.17 *)
val WideSubstring.concat: WideSubstring.substring list -> WideSubstring.char vector (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 240.17-240.22 *)
val WideSubstring.concatWith: WideSubstring.char vector -> WideSubstring.substring list -> WideSubstring.char vector (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 263.17-263.26 *)
val WideSubstring.dropl: (WideSubstring.char -> bool) -> WideSubstring.substring -> WideSubstring.substring (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 407.17-407.21 *)
val WideSubstring.dropr: (WideSubstring.char -> bool) -> WideSubstring.substring -> WideSubstring.substring (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 408.17-408.21 *)
val WideSubstring.explode: WideSubstring.substring -> WideSubstring.char list (* @ $(SML_LIB)/basis/text/substring.sml 32.11-32.17 *)
val WideSubstring.extract: WideSubstring.char vector * int * int option -> WideSubstring.substring (* @ $(SML_LIB)/basis/text/substring.sml 26.11-26.17 *)
val WideSubstring.fields: (WideSubstring.char -> bool) -> WideSubstring.substring -> WideSubstring.substring list (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 437.20-437.25 *)
val WideSubstring.first: WideSubstring.substring -> WideSubstring.char option (* @ $(SML_LIB)/basis/text/substring.sml 30.11-30.15 *)
val WideSubstring.foldl: (WideSubstring.char * 'a -> 'a) -> 'a -> WideSubstring.substring -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 223.17-223.21 *)
val WideSubstring.foldr: (WideSubstring.char * 'a -> 'a) -> 'a -> WideSubstring.substring -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 224.17-224.21 *)
val WideSubstring.full: WideSubstring.char vector -> WideSubstring.substring (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 192.17-192.20 *)
val WideSubstring.getc: WideSubstring.substring -> (WideSubstring.char * WideSubstring.substring) option (* @ $(SML_LIB)/basis/text/substring.sml 29.11-29.14 *)
val WideSubstring.isEmpty: WideSubstring.substring -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 219.17-219.23 *)
val WideSubstring.isPrefix: WideSubstring.char vector -> WideSubstring.substring -> bool (* @ $(SML_LIB)/basis/text/substring.sml 36.13-36.20 *)
val WideSubstring.isSubstring: WideSubstring.char vector -> WideSubstring.substring -> bool (* @ $(SML_LIB)/basis/text/substring.sml 37.13-37.23 *)
val WideSubstring.isSuffix: WideSubstring.char vector -> WideSubstring.substring -> bool (* @ $(SML_LIB)/basis/text/substring.sml 38.13-38.20 *)
val WideSubstring.position: WideSubstring.char vector -> WideSubstring.substring -> WideSubstring.substring * WideSubstring.substring (* @ $(SML_LIB)/basis/text/substring.sml 39.13-39.20 *)
val WideSubstring.size: WideSubstring.substring -> int (* @ $(SML_LIB)/basis/text/substring.sml 25.11-25.14 *)
val WideSubstring.slice: WideSubstring.substring * int * int option -> WideSubstring.substring (* @ $(SML_LIB)/basis/text/substring.sml 31.11-31.15 *)
val WideSubstring.span: WideSubstring.substring * WideSubstring.substring -> WideSubstring.substring (* @ $(SML_LIB)/basis/arrays-and-vectors/vector.sml 24.17-24.20 *)
val WideSubstring.splitAt: WideSubstring.substring * int -> WideSubstring.substring * WideSubstring.substring (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 402.17-402.23 *)
val WideSubstring.splitl: (WideSubstring.char -> bool) -> WideSubstring.substring -> WideSubstring.substring * WideSubstring.substring (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 400.17-400.22 *)
val WideSubstring.splitr: (WideSubstring.char -> bool) -> WideSubstring.substring -> WideSubstring.substring * WideSubstring.substring (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 401.17-401.22 *)
val WideSubstring.string: WideSubstring.substring -> WideSubstring.char vector (* @ $(SML_LIB)/basis/text/substring.sml 28.11-28.16 *)
val WideSubstring.sub: WideSubstring.substring * int -> WideSubstring.char (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 142.17-142.19 *)
val WideSubstring.substring: WideSubstring.char vector * int * int -> WideSubstring.substring (* @ $(SML_LIB)/basis/text/substring.sml 27.11-27.19 *)
val WideSubstring.takel: (WideSubstring.char -> bool) -> WideSubstring.substring -> WideSubstring.substring (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 409.17-409.21 *)
val WideSubstring.taker: (WideSubstring.char -> bool) -> WideSubstring.substring -> WideSubstring.substring (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 410.17-410.21 *)
val WideSubstring.tokens: (WideSubstring.char -> bool) -> WideSubstring.substring -> WideSubstring.substring list (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 429.20-429.25 *)
val WideSubstring.translate: (WideSubstring.char -> WideSubstring.char vector) -> WideSubstring.substring -> WideSubstring.char vector (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 412.17-412.25 *)
val WideSubstring.triml: int -> WideSubstring.substring -> WideSubstring.substring (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 301.17-301.21 *)
val WideSubstring.trimr: int -> WideSubstring.substring -> WideSubstring.substring (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 317.17-317.21 *)
structure WideText: TEXT where type Char.char = WideSubstring.char where type Char.string = WideSubstring.char vector where type CharArray.array = WideCharArraySlice.array where type CharArraySlice.slice = WideCharArraySlice.slice where type CharArraySlice.vector_slice = WideSubstring.substring where type Substring.substring = WideSubstring.substring (* @ $(SML_LIB)/basis/libs/basis-extra/top-level/basis.sml 191.17-191.24 *)
structure WideText.Char: CHAR where type char = WideSubstring.char where type string = WideSubstring.char vector (* @ $(SML_LIB)/basis/text/text.sml 21.17-21.20 *)
type WideText.Char.char = WideSubstring.char (* @ $(SML_LIB)/basis/primitive/prim-basis.sml 67.12-67.15 *)
type WideText.Char.string = WideSubstring.char vector (* @ $(SML_LIB)/basis/text/char.sml 25.12-25.17 *)
val WideText.Char.< : WideSubstring.char * WideSubstring.char -> bool (* @ $(SML_LIB)/basis/util/integral-comparisons.sml 11.11-11.11 *)
val WideText.Char.<= : WideSubstring.char * WideSubstring.char -> bool (* @ $(SML_LIB)/basis/util/integral-comparisons.sml 12.11-12.12 *)
val WideText.Char.> : WideSubstring.char * WideSubstring.char -> bool (* @ $(SML_LIB)/basis/util/integral-comparisons.sml 13.11-13.11 *)
val WideText.Char.>= : WideSubstring.char * WideSubstring.char -> bool (* @ $(SML_LIB)/basis/util/integral-comparisons.sml 14.11-14.12 *)
val WideText.Char.chr: int -> WideSubstring.char (* @ $(SML_LIB)/basis/text/char.sml 50.11-50.13 *)
val WideText.Char.compare: WideSubstring.char * WideSubstring.char -> order (* @ $(SML_LIB)/basis/util/integral-comparisons.sml 16.11-16.17 *)
val WideText.Char.contains: WideSubstring.char vector -> WideSubstring.char -> bool (* @ $(SML_LIB)/basis/text/char.sml 59.11-59.18 *)
val WideText.Char.fromCString: string -> WideSubstring.char option (* @ $(SML_LIB)/basis/text/char.sml 272.11-272.21 *)
val WideText.Char.fromString: string -> WideSubstring.char option (* @ $(SML_LIB)/basis/text/char.sml 217.11-217.20 *)
val WideText.Char.isAlpha: WideSubstring.char -> bool (* @ $(SML_LIB)/basis/text/char.sml 90.11-90.17 *)
val WideText.Char.isAlphaNum: WideSubstring.char -> bool (* @ $(SML_LIB)/basis/text/char.sml 91.11-91.20 *)
val WideText.Char.isAscii: WideSubstring.char -> bool (* @ $(SML_LIB)/basis/text/char.sml 87.11-87.17 *)
val WideText.Char.isCntrl: WideSubstring.char -> bool (* @ $(SML_LIB)/basis/text/char.sml 86.11-86.17 *)
val WideText.Char.isDigit: WideSubstring.char -> bool (* @ $(SML_LIB)/basis/text/char.sml 83.11-83.17 *)
val WideText.Char.isGraph: WideSubstring.char -> bool (* @ $(SML_LIB)/basis/text/char.sml 84.11-84.17 *)
val WideText.Char.isHexDigit: WideSubstring.char -> bool (* @ $(SML_LIB)/basis/text/char.sml 96.11-96.20 *)
val WideText.Char.isLower: WideSubstring.char -> bool (* @ $(SML_LIB)/basis/text/char.sml 81.11-81.17 *)
val WideText.Char.isPrint: WideSubstring.char -> bool (* @ $(SML_LIB)/basis/text/char.sml 85.11-85.17 *)
val WideText.Char.isPunct: WideSubstring.char -> bool (* @ $(SML_LIB)/basis/text/char.sml 102.11-102.17 *)
val WideText.Char.isSpace: WideSubstring.char -> bool (* @ $(SML_LIB)/basis/text/char.sml 101.11-101.17 *)
val WideText.Char.isUpper: WideSubstring.char -> bool (* @ $(SML_LIB)/basis/text/char.sml 82.11-82.17 *)
val WideText.Char.maxChar: WideSubstring.char (* @ $(SML_LIB)/basis/text/char0.sml 72.44-72.50 *)
val WideText.Char.maxOrd: int (* @ $(SML_LIB)/basis/text/char.sml 26.11-26.16 *)
val WideText.Char.minChar: WideSubstring.char (* @ $(SML_LIB)/basis/text/char0.sml 72.35-72.41 *)
val WideText.Char.notContains: WideSubstring.char vector -> WideSubstring.char -> bool (* @ $(SML_LIB)/basis/text/char.sml 74.11-74.21 *)
val WideText.Char.ord: WideSubstring.char -> int (* @ $(SML_LIB)/basis/text/char0.sml 72.30-72.32 *)
val WideText.Char.pred: WideSubstring.char -> WideSubstring.char (* @ $(SML_LIB)/basis/text/char.sml 38.11-38.14 *)
val WideText.Char.scan: ('a -> (char * 'a) option) -> 'a -> (WideSubstring.char * 'a) option (* @ $(SML_LIB)/basis/text/char.sml 160.14-160.17 *)
val WideText.Char.succ: WideSubstring.char -> WideSubstring.char (* @ $(SML_LIB)/basis/text/char.sml 32.11-32.14 *)
val WideText.Char.toCString: WideSubstring.char -> string (* @ $(SML_LIB)/basis/text/char.sml 324.11-324.19 *)
val WideText.Char.toLower: WideSubstring.char -> WideSubstring.char (* @ $(SML_LIB)/basis/text/char.sml 109.14-109.20 *)
val WideText.Char.toString: WideSubstring.char -> string (* @ $(SML_LIB)/basis/text/char.sml 292.11-292.18 *)
val WideText.Char.toUpper: WideSubstring.char -> WideSubstring.char (* @ $(SML_LIB)/basis/text/char.sml 110.14-110.20 *)
structure WideText.CharArray: MONO_ARRAY where type array = WideCharArraySlice.array where type elem = WideSubstring.char where type vector = WideSubstring.char vector (* @ $(SML_LIB)/basis/text/text.sml 22.17-22.25 *)
type WideText.CharArray.array = WideCharArraySlice.array (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array.fun 23.12-23.16 *)
type WideText.CharArray.elem = WideSubstring.char (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array.fun 22.12-22.15 *)
type WideText.CharArray.vector = WideSubstring.char vector (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array.fun 24.12-24.17 *)
val WideText.CharArray.all: (WideSubstring.char -> bool) -> WideCharArraySlice.array -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 476.13-476.15 *)
val WideText.CharArray.app: (WideSubstring.char -> unit) -> WideCharArraySlice.array -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 464.13-464.15 *)
val WideText.CharArray.appi: (int * WideSubstring.char -> unit) -> WideCharArraySlice.array -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 463.13-463.16 *)
val WideText.CharArray.array: int * WideSubstring.char -> WideCharArraySlice.array (* @ $(SML_LIB)/basis/arrays-and-vectors/array.sml 34.11-34.15 *)
val WideText.CharArray.collate: (WideSubstring.char * WideSubstring.char -> order) -> WideCharArraySlice.array * WideCharArraySlice.array -> order (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 477.13-477.19 *)
val WideText.CharArray.copy: {di: int, dst: WideCharArraySlice.array, src: WideCharArraySlice.array} -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 457.13-457.16 *)
val WideText.CharArray.copyVec: {di: int, dst: WideCharArraySlice.array, src: WideSubstring.char vector} -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array.sml 37.11-37.17 *)
val WideText.CharArray.exists: (WideSubstring.char -> bool) -> WideCharArraySlice.array -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 474.13-474.18 *)
val WideText.CharArray.find: (WideSubstring.char -> bool) -> WideCharArraySlice.array -> WideSubstring.char option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 472.13-472.16 *)
val WideText.CharArray.findi: (int * WideSubstring.char -> bool) -> WideCharArraySlice.array -> (int * WideSubstring.char) option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 471.13-471.17 *)
val WideText.CharArray.foldl: (WideSubstring.char * 'a -> 'a) -> 'a -> WideCharArraySlice.array -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 468.13-468.17 *)
val WideText.CharArray.foldli: (int * WideSubstring.char * 'a -> 'a) -> 'a -> WideCharArraySlice.array -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 467.13-467.18 *)
val WideText.CharArray.foldr: (WideSubstring.char * 'a -> 'a) -> 'a -> WideCharArraySlice.array -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 470.13-470.17 *)
val WideText.CharArray.foldri: (int * WideSubstring.char * 'a -> 'a) -> 'a -> WideCharArraySlice.array -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 469.13-469.18 *)
val WideText.CharArray.fromList: WideSubstring.char list -> WideCharArraySlice.array (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 122.11-122.18 *)
val WideText.CharArray.length: WideCharArraySlice.array -> int (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 90.11-90.16 *)
val WideText.CharArray.maxLen: int (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 88.11-88.16 *)
val WideText.CharArray.modify: (WideSubstring.char -> WideSubstring.char) -> WideCharArraySlice.array -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array.sml 40.11-40.16 *)
val WideText.CharArray.modifyi: (int * WideSubstring.char -> WideSubstring.char) -> WideCharArraySlice.array -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array.sml 39.11-39.17 *)
val WideText.CharArray.sub: WideCharArraySlice.array * int -> WideSubstring.char (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 450.13-450.15 *)
val WideText.CharArray.tabulate: int * (int -> WideSubstring.char) -> WideCharArraySlice.array (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 114.11-114.18 *)
val WideText.CharArray.update: WideCharArraySlice.array * int * WideSubstring.char -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 452.13-452.18 *)
val WideText.CharArray.vector: WideCharArraySlice.array -> WideSubstring.char vector (* @ $(SML_LIB)/basis/arrays-and-vectors/array.sml 36.11-36.16 *)
structure WideText.CharArraySlice: MONO_ARRAY_SLICE where type array = WideCharArraySlice.array where type elem = WideSubstring.char where type slice = WideCharArraySlice.slice where type vector = WideSubstring.char vector where type vector_slice = WideSubstring.substring (* @ $(SML_LIB)/basis/text/text.sml 23.17-23.30 *)
type WideText.CharArraySlice.array = WideCharArraySlice.array (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array.fun 35.18-35.22 *)
type WideText.CharArraySlice.elem = WideSubstring.char (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array.fun 34.18-34.21 *)
type WideText.CharArraySlice.slice = WideCharArraySlice.slice (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array.fun 36.18-36.22 *)
type WideText.CharArraySlice.vector = WideSubstring.char vector (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array.fun 37.18-37.23 *)
type WideText.CharArraySlice.vector_slice = WideSubstring.substring (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array.fun 38.18-38.29 *)
val WideText.CharArraySlice.all: (WideSubstring.char -> bool) -> WideCharArraySlice.slice -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 235.17-235.19 *)
val WideText.CharArraySlice.app: (WideSubstring.char -> unit) -> WideCharArraySlice.slice -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 226.17-226.19 *)
val WideText.CharArraySlice.appi: (int * WideSubstring.char -> unit) -> WideCharArraySlice.slice -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 225.17-225.20 *)
val WideText.CharArraySlice.base: WideCharArraySlice.slice -> WideCharArraySlice.array * int * int (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 208.17-208.20 *)
val WideText.CharArraySlice.collate: (WideSubstring.char * WideSubstring.char -> order) -> WideCharArraySlice.slice * WideCharArraySlice.slice -> order (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 236.17-236.23 *)
val WideText.CharArraySlice.copy: {di: int, dst: WideCharArraySlice.array, src: WideCharArraySlice.slice} -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 185.17-185.20 *)
val WideText.CharArraySlice.copyVec: {di: int, dst: WideCharArraySlice.array, src: WideSubstring.substring} -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array.sml 28.17-28.23 *)
val WideText.CharArraySlice.exists: (WideSubstring.char -> bool) -> WideCharArraySlice.slice -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 233.17-233.22 *)
val WideText.CharArraySlice.find: (WideSubstring.char -> bool) -> WideCharArraySlice.slice -> WideSubstring.char option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 231.17-231.20 *)
val WideText.CharArraySlice.findi: (int * WideSubstring.char -> bool) -> WideCharArraySlice.slice -> (int * WideSubstring.char) option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 229.17-229.21 *)
val WideText.CharArraySlice.foldl: (WideSubstring.char * 'a -> 'a) -> 'a -> WideCharArraySlice.slice -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 223.17-223.21 *)
val WideText.CharArraySlice.foldli: (int * WideSubstring.char * 'a -> 'a) -> 'a -> WideCharArraySlice.slice -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 221.17-221.22 *)
val WideText.CharArraySlice.foldr: (WideSubstring.char * 'a -> 'a) -> 'a -> WideCharArraySlice.slice -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 224.17-224.21 *)
val WideText.CharArraySlice.foldri: (int * WideSubstring.char * 'a -> 'a) -> 'a -> WideCharArraySlice.slice -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 222.17-222.22 *)
val WideText.CharArraySlice.full: WideCharArraySlice.array -> WideCharArraySlice.slice (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 192.17-192.20 *)
val WideText.CharArraySlice.getItem: WideCharArraySlice.slice -> (WideSubstring.char * WideCharArraySlice.slice) option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 220.17-220.23 *)
val WideText.CharArraySlice.isEmpty: WideCharArraySlice.slice -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 219.17-219.23 *)
val WideText.CharArraySlice.length: WideCharArraySlice.slice -> int (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 134.17-134.22 *)
val WideText.CharArraySlice.modify: (WideSubstring.char -> WideSubstring.char) -> WideCharArraySlice.slice -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array.sml 31.17-31.22 *)
val WideText.CharArraySlice.modifyi: (int * WideSubstring.char -> WideSubstring.char) -> WideCharArraySlice.slice -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array.sml 30.17-30.23 *)
val WideText.CharArraySlice.slice: WideCharArraySlice.array * int * int option -> WideCharArraySlice.slice (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 206.17-206.21 *)
val WideText.CharArraySlice.sub: WideCharArraySlice.slice * int -> WideSubstring.char (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 142.17-142.19 *)
val WideText.CharArraySlice.subslice: WideCharArraySlice.slice * int * int option -> WideCharArraySlice.slice (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 199.17-199.24 *)
val WideText.CharArraySlice.update: WideCharArraySlice.slice * int * WideSubstring.char -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 155.17-155.22 *)
val WideText.CharArraySlice.vector: WideCharArraySlice.slice -> WideSubstring.char vector (* @ $(SML_LIB)/basis/arrays-and-vectors/array.sml 27.17-27.22 *)
structure WideText.CharVector: MONO_VECTOR where type elem = WideSubstring.char where type vector = WideSubstring.char vector (* @ $(SML_LIB)/basis/text/text.sml 24.17-24.26 *)
type WideText.CharVector.elem = WideSubstring.char (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-vector.fun 35.12-35.15 *)
type WideText.CharVector.vector = WideSubstring.char vector (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-vector.fun 36.12-36.17 *)
val WideText.CharVector.all: (WideSubstring.char -> bool) -> WideSubstring.char vector -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 476.13-476.15 *)
val WideText.CharVector.app: (WideSubstring.char -> unit) -> WideSubstring.char vector -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 464.13-464.15 *)
val WideText.CharVector.appi: (int * WideSubstring.char -> unit) -> WideSubstring.char vector -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 463.13-463.16 *)
val WideText.CharVector.collate: (WideSubstring.char * WideSubstring.char -> order) -> WideSubstring.char vector * WideSubstring.char vector -> order (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 477.13-477.19 *)
val WideText.CharVector.concat: WideSubstring.char vector list -> WideSubstring.char vector (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 462.13-462.18 *)
val WideText.CharVector.exists: (WideSubstring.char -> bool) -> WideSubstring.char vector -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 474.13-474.18 *)
val WideText.CharVector.find: (WideSubstring.char -> bool) -> WideSubstring.char vector -> WideSubstring.char option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 472.13-472.16 *)
val WideText.CharVector.findi: (int * WideSubstring.char -> bool) -> WideSubstring.char vector -> (int * WideSubstring.char) option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 471.13-471.17 *)
val WideText.CharVector.foldl: (WideSubstring.char * 'a -> 'a) -> 'a -> WideSubstring.char vector -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 468.13-468.17 *)
val WideText.CharVector.foldli: (int * WideSubstring.char * 'a -> 'a) -> 'a -> WideSubstring.char vector -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 467.13-467.18 *)
val WideText.CharVector.foldr: (WideSubstring.char * 'a -> 'a) -> 'a -> WideSubstring.char vector -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 470.13-470.17 *)
val WideText.CharVector.foldri: (int * WideSubstring.char * 'a -> 'a) -> 'a -> WideSubstring.char vector -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 469.13-469.18 *)
val WideText.CharVector.fromList: WideSubstring.char list -> WideSubstring.char vector (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 122.11-122.18 *)
val WideText.CharVector.length: WideSubstring.char vector -> int (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 90.11-90.16 *)
val WideText.CharVector.map: (WideSubstring.char -> WideSubstring.char) -> WideSubstring.char vector -> WideSubstring.char vector (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 466.13-466.15 *)
val WideText.CharVector.mapi: (int * WideSubstring.char -> WideSubstring.char) -> WideSubstring.char vector -> WideSubstring.char vector (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 465.13-465.16 *)
val WideText.CharVector.maxLen: int (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 88.11-88.16 *)
val WideText.CharVector.sub: WideSubstring.char vector * int -> WideSubstring.char (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 450.13-450.15 *)
val WideText.CharVector.tabulate: int * (int -> WideSubstring.char) -> WideSubstring.char vector (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 114.11-114.18 *)
val WideText.CharVector.update: WideSubstring.char vector * int * WideSubstring.char -> WideSubstring.char vector (* @ $(SML_LIB)/basis/arrays-and-vectors/vector.sml 30.11-30.16 *)
structure WideText.CharVectorSlice: MONO_VECTOR_SLICE where type elem = WideSubstring.char where type slice = WideSubstring.substring where type vector = WideSubstring.char vector (* @ $(SML_LIB)/basis/text/text.sml 25.17-25.31 *)
type WideText.CharVectorSlice.elem = WideSubstring.char (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-vector.fun 43.18-43.21 *)
type WideText.CharVectorSlice.slice = WideSubstring.substring (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-vector.fun 45.18-45.22 *)
type WideText.CharVectorSlice.vector = WideSubstring.char vector (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-vector.fun 44.18-44.23 *)
val WideText.CharVectorSlice.all: (WideSubstring.char -> bool) -> WideSubstring.substring -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 235.17-235.19 *)
val WideText.CharVectorSlice.app: (WideSubstring.char -> unit) -> WideSubstring.substring -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 226.17-226.19 *)
val WideText.CharVectorSlice.appi: (int * WideSubstring.char -> unit) -> WideSubstring.substring -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 225.17-225.20 *)
val WideText.CharVectorSlice.base: WideSubstring.substring -> WideSubstring.char vector * int * int (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 208.17-208.20 *)
val WideText.CharVectorSlice.collate: (WideSubstring.char * WideSubstring.char -> order) -> WideSubstring.substring * WideSubstring.substring -> order (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 236.17-236.23 *)
val WideText.CharVectorSlice.concat: WideSubstring.substring list -> WideSubstring.char vector (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 240.17-240.22 *)
val WideText.CharVectorSlice.exists: (WideSubstring.char -> bool) -> WideSubstring.substring -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 233.17-233.22 *)
val WideText.CharVectorSlice.find: (WideSubstring.char -> bool) -> WideSubstring.substring -> WideSubstring.char option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 231.17-231.20 *)
val WideText.CharVectorSlice.findi: (int * WideSubstring.char -> bool) -> WideSubstring.substring -> (int * WideSubstring.char) option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 229.17-229.21 *)
val WideText.CharVectorSlice.foldl: (WideSubstring.char * 'a -> 'a) -> 'a -> WideSubstring.substring -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 223.17-223.21 *)
val WideText.CharVectorSlice.foldli: (int * WideSubstring.char * 'a -> 'a) -> 'a -> WideSubstring.substring -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 221.17-221.22 *)
val WideText.CharVectorSlice.foldr: (WideSubstring.char * 'a -> 'a) -> 'a -> WideSubstring.substring -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 224.17-224.21 *)
val WideText.CharVectorSlice.foldri: (int * WideSubstring.char * 'a -> 'a) -> 'a -> WideSubstring.substring -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 222.17-222.22 *)
val WideText.CharVectorSlice.full: WideSubstring.char vector -> WideSubstring.substring (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 192.17-192.20 *)
val WideText.CharVectorSlice.getItem: WideSubstring.substring -> (WideSubstring.char * WideSubstring.substring) option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 220.17-220.23 *)
val WideText.CharVectorSlice.isEmpty: WideSubstring.substring -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 219.17-219.23 *)
val WideText.CharVectorSlice.length: WideSubstring.substring -> int (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 134.17-134.22 *)
val WideText.CharVectorSlice.map: (WideSubstring.char -> WideSubstring.char) -> WideSubstring.substring -> WideSubstring.char vector (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 228.17-228.19 *)
val WideText.CharVectorSlice.mapi: (int * WideSubstring.char -> WideSubstring.char) -> WideSubstring.substring -> WideSubstring.char vector (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 227.17-227.20 *)
val WideText.CharVectorSlice.slice: WideSubstring.char vector * int * int option -> WideSubstring.substring (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 206.17-206.21 *)
val WideText.CharVectorSlice.sub: WideSubstring.substring * int -> WideSubstring.char (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 142.17-142.19 *)
val WideText.CharVectorSlice.subslice: WideSubstring.substring * int * int option -> WideSubstring.substring (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 199.17-199.24 *)
val WideText.CharVectorSlice.vector: WideSubstring.substring -> WideSubstring.char vector (* @ $(SML_LIB)/basis/arrays-and-vectors/vector.sml 21.17-21.22 *)
structure WideText.String: STRING where type char = WideSubstring.char where type string = WideSubstring.char vector (* @ $(SML_LIB)/basis/text/text.sml 26.17-26.22 *)
type WideText.String.char = WideSubstring.char (* @ $(SML_LIB)/basis/text/string.sml 27.12-27.15 *)
type WideText.String.string = WideSubstring.char vector (* @ $(SML_LIB)/basis/text/string.sml 28.12-28.17 *)
val WideText.String.< : WideSubstring.char vector * WideSubstring.char vector -> bool (* @ $(SML_LIB)/basis/util/string-comparisons.sml 12.11-12.11 *)
val WideText.String.<= : WideSubstring.char vector * WideSubstring.char vector -> bool (* @ $(SML_LIB)/basis/util/string-comparisons.sml 16.11-16.12 *)
val WideText.String.> : WideSubstring.char vector * WideSubstring.char vector -> bool (* @ $(SML_LIB)/basis/util/string-comparisons.sml 20.11-20.11 *)
val WideText.String.>= : WideSubstring.char vector * WideSubstring.char vector -> bool (* @ $(SML_LIB)/basis/util/string-comparisons.sml 24.11-24.12 *)
val WideText.String.^ : WideSubstring.char vector * WideSubstring.char vector -> WideSubstring.char vector (* @ $(SML_LIB)/basis/text/string.sml 35.14-35.14 *)
val WideText.String.collate: (WideSubstring.char * WideSubstring.char -> order) -> WideSubstring.char vector * WideSubstring.char vector -> order (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 477.13-477.19 *)
val WideText.String.compare: WideSubstring.char vector * WideSubstring.char vector -> order (* @ $(SML_LIB)/basis/text/string.sml 52.11-52.17 *)
val WideText.String.concat: WideSubstring.char vector list -> WideSubstring.char vector (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 462.13-462.18 *)
val WideText.String.concatWith: WideSubstring.char vector -> WideSubstring.char vector list -> WideSubstring.char vector (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 478.13-478.22 *)
val WideText.String.explode: WideSubstring.char vector -> WideSubstring.char list (* @ $(SML_LIB)/basis/text/string.sml 37.11-37.17 *)
val WideText.String.extract: WideSubstring.char vector * int * int option -> WideSubstring.char vector (* @ $(SML_LIB)/basis/text/string.sml 39.11-39.17 *)
val WideText.String.fields: (WideSubstring.char -> bool) -> WideSubstring.char vector -> WideSubstring.char vector list (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 484.13-484.18 *)
val WideText.String.fromCString: string -> WideSubstring.char vector option (* @ $(SML_LIB)/basis/text/string.sml 84.11-84.21 *)
val WideText.String.fromString: string -> WideSubstring.char vector option (* @ $(SML_LIB)/basis/text/string.sml 77.11-77.20 *)
val WideText.String.implode: WideSubstring.char list -> WideSubstring.char vector (* @ $(SML_LIB)/basis/text/string.sml 36.11-36.17 *)
val WideText.String.isPrefix: WideSubstring.char vector -> WideSubstring.char vector -> bool (* @ $(SML_LIB)/basis/text/string.sml 48.13-48.20 *)
val WideText.String.isSubstring: WideSubstring.char vector -> WideSubstring.char vector -> bool (* @ $(SML_LIB)/basis/text/string.sml 49.13-49.23 *)
val WideText.String.isSuffix: WideSubstring.char vector -> WideSubstring.char vector -> bool (* @ $(SML_LIB)/basis/text/string.sml 50.13-50.20 *)
val WideText.String.map: (WideSubstring.char -> WideSubstring.char) -> WideSubstring.char vector -> WideSubstring.char vector (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 466.13-466.15 *)
val WideText.String.maxSize: int (* @ $(SML_LIB)/basis/text/string.sml 33.11-33.17 *)
val WideText.String.scan: ('a -> (char * 'a) option) -> 'a -> (WideSubstring.char vector * 'a) option (* @ $(SML_LIB)/basis/text/string.sml 65.11-65.14 *)
val WideText.String.size: WideSubstring.char vector -> int (* @ $(SML_LIB)/basis/text/string.sml 34.11-34.14 *)
val WideText.String.str: WideSubstring.char -> WideSubstring.char vector (* @ $(SML_LIB)/basis/text/string.sml 31.11-31.13 *)
val WideText.String.sub: WideSubstring.char vector * int -> WideSubstring.char (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 450.13-450.15 *)
val WideText.String.substring: WideSubstring.char vector * int * int -> WideSubstring.char vector (* @ $(SML_LIB)/basis/text/string.sml 41.11-41.19 *)
val WideText.String.toCString: WideSubstring.char vector -> string (* @ $(SML_LIB)/basis/text/string.sml 63.11-63.19 *)
val WideText.String.toString: WideSubstring.char vector -> string (* @ $(SML_LIB)/basis/text/string.sml 62.11-62.18 *)
val WideText.String.tokens: (WideSubstring.char -> bool) -> WideSubstring.char vector -> WideSubstring.char vector list (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 483.13-483.18 *)
val WideText.String.translate: (WideSubstring.char -> WideSubstring.char vector) -> WideSubstring.char vector -> WideSubstring.char vector (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 482.13-482.21 *)
structure WideText.Substring: SUBSTRING where type char = WideSubstring.char where type string = WideSubstring.char vector where type substring = WideSubstring.substring (* @ $(SML_LIB)/basis/text/text.sml 27.17-27.25 *)
type WideText.Substring.char = WideSubstring.char (* @ $(SML_LIB)/basis/text/substring.sml 21.12-21.15 *)
type WideText.Substring.string = WideSubstring.char vector (* @ $(SML_LIB)/basis/text/substring.sml 22.12-22.17 *)
type WideText.Substring.substring = WideSubstring.substring (* @ $(SML_LIB)/basis/text/substring.sml 23.12-23.20 *)
val WideText.Substring.app: (WideSubstring.char -> unit) -> WideSubstring.substring -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 226.17-226.19 *)
val WideText.Substring.base: WideSubstring.substring -> WideSubstring.char vector * int * int (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 208.17-208.20 *)
val WideText.Substring.collate: (WideSubstring.char * WideSubstring.char -> order) -> WideSubstring.substring * WideSubstring.substring -> order (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 236.17-236.23 *)
val WideText.Substring.compare: WideSubstring.substring * WideSubstring.substring -> order (* @ $(SML_LIB)/basis/text/substring.sml 41.11-41.17 *)
val WideText.Substring.concat: WideSubstring.substring list -> WideSubstring.char vector (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 240.17-240.22 *)
val WideText.Substring.concatWith: WideSubstring.char vector -> WideSubstring.substring list -> WideSubstring.char vector (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 263.17-263.26 *)
val WideText.Substring.dropl: (WideSubstring.char -> bool) -> WideSubstring.substring -> WideSubstring.substring (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 407.17-407.21 *)
val WideText.Substring.dropr: (WideSubstring.char -> bool) -> WideSubstring.substring -> WideSubstring.substring (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 408.17-408.21 *)
val WideText.Substring.explode: WideSubstring.substring -> WideSubstring.char list (* @ $(SML_LIB)/basis/text/substring.sml 32.11-32.17 *)
val WideText.Substring.extract: WideSubstring.char vector * int * int option -> WideSubstring.substring (* @ $(SML_LIB)/basis/text/substring.sml 26.11-26.17 *)
val WideText.Substring.fields: (WideSubstring.char -> bool) -> WideSubstring.substring -> WideSubstring.substring list (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 437.20-437.25 *)
val WideText.Substring.first: WideSubstring.substring -> WideSubstring.char option (* @ $(SML_LIB)/basis/text/substring.sml 30.11-30.15 *)
val WideText.Substring.foldl: (WideSubstring.char * 'a -> 'a) -> 'a -> WideSubstring.substring -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 223.17-223.21 *)
val WideText.Substring.foldr: (WideSubstring.char * 'a -> 'a) -> 'a -> WideSubstring.substring -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 224.17-224.21 *)
val WideText.Substring.full: WideSubstring.char vector -> WideSubstring.substring (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 192.17-192.20 *)
val WideText.Substring.getc: WideSubstring.substring -> (WideSubstring.char * WideSubstring.substring) option (* @ $(SML_LIB)/basis/text/substring.sml 29.11-29.14 *)
val WideText.Substring.isEmpty: WideSubstring.substring -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 219.17-219.23 *)
val WideText.Substring.isPrefix: WideSubstring.char vector -> WideSubstring.substring -> bool (* @ $(SML_LIB)/basis/text/substring.sml 36.13-36.20 *)
val WideText.Substring.isSubstring: WideSubstring.char vector -> WideSubstring.substring -> bool (* @ $(SML_LIB)/basis/text/substring.sml 37.13-37.23 *)
val WideText.Substring.isSuffix: WideSubstring.char vector -> WideSubstring.substring -> bool (* @ $(SML_LIB)/basis/text/substring.sml 38.13-38.20 *)
val WideText.Substring.position: WideSubstring.char vector -> WideSubstring.substring -> WideSubstring.substring * WideSubstring.substring (* @ $(SML_LIB)/basis/text/substring.sml 39.13-39.20 *)
val WideText.Substring.size: WideSubstring.substring -> int (* @ $(SML_LIB)/basis/text/substring.sml 25.11-25.14 *)
val WideText.Substring.slice: WideSubstring.substring * int * int option -> WideSubstring.substring (* @ $(SML_LIB)/basis/text/substring.sml 31.11-31.15 *)
val WideText.Substring.span: WideSubstring.substring * WideSubstring.substring -> WideSubstring.substring (* @ $(SML_LIB)/basis/arrays-and-vectors/vector.sml 24.17-24.20 *)
val WideText.Substring.splitAt: WideSubstring.substring * int -> WideSubstring.substring * WideSubstring.substring (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 402.17-402.23 *)
val WideText.Substring.splitl: (WideSubstring.char -> bool) -> WideSubstring.substring -> WideSubstring.substring * WideSubstring.substring (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 400.17-400.22 *)
val WideText.Substring.splitr: (WideSubstring.char -> bool) -> WideSubstring.substring -> WideSubstring.substring * WideSubstring.substring (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 401.17-401.22 *)
val WideText.Substring.string: WideSubstring.substring -> WideSubstring.char vector (* @ $(SML_LIB)/basis/text/substring.sml 28.11-28.16 *)
val WideText.Substring.sub: WideSubstring.substring * int -> WideSubstring.char (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 142.17-142.19 *)
val WideText.Substring.substring: WideSubstring.char vector * int * int -> WideSubstring.substring (* @ $(SML_LIB)/basis/text/substring.sml 27.11-27.19 *)
val WideText.Substring.takel: (WideSubstring.char -> bool) -> WideSubstring.substring -> WideSubstring.substring (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 409.17-409.21 *)
val WideText.Substring.taker: (WideSubstring.char -> bool) -> WideSubstring.substring -> WideSubstring.substring (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 410.17-410.21 *)
val WideText.Substring.tokens: (WideSubstring.char -> bool) -> WideSubstring.substring -> WideSubstring.substring list (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 429.20-429.25 *)
val WideText.Substring.translate: (WideSubstring.char -> WideSubstring.char vector) -> WideSubstring.substring -> WideSubstring.char vector (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 412.17-412.25 *)
val WideText.Substring.triml: int -> WideSubstring.substring -> WideSubstring.substring (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 301.17-301.21 *)
val WideText.Substring.trimr: int -> WideSubstring.substring -> WideSubstring.substring (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 317.17-317.21 *)
structure Word: WORD where type word = word (* @ $(SML_LIB)/basis/libs/basis-2002/top-level/top-level.sml 92.11-92.14 *)
type Word.word = word (* @ $(SML_LIB)/basis/primitive/prim-basis.sml 426.12-426.15 *)
val Word.* : word * word -> word (* @ $(SML_LIB)/basis/primitive/prim-word.sml 361.11-361.11 *)
val Word.+ : word * word -> word (* @ $(SML_LIB)/basis/primitive/prim-word.sml 358.11-358.11 *)
val Word.- : word * word -> word (* @ $(SML_LIB)/basis/primitive/prim-word.sml 371.11-371.11 *)
val Word.< : word * word -> bool (* @ $(SML_LIB)/basis/util/integral-comparisons.sml 11.11-11.11 *)
val Word.<< : word * word -> word (* @ $(SML_LIB)/basis/integer/word.sml 19.5-19.6 *)
val Word.<= : word * word -> bool (* @ $(SML_LIB)/basis/util/integral-comparisons.sml 12.11-12.12 *)
val Word.> : word * word -> bool (* @ $(SML_LIB)/basis/util/integral-comparisons.sml 13.11-13.11 *)
val Word.>= : word * word -> bool (* @ $(SML_LIB)/basis/util/integral-comparisons.sml 14.11-14.12 *)
val Word.>> : word * word -> word (* @ $(SML_LIB)/basis/integer/word.sml 23.5-23.6 *)
val Word.andb: word * word -> word (* @ $(SML_LIB)/basis/primitive/prim-word.sml 359.11-359.14 *)
val Word.compare: word * word -> order (* @ $(SML_LIB)/basis/util/integral-comparisons.sml 16.11-16.17 *)
val Word.div: word * word -> word (* @ $(SML_LIB)/basis/integer/num0.sml 97.23-97.25 *)
val Word.fmt: StringCvt.radix -> word -> string (* @ $(SML_LIB)/basis/integer/word.sml 104.8-104.10 *)
val Word.fromInt: int -> word (* @ $(SML_LIB)/basis/integer/word.sml 55.5-55.11 *)
val Word.fromLarge: LargeWord.word -> word (* @ $(SML_LIB)/basis/integer/word.sml 87.5-87.13 *)
val Word.fromLargeInt: LargeInt.int -> word (* @ $(SML_LIB)/basis/integer/word.sml 70.5-70.16 *)
val Word.fromLargeWord: LargeWord.word -> word (* @ $(SML_LIB)/basis/integer/word.sml 86.5-86.17 *)
val Word.fromString: string -> word option (* @ $(SML_LIB)/basis/integer/word.sml 209.5-209.14 *)
val Word.max: word * word -> word (* @ $(SML_LIB)/basis/util/integral-comparisons.sml 21.11-21.13 *)
val Word.min: word * word -> word (* @ $(SML_LIB)/basis/util/integral-comparisons.sml 20.11-20.13 *)
val Word.mod: word * word -> word (* @ $(SML_LIB)/basis/integer/num0.sml 98.23-98.25 *)
val Word.notb: word -> word (* @ $(SML_LIB)/basis/primitive/prim-word.sml 363.11-363.14 *)
val Word.orb: word * word -> word (* @ $(SML_LIB)/basis/primitive/prim-word.sml 364.11-364.13 *)
val Word.scan: StringCvt.radix -> ('a -> (char * 'a) option) -> 'a -> (word * 'a) option (* @ $(SML_LIB)/basis/integer/word.sml 146.5-146.8 *)
val Word.toInt: word -> int (* @ $(SML_LIB)/basis/integer/word.sml 57.5-57.9 *)
val Word.toIntX: word -> int (* @ $(SML_LIB)/basis/integer/word.sml 56.5-56.10 *)
val Word.toLarge: word -> LargeWord.word (* @ $(SML_LIB)/basis/integer/word.sml 91.5-91.11 *)
val Word.toLargeInt: word -> LargeInt.int (* @ $(SML_LIB)/basis/integer/word.sml 72.5-72.14 *)
val Word.toLargeIntX: word -> LargeInt.int (* @ $(SML_LIB)/basis/integer/word.sml 71.5-71.15 *)
val Word.toLargeWord: word -> LargeWord.word (* @ $(SML_LIB)/basis/integer/word.sml 90.5-90.15 *)
val Word.toLargeWordX: word -> LargeWord.word (* @ $(SML_LIB)/basis/integer/word.sml 88.5-88.16 *)
val Word.toLargeX: word -> LargeWord.word (* @ $(SML_LIB)/basis/integer/word.sml 89.5-89.12 *)
val Word.toString: word -> string (* @ $(SML_LIB)/basis/integer/word.sml 144.5-144.12 *)
val Word.wordSize: int (* @ $(SML_LIB)/basis/integer/word.sml 16.5-16.12 *)
val Word.xorb: word * word -> word (* @ $(SML_LIB)/basis/primitive/prim-word.sml 372.11-372.14 *)
val Word.~ : word -> word (* @ $(SML_LIB)/basis/primitive/prim-word.sml 362.11-362.11 *)
val Word.~>> : word * word -> word (* @ $(SML_LIB)/basis/integer/word.sml 27.5-27.7 *)
structure Word1: WORD where type word = Word1.word (* @ $(SML_LIB)/basis/libs/basis-extra/top-level/basis.sml 199.17-199.21 *)
type Word1.word = Word1.word (* @ $(SML_LIB)/basis/primitive/prim-basis.sml 271.12-271.15 *)
val Word1.* : Word1.word * Word1.word -> Word1.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 62.17-62.17 *)
val Word1.+ : Word1.word * Word1.word -> Word1.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 63.17-63.17 *)
val Word1.- : Word1.word * Word1.word -> Word1.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 64.17-64.17 *)
val Word1.< : Word1.word * Word1.word -> bool (* @ $(SML_LIB)/basis/integer/embed-word.sml 87.17-87.17 *)
val Word1.<< : Word1.word * word -> Word1.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 78.14-78.15 *)
val Word1.<= : Word1.word * Word1.word -> bool (* @ $(SML_LIB)/basis/integer/embed-word.sml 88.17-88.18 *)
val Word1.> : Word1.word * Word1.word -> bool (* @ $(SML_LIB)/basis/integer/embed-word.sml 89.17-89.17 *)
val Word1.>= : Word1.word * Word1.word -> bool (* @ $(SML_LIB)/basis/integer/embed-word.sml 90.17-90.18 *)
val Word1.>> : Word1.word * word -> Word1.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 77.14-77.15 *)
val Word1.andb: Word1.word * Word1.word -> Word1.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 65.14-65.17 *)
val Word1.compare: Word1.word * Word1.word -> order (* @ $(SML_LIB)/basis/integer/embed-word.sml 91.14-91.20 *)
val Word1.div: Word1.word * Word1.word -> Word1.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 66.17-66.19 *)
val Word1.fmt: StringCvt.radix -> Word1.word -> string (* @ $(SML_LIB)/basis/integer/embed-word.sml 129.11-129.13 *)
val Word1.fromInt: int -> Word1.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 105.14-105.20 *)
val Word1.fromLarge: LargeWord.word -> Word1.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 106.14-106.22 *)
val Word1.fromLargeInt: LargeInt.int -> Word1.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 107.14-107.25 *)
val Word1.fromLargeWord: LargeWord.word -> Word1.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 131.11-131.23 *)
val Word1.fromString: string -> Word1.word option (* @ $(SML_LIB)/basis/integer/embed-word.sml 133.11-133.20 *)
val Word1.max: Word1.word * Word1.word -> Word1.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 135.11-135.13 *)
val Word1.min: Word1.word * Word1.word -> Word1.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 137.11-137.13 *)
val Word1.mod: Word1.word * Word1.word -> Word1.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 67.17-67.19 *)
val Word1.notb: Word1.word -> Word1.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 98.14-98.17 *)
val Word1.orb: Word1.word * Word1.word -> Word1.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 68.14-68.16 *)
val Word1.scan: StringCvt.radix -> ('a -> (char * 'a) option) -> 'a -> (Word1.word * 'a) option (* @ $(SML_LIB)/basis/integer/embed-word.sml 139.11-139.14 *)
val Word1.toInt: Word1.word -> int (* @ $(SML_LIB)/basis/integer/embed-word.sml 114.14-114.18 *)
val Word1.toIntX: Word1.word -> int (* @ $(SML_LIB)/basis/integer/embed-word.sml 124.14-124.19 *)
val Word1.toLarge: Word1.word -> LargeWord.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 115.14-115.20 *)
val Word1.toLargeInt: Word1.word -> LargeInt.int (* @ $(SML_LIB)/basis/integer/embed-word.sml 116.14-116.23 *)
val Word1.toLargeIntX: Word1.word -> LargeInt.int (* @ $(SML_LIB)/basis/integer/embed-word.sml 125.14-125.24 *)
val Word1.toLargeWord: Word1.word -> LargeWord.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 144.11-144.21 *)
val Word1.toLargeWordX: Word1.word -> LargeWord.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 146.11-146.22 *)
val Word1.toLargeX: Word1.word -> LargeWord.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 126.14-126.21 *)
val Word1.toString: Word1.word -> string (* @ $(SML_LIB)/basis/integer/embed-word.sml 117.14-117.21 *)
val Word1.wordSize: int (* @ $(SML_LIB)/basis/integer/embed-word.sml 24.17-24.24 *)
val Word1.xorb: Word1.word * Word1.word -> Word1.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 69.14-69.17 *)
val Word1.~ : Word1.word -> Word1.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 148.11-148.11 *)
val Word1.~>> : Word1.word * word -> Word1.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 81.11-81.13 *)
structure Word10: WORD where type word = Word10.word (* @ $(SML_LIB)/basis/libs/basis-extra/top-level/basis.sml 208.17-208.22 *)
type Word10.word = Word10.word (* @ $(SML_LIB)/basis/primitive/prim-basis.sml 316.12-316.15 *)
val Word10.* : Word10.word * Word10.word -> Word10.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 62.17-62.17 *)
val Word10.+ : Word10.word * Word10.word -> Word10.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 63.17-63.17 *)
val Word10.- : Word10.word * Word10.word -> Word10.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 64.17-64.17 *)
val Word10.< : Word10.word * Word10.word -> bool (* @ $(SML_LIB)/basis/integer/embed-word.sml 87.17-87.17 *)
val Word10.<< : Word10.word * word -> Word10.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 78.14-78.15 *)
val Word10.<= : Word10.word * Word10.word -> bool (* @ $(SML_LIB)/basis/integer/embed-word.sml 88.17-88.18 *)
val Word10.> : Word10.word * Word10.word -> bool (* @ $(SML_LIB)/basis/integer/embed-word.sml 89.17-89.17 *)
val Word10.>= : Word10.word * Word10.word -> bool (* @ $(SML_LIB)/basis/integer/embed-word.sml 90.17-90.18 *)
val Word10.>> : Word10.word * word -> Word10.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 77.14-77.15 *)
val Word10.andb: Word10.word * Word10.word -> Word10.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 65.14-65.17 *)
val Word10.compare: Word10.word * Word10.word -> order (* @ $(SML_LIB)/basis/integer/embed-word.sml 91.14-91.20 *)
val Word10.div: Word10.word * Word10.word -> Word10.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 66.17-66.19 *)
val Word10.fmt: StringCvt.radix -> Word10.word -> string (* @ $(SML_LIB)/basis/integer/embed-word.sml 129.11-129.13 *)
val Word10.fromInt: int -> Word10.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 105.14-105.20 *)
val Word10.fromLarge: LargeWord.word -> Word10.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 106.14-106.22 *)
val Word10.fromLargeInt: LargeInt.int -> Word10.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 107.14-107.25 *)
val Word10.fromLargeWord: LargeWord.word -> Word10.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 131.11-131.23 *)
val Word10.fromString: string -> Word10.word option (* @ $(SML_LIB)/basis/integer/embed-word.sml 133.11-133.20 *)
val Word10.max: Word10.word * Word10.word -> Word10.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 135.11-135.13 *)
val Word10.min: Word10.word * Word10.word -> Word10.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 137.11-137.13 *)
val Word10.mod: Word10.word * Word10.word -> Word10.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 67.17-67.19 *)
val Word10.notb: Word10.word -> Word10.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 98.14-98.17 *)
val Word10.orb: Word10.word * Word10.word -> Word10.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 68.14-68.16 *)
val Word10.scan: StringCvt.radix -> ('a -> (char * 'a) option) -> 'a -> (Word10.word * 'a) option (* @ $(SML_LIB)/basis/integer/embed-word.sml 139.11-139.14 *)
val Word10.toInt: Word10.word -> int (* @ $(SML_LIB)/basis/integer/embed-word.sml 114.14-114.18 *)
val Word10.toIntX: Word10.word -> int (* @ $(SML_LIB)/basis/integer/embed-word.sml 124.14-124.19 *)
val Word10.toLarge: Word10.word -> LargeWord.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 115.14-115.20 *)
val Word10.toLargeInt: Word10.word -> LargeInt.int (* @ $(SML_LIB)/basis/integer/embed-word.sml 116.14-116.23 *)
val Word10.toLargeIntX: Word10.word -> LargeInt.int (* @ $(SML_LIB)/basis/integer/embed-word.sml 125.14-125.24 *)
val Word10.toLargeWord: Word10.word -> LargeWord.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 144.11-144.21 *)
val Word10.toLargeWordX: Word10.word -> LargeWord.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 146.11-146.22 *)
val Word10.toLargeX: Word10.word -> LargeWord.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 126.14-126.21 *)
val Word10.toString: Word10.word -> string (* @ $(SML_LIB)/basis/integer/embed-word.sml 117.14-117.21 *)
val Word10.wordSize: int (* @ $(SML_LIB)/basis/integer/embed-word.sml 24.17-24.24 *)
val Word10.xorb: Word10.word * Word10.word -> Word10.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 69.14-69.17 *)
val Word10.~ : Word10.word -> Word10.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 148.11-148.11 *)
val Word10.~>> : Word10.word * word -> Word10.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 81.11-81.13 *)
structure Word11: WORD where type word = Word11.word (* @ $(SML_LIB)/basis/libs/basis-extra/top-level/basis.sml 209.17-209.22 *)
type Word11.word = Word11.word (* @ $(SML_LIB)/basis/primitive/prim-basis.sml 321.12-321.15 *)
val Word11.* : Word11.word * Word11.word -> Word11.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 62.17-62.17 *)
val Word11.+ : Word11.word * Word11.word -> Word11.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 63.17-63.17 *)
val Word11.- : Word11.word * Word11.word -> Word11.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 64.17-64.17 *)
val Word11.< : Word11.word * Word11.word -> bool (* @ $(SML_LIB)/basis/integer/embed-word.sml 87.17-87.17 *)
val Word11.<< : Word11.word * word -> Word11.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 78.14-78.15 *)
val Word11.<= : Word11.word * Word11.word -> bool (* @ $(SML_LIB)/basis/integer/embed-word.sml 88.17-88.18 *)
val Word11.> : Word11.word * Word11.word -> bool (* @ $(SML_LIB)/basis/integer/embed-word.sml 89.17-89.17 *)
val Word11.>= : Word11.word * Word11.word -> bool (* @ $(SML_LIB)/basis/integer/embed-word.sml 90.17-90.18 *)
val Word11.>> : Word11.word * word -> Word11.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 77.14-77.15 *)
val Word11.andb: Word11.word * Word11.word -> Word11.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 65.14-65.17 *)
val Word11.compare: Word11.word * Word11.word -> order (* @ $(SML_LIB)/basis/integer/embed-word.sml 91.14-91.20 *)
val Word11.div: Word11.word * Word11.word -> Word11.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 66.17-66.19 *)
val Word11.fmt: StringCvt.radix -> Word11.word -> string (* @ $(SML_LIB)/basis/integer/embed-word.sml 129.11-129.13 *)
val Word11.fromInt: int -> Word11.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 105.14-105.20 *)
val Word11.fromLarge: LargeWord.word -> Word11.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 106.14-106.22 *)
val Word11.fromLargeInt: LargeInt.int -> Word11.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 107.14-107.25 *)
val Word11.fromLargeWord: LargeWord.word -> Word11.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 131.11-131.23 *)
val Word11.fromString: string -> Word11.word option (* @ $(SML_LIB)/basis/integer/embed-word.sml 133.11-133.20 *)
val Word11.max: Word11.word * Word11.word -> Word11.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 135.11-135.13 *)
val Word11.min: Word11.word * Word11.word -> Word11.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 137.11-137.13 *)
val Word11.mod: Word11.word * Word11.word -> Word11.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 67.17-67.19 *)
val Word11.notb: Word11.word -> Word11.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 98.14-98.17 *)
val Word11.orb: Word11.word * Word11.word -> Word11.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 68.14-68.16 *)
val Word11.scan: StringCvt.radix -> ('a -> (char * 'a) option) -> 'a -> (Word11.word * 'a) option (* @ $(SML_LIB)/basis/integer/embed-word.sml 139.11-139.14 *)
val Word11.toInt: Word11.word -> int (* @ $(SML_LIB)/basis/integer/embed-word.sml 114.14-114.18 *)
val Word11.toIntX: Word11.word -> int (* @ $(SML_LIB)/basis/integer/embed-word.sml 124.14-124.19 *)
val Word11.toLarge: Word11.word -> LargeWord.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 115.14-115.20 *)
val Word11.toLargeInt: Word11.word -> LargeInt.int (* @ $(SML_LIB)/basis/integer/embed-word.sml 116.14-116.23 *)
val Word11.toLargeIntX: Word11.word -> LargeInt.int (* @ $(SML_LIB)/basis/integer/embed-word.sml 125.14-125.24 *)
val Word11.toLargeWord: Word11.word -> LargeWord.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 144.11-144.21 *)
val Word11.toLargeWordX: Word11.word -> LargeWord.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 146.11-146.22 *)
val Word11.toLargeX: Word11.word -> LargeWord.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 126.14-126.21 *)
val Word11.toString: Word11.word -> string (* @ $(SML_LIB)/basis/integer/embed-word.sml 117.14-117.21 *)
val Word11.wordSize: int (* @ $(SML_LIB)/basis/integer/embed-word.sml 24.17-24.24 *)
val Word11.xorb: Word11.word * Word11.word -> Word11.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 69.14-69.17 *)
val Word11.~ : Word11.word -> Word11.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 148.11-148.11 *)
val Word11.~>> : Word11.word * word -> Word11.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 81.11-81.13 *)
structure Word12: WORD where type word = Word12.word (* @ $(SML_LIB)/basis/libs/basis-extra/top-level/basis.sml 210.17-210.22 *)
type Word12.word = Word12.word (* @ $(SML_LIB)/basis/primitive/prim-basis.sml 326.12-326.15 *)
val Word12.* : Word12.word * Word12.word -> Word12.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 62.17-62.17 *)
val Word12.+ : Word12.word * Word12.word -> Word12.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 63.17-63.17 *)
val Word12.- : Word12.word * Word12.word -> Word12.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 64.17-64.17 *)
val Word12.< : Word12.word * Word12.word -> bool (* @ $(SML_LIB)/basis/integer/embed-word.sml 87.17-87.17 *)
val Word12.<< : Word12.word * word -> Word12.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 78.14-78.15 *)
val Word12.<= : Word12.word * Word12.word -> bool (* @ $(SML_LIB)/basis/integer/embed-word.sml 88.17-88.18 *)
val Word12.> : Word12.word * Word12.word -> bool (* @ $(SML_LIB)/basis/integer/embed-word.sml 89.17-89.17 *)
val Word12.>= : Word12.word * Word12.word -> bool (* @ $(SML_LIB)/basis/integer/embed-word.sml 90.17-90.18 *)
val Word12.>> : Word12.word * word -> Word12.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 77.14-77.15 *)
val Word12.andb: Word12.word * Word12.word -> Word12.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 65.14-65.17 *)
val Word12.compare: Word12.word * Word12.word -> order (* @ $(SML_LIB)/basis/integer/embed-word.sml 91.14-91.20 *)
val Word12.div: Word12.word * Word12.word -> Word12.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 66.17-66.19 *)
val Word12.fmt: StringCvt.radix -> Word12.word -> string (* @ $(SML_LIB)/basis/integer/embed-word.sml 129.11-129.13 *)
val Word12.fromInt: int -> Word12.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 105.14-105.20 *)
val Word12.fromLarge: LargeWord.word -> Word12.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 106.14-106.22 *)
val Word12.fromLargeInt: LargeInt.int -> Word12.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 107.14-107.25 *)
val Word12.fromLargeWord: LargeWord.word -> Word12.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 131.11-131.23 *)
val Word12.fromString: string -> Word12.word option (* @ $(SML_LIB)/basis/integer/embed-word.sml 133.11-133.20 *)
val Word12.max: Word12.word * Word12.word -> Word12.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 135.11-135.13 *)
val Word12.min: Word12.word * Word12.word -> Word12.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 137.11-137.13 *)
val Word12.mod: Word12.word * Word12.word -> Word12.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 67.17-67.19 *)
val Word12.notb: Word12.word -> Word12.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 98.14-98.17 *)
val Word12.orb: Word12.word * Word12.word -> Word12.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 68.14-68.16 *)
val Word12.scan: StringCvt.radix -> ('a -> (char * 'a) option) -> 'a -> (Word12.word * 'a) option (* @ $(SML_LIB)/basis/integer/embed-word.sml 139.11-139.14 *)
val Word12.toInt: Word12.word -> int (* @ $(SML_LIB)/basis/integer/embed-word.sml 114.14-114.18 *)
val Word12.toIntX: Word12.word -> int (* @ $(SML_LIB)/basis/integer/embed-word.sml 124.14-124.19 *)
val Word12.toLarge: Word12.word -> LargeWord.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 115.14-115.20 *)
val Word12.toLargeInt: Word12.word -> LargeInt.int (* @ $(SML_LIB)/basis/integer/embed-word.sml 116.14-116.23 *)
val Word12.toLargeIntX: Word12.word -> LargeInt.int (* @ $(SML_LIB)/basis/integer/embed-word.sml 125.14-125.24 *)
val Word12.toLargeWord: Word12.word -> LargeWord.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 144.11-144.21 *)
val Word12.toLargeWordX: Word12.word -> LargeWord.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 146.11-146.22 *)
val Word12.toLargeX: Word12.word -> LargeWord.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 126.14-126.21 *)
val Word12.toString: Word12.word -> string (* @ $(SML_LIB)/basis/integer/embed-word.sml 117.14-117.21 *)
val Word12.wordSize: int (* @ $(SML_LIB)/basis/integer/embed-word.sml 24.17-24.24 *)
val Word12.xorb: Word12.word * Word12.word -> Word12.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 69.14-69.17 *)
val Word12.~ : Word12.word -> Word12.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 148.11-148.11 *)
val Word12.~>> : Word12.word * word -> Word12.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 81.11-81.13 *)
structure Word13: WORD where type word = Word13.word (* @ $(SML_LIB)/basis/libs/basis-extra/top-level/basis.sml 211.17-211.22 *)
type Word13.word = Word13.word (* @ $(SML_LIB)/basis/primitive/prim-basis.sml 331.12-331.15 *)
val Word13.* : Word13.word * Word13.word -> Word13.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 62.17-62.17 *)
val Word13.+ : Word13.word * Word13.word -> Word13.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 63.17-63.17 *)
val Word13.- : Word13.word * Word13.word -> Word13.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 64.17-64.17 *)
val Word13.< : Word13.word * Word13.word -> bool (* @ $(SML_LIB)/basis/integer/embed-word.sml 87.17-87.17 *)
val Word13.<< : Word13.word * word -> Word13.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 78.14-78.15 *)
val Word13.<= : Word13.word * Word13.word -> bool (* @ $(SML_LIB)/basis/integer/embed-word.sml 88.17-88.18 *)
val Word13.> : Word13.word * Word13.word -> bool (* @ $(SML_LIB)/basis/integer/embed-word.sml 89.17-89.17 *)
val Word13.>= : Word13.word * Word13.word -> bool (* @ $(SML_LIB)/basis/integer/embed-word.sml 90.17-90.18 *)
val Word13.>> : Word13.word * word -> Word13.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 77.14-77.15 *)
val Word13.andb: Word13.word * Word13.word -> Word13.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 65.14-65.17 *)
val Word13.compare: Word13.word * Word13.word -> order (* @ $(SML_LIB)/basis/integer/embed-word.sml 91.14-91.20 *)
val Word13.div: Word13.word * Word13.word -> Word13.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 66.17-66.19 *)
val Word13.fmt: StringCvt.radix -> Word13.word -> string (* @ $(SML_LIB)/basis/integer/embed-word.sml 129.11-129.13 *)
val Word13.fromInt: int -> Word13.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 105.14-105.20 *)
val Word13.fromLarge: LargeWord.word -> Word13.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 106.14-106.22 *)
val Word13.fromLargeInt: LargeInt.int -> Word13.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 107.14-107.25 *)
val Word13.fromLargeWord: LargeWord.word -> Word13.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 131.11-131.23 *)
val Word13.fromString: string -> Word13.word option (* @ $(SML_LIB)/basis/integer/embed-word.sml 133.11-133.20 *)
val Word13.max: Word13.word * Word13.word -> Word13.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 135.11-135.13 *)
val Word13.min: Word13.word * Word13.word -> Word13.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 137.11-137.13 *)
val Word13.mod: Word13.word * Word13.word -> Word13.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 67.17-67.19 *)
val Word13.notb: Word13.word -> Word13.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 98.14-98.17 *)
val Word13.orb: Word13.word * Word13.word -> Word13.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 68.14-68.16 *)
val Word13.scan: StringCvt.radix -> ('a -> (char * 'a) option) -> 'a -> (Word13.word * 'a) option (* @ $(SML_LIB)/basis/integer/embed-word.sml 139.11-139.14 *)
val Word13.toInt: Word13.word -> int (* @ $(SML_LIB)/basis/integer/embed-word.sml 114.14-114.18 *)
val Word13.toIntX: Word13.word -> int (* @ $(SML_LIB)/basis/integer/embed-word.sml 124.14-124.19 *)
val Word13.toLarge: Word13.word -> LargeWord.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 115.14-115.20 *)
val Word13.toLargeInt: Word13.word -> LargeInt.int (* @ $(SML_LIB)/basis/integer/embed-word.sml 116.14-116.23 *)
val Word13.toLargeIntX: Word13.word -> LargeInt.int (* @ $(SML_LIB)/basis/integer/embed-word.sml 125.14-125.24 *)
val Word13.toLargeWord: Word13.word -> LargeWord.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 144.11-144.21 *)
val Word13.toLargeWordX: Word13.word -> LargeWord.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 146.11-146.22 *)
val Word13.toLargeX: Word13.word -> LargeWord.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 126.14-126.21 *)
val Word13.toString: Word13.word -> string (* @ $(SML_LIB)/basis/integer/embed-word.sml 117.14-117.21 *)
val Word13.wordSize: int (* @ $(SML_LIB)/basis/integer/embed-word.sml 24.17-24.24 *)
val Word13.xorb: Word13.word * Word13.word -> Word13.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 69.14-69.17 *)
val Word13.~ : Word13.word -> Word13.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 148.11-148.11 *)
val Word13.~>> : Word13.word * word -> Word13.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 81.11-81.13 *)
structure Word14: WORD where type word = Word14.word (* @ $(SML_LIB)/basis/libs/basis-extra/top-level/basis.sml 212.17-212.22 *)
type Word14.word = Word14.word (* @ $(SML_LIB)/basis/primitive/prim-basis.sml 336.12-336.15 *)
val Word14.* : Word14.word * Word14.word -> Word14.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 62.17-62.17 *)
val Word14.+ : Word14.word * Word14.word -> Word14.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 63.17-63.17 *)
val Word14.- : Word14.word * Word14.word -> Word14.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 64.17-64.17 *)
val Word14.< : Word14.word * Word14.word -> bool (* @ $(SML_LIB)/basis/integer/embed-word.sml 87.17-87.17 *)
val Word14.<< : Word14.word * word -> Word14.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 78.14-78.15 *)
val Word14.<= : Word14.word * Word14.word -> bool (* @ $(SML_LIB)/basis/integer/embed-word.sml 88.17-88.18 *)
val Word14.> : Word14.word * Word14.word -> bool (* @ $(SML_LIB)/basis/integer/embed-word.sml 89.17-89.17 *)
val Word14.>= : Word14.word * Word14.word -> bool (* @ $(SML_LIB)/basis/integer/embed-word.sml 90.17-90.18 *)
val Word14.>> : Word14.word * word -> Word14.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 77.14-77.15 *)
val Word14.andb: Word14.word * Word14.word -> Word14.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 65.14-65.17 *)
val Word14.compare: Word14.word * Word14.word -> order (* @ $(SML_LIB)/basis/integer/embed-word.sml 91.14-91.20 *)
val Word14.div: Word14.word * Word14.word -> Word14.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 66.17-66.19 *)
val Word14.fmt: StringCvt.radix -> Word14.word -> string (* @ $(SML_LIB)/basis/integer/embed-word.sml 129.11-129.13 *)
val Word14.fromInt: int -> Word14.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 105.14-105.20 *)
val Word14.fromLarge: LargeWord.word -> Word14.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 106.14-106.22 *)
val Word14.fromLargeInt: LargeInt.int -> Word14.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 107.14-107.25 *)
val Word14.fromLargeWord: LargeWord.word -> Word14.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 131.11-131.23 *)
val Word14.fromString: string -> Word14.word option (* @ $(SML_LIB)/basis/integer/embed-word.sml 133.11-133.20 *)
val Word14.max: Word14.word * Word14.word -> Word14.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 135.11-135.13 *)
val Word14.min: Word14.word * Word14.word -> Word14.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 137.11-137.13 *)
val Word14.mod: Word14.word * Word14.word -> Word14.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 67.17-67.19 *)
val Word14.notb: Word14.word -> Word14.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 98.14-98.17 *)
val Word14.orb: Word14.word * Word14.word -> Word14.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 68.14-68.16 *)
val Word14.scan: StringCvt.radix -> ('a -> (char * 'a) option) -> 'a -> (Word14.word * 'a) option (* @ $(SML_LIB)/basis/integer/embed-word.sml 139.11-139.14 *)
val Word14.toInt: Word14.word -> int (* @ $(SML_LIB)/basis/integer/embed-word.sml 114.14-114.18 *)
val Word14.toIntX: Word14.word -> int (* @ $(SML_LIB)/basis/integer/embed-word.sml 124.14-124.19 *)
val Word14.toLarge: Word14.word -> LargeWord.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 115.14-115.20 *)
val Word14.toLargeInt: Word14.word -> LargeInt.int (* @ $(SML_LIB)/basis/integer/embed-word.sml 116.14-116.23 *)
val Word14.toLargeIntX: Word14.word -> LargeInt.int (* @ $(SML_LIB)/basis/integer/embed-word.sml 125.14-125.24 *)
val Word14.toLargeWord: Word14.word -> LargeWord.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 144.11-144.21 *)
val Word14.toLargeWordX: Word14.word -> LargeWord.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 146.11-146.22 *)
val Word14.toLargeX: Word14.word -> LargeWord.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 126.14-126.21 *)
val Word14.toString: Word14.word -> string (* @ $(SML_LIB)/basis/integer/embed-word.sml 117.14-117.21 *)
val Word14.wordSize: int (* @ $(SML_LIB)/basis/integer/embed-word.sml 24.17-24.24 *)
val Word14.xorb: Word14.word * Word14.word -> Word14.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 69.14-69.17 *)
val Word14.~ : Word14.word -> Word14.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 148.11-148.11 *)
val Word14.~>> : Word14.word * word -> Word14.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 81.11-81.13 *)
structure Word15: WORD where type word = Word15.word (* @ $(SML_LIB)/basis/libs/basis-extra/top-level/basis.sml 213.17-213.22 *)
type Word15.word = Word15.word (* @ $(SML_LIB)/basis/primitive/prim-basis.sml 341.12-341.15 *)
val Word15.* : Word15.word * Word15.word -> Word15.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 62.17-62.17 *)
val Word15.+ : Word15.word * Word15.word -> Word15.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 63.17-63.17 *)
val Word15.- : Word15.word * Word15.word -> Word15.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 64.17-64.17 *)
val Word15.< : Word15.word * Word15.word -> bool (* @ $(SML_LIB)/basis/integer/embed-word.sml 87.17-87.17 *)
val Word15.<< : Word15.word * word -> Word15.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 78.14-78.15 *)
val Word15.<= : Word15.word * Word15.word -> bool (* @ $(SML_LIB)/basis/integer/embed-word.sml 88.17-88.18 *)
val Word15.> : Word15.word * Word15.word -> bool (* @ $(SML_LIB)/basis/integer/embed-word.sml 89.17-89.17 *)
val Word15.>= : Word15.word * Word15.word -> bool (* @ $(SML_LIB)/basis/integer/embed-word.sml 90.17-90.18 *)
val Word15.>> : Word15.word * word -> Word15.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 77.14-77.15 *)
val Word15.andb: Word15.word * Word15.word -> Word15.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 65.14-65.17 *)
val Word15.compare: Word15.word * Word15.word -> order (* @ $(SML_LIB)/basis/integer/embed-word.sml 91.14-91.20 *)
val Word15.div: Word15.word * Word15.word -> Word15.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 66.17-66.19 *)
val Word15.fmt: StringCvt.radix -> Word15.word -> string (* @ $(SML_LIB)/basis/integer/embed-word.sml 129.11-129.13 *)
val Word15.fromInt: int -> Word15.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 105.14-105.20 *)
val Word15.fromLarge: LargeWord.word -> Word15.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 106.14-106.22 *)
val Word15.fromLargeInt: LargeInt.int -> Word15.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 107.14-107.25 *)
val Word15.fromLargeWord: LargeWord.word -> Word15.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 131.11-131.23 *)
val Word15.fromString: string -> Word15.word option (* @ $(SML_LIB)/basis/integer/embed-word.sml 133.11-133.20 *)
val Word15.max: Word15.word * Word15.word -> Word15.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 135.11-135.13 *)
val Word15.min: Word15.word * Word15.word -> Word15.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 137.11-137.13 *)
val Word15.mod: Word15.word * Word15.word -> Word15.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 67.17-67.19 *)
val Word15.notb: Word15.word -> Word15.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 98.14-98.17 *)
val Word15.orb: Word15.word * Word15.word -> Word15.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 68.14-68.16 *)
val Word15.scan: StringCvt.radix -> ('a -> (char * 'a) option) -> 'a -> (Word15.word * 'a) option (* @ $(SML_LIB)/basis/integer/embed-word.sml 139.11-139.14 *)
val Word15.toInt: Word15.word -> int (* @ $(SML_LIB)/basis/integer/embed-word.sml 114.14-114.18 *)
val Word15.toIntX: Word15.word -> int (* @ $(SML_LIB)/basis/integer/embed-word.sml 124.14-124.19 *)
val Word15.toLarge: Word15.word -> LargeWord.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 115.14-115.20 *)
val Word15.toLargeInt: Word15.word -> LargeInt.int (* @ $(SML_LIB)/basis/integer/embed-word.sml 116.14-116.23 *)
val Word15.toLargeIntX: Word15.word -> LargeInt.int (* @ $(SML_LIB)/basis/integer/embed-word.sml 125.14-125.24 *)
val Word15.toLargeWord: Word15.word -> LargeWord.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 144.11-144.21 *)
val Word15.toLargeWordX: Word15.word -> LargeWord.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 146.11-146.22 *)
val Word15.toLargeX: Word15.word -> LargeWord.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 126.14-126.21 *)
val Word15.toString: Word15.word -> string (* @ $(SML_LIB)/basis/integer/embed-word.sml 117.14-117.21 *)
val Word15.wordSize: int (* @ $(SML_LIB)/basis/integer/embed-word.sml 24.17-24.24 *)
val Word15.xorb: Word15.word * Word15.word -> Word15.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 69.14-69.17 *)
val Word15.~ : Word15.word -> Word15.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 148.11-148.11 *)
val Word15.~>> : Word15.word * word -> Word15.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 81.11-81.13 *)
structure Word16: WORD where type word = Word16.word (* @ $(SML_LIB)/basis/libs/basis-2002/top-level/top-level.sml 88.11-88.16 *)
type Word16.word = Word16.word (* @ $(SML_LIB)/basis/primitive/prim-basis.sml 346.12-346.15 *)
val Word16.* : Word16.word * Word16.word -> Word16.word (* @ $(SML_LIB)/basis/primitive/prim-word.sml 206.11-206.11 *)
val Word16.+ : Word16.word * Word16.word -> Word16.word (* @ $(SML_LIB)/basis/primitive/prim-word.sml 203.11-203.11 *)
val Word16.- : Word16.word * Word16.word -> Word16.word (* @ $(SML_LIB)/basis/primitive/prim-word.sml 216.11-216.11 *)
val Word16.< : Word16.word * Word16.word -> bool (* @ $(SML_LIB)/basis/util/integral-comparisons.sml 11.11-11.11 *)
val Word16.<< : Word16.word * word -> Word16.word (* @ $(SML_LIB)/basis/integer/word.sml 19.5-19.6 *)
val Word16.<= : Word16.word * Word16.word -> bool (* @ $(SML_LIB)/basis/util/integral-comparisons.sml 12.11-12.12 *)
val Word16.> : Word16.word * Word16.word -> bool (* @ $(SML_LIB)/basis/util/integral-comparisons.sml 13.11-13.11 *)
val Word16.>= : Word16.word * Word16.word -> bool (* @ $(SML_LIB)/basis/util/integral-comparisons.sml 14.11-14.12 *)
val Word16.>> : Word16.word * word -> Word16.word (* @ $(SML_LIB)/basis/integer/word.sml 23.5-23.6 *)
val Word16.andb: Word16.word * Word16.word -> Word16.word (* @ $(SML_LIB)/basis/primitive/prim-word.sml 204.11-204.14 *)
val Word16.compare: Word16.word * Word16.word -> order (* @ $(SML_LIB)/basis/util/integral-comparisons.sml 16.11-16.17 *)
val Word16.div: Word16.word * Word16.word -> Word16.word (* @ $(SML_LIB)/basis/integer/num0.sml 97.23-97.25 *)
val Word16.fmt: StringCvt.radix -> Word16.word -> string (* @ $(SML_LIB)/basis/integer/word.sml 104.8-104.10 *)
val Word16.fromInt: int -> Word16.word (* @ $(SML_LIB)/basis/integer/word.sml 55.5-55.11 *)
val Word16.fromLarge: LargeWord.word -> Word16.word (* @ $(SML_LIB)/basis/integer/word.sml 87.5-87.13 *)
val Word16.fromLargeInt: LargeInt.int -> Word16.word (* @ $(SML_LIB)/basis/integer/word.sml 70.5-70.16 *)
val Word16.fromLargeWord: LargeWord.word -> Word16.word (* @ $(SML_LIB)/basis/integer/word.sml 86.5-86.17 *)
val Word16.fromString: string -> Word16.word option (* @ $(SML_LIB)/basis/integer/word.sml 209.5-209.14 *)
val Word16.max: Word16.word * Word16.word -> Word16.word (* @ $(SML_LIB)/basis/util/integral-comparisons.sml 21.11-21.13 *)
val Word16.min: Word16.word * Word16.word -> Word16.word (* @ $(SML_LIB)/basis/util/integral-comparisons.sml 20.11-20.13 *)
val Word16.mod: Word16.word * Word16.word -> Word16.word (* @ $(SML_LIB)/basis/integer/num0.sml 98.23-98.25 *)
val Word16.notb: Word16.word -> Word16.word (* @ $(SML_LIB)/basis/primitive/prim-word.sml 208.11-208.14 *)
val Word16.orb: Word16.word * Word16.word -> Word16.word (* @ $(SML_LIB)/basis/primitive/prim-word.sml 209.11-209.13 *)
val Word16.scan: StringCvt.radix -> ('a -> (char * 'a) option) -> 'a -> (Word16.word * 'a) option (* @ $(SML_LIB)/basis/integer/word.sml 146.5-146.8 *)
val Word16.toInt: Word16.word -> int (* @ $(SML_LIB)/basis/integer/word.sml 57.5-57.9 *)
val Word16.toIntX: Word16.word -> int (* @ $(SML_LIB)/basis/integer/word.sml 56.5-56.10 *)
val Word16.toLarge: Word16.word -> LargeWord.word (* @ $(SML_LIB)/basis/integer/word.sml 91.5-91.11 *)
val Word16.toLargeInt: Word16.word -> LargeInt.int (* @ $(SML_LIB)/basis/integer/word.sml 72.5-72.14 *)
val Word16.toLargeIntX: Word16.word -> LargeInt.int (* @ $(SML_LIB)/basis/integer/word.sml 71.5-71.15 *)
val Word16.toLargeWord: Word16.word -> LargeWord.word (* @ $(SML_LIB)/basis/integer/word.sml 90.5-90.15 *)
val Word16.toLargeWordX: Word16.word -> LargeWord.word (* @ $(SML_LIB)/basis/integer/word.sml 88.5-88.16 *)
val Word16.toLargeX: Word16.word -> LargeWord.word (* @ $(SML_LIB)/basis/integer/word.sml 89.5-89.12 *)
val Word16.toString: Word16.word -> string (* @ $(SML_LIB)/basis/integer/word.sml 144.5-144.12 *)
val Word16.wordSize: int (* @ $(SML_LIB)/basis/integer/word.sml 16.5-16.12 *)
val Word16.xorb: Word16.word * Word16.word -> Word16.word (* @ $(SML_LIB)/basis/primitive/prim-word.sml 217.11-217.14 *)
val Word16.~ : Word16.word -> Word16.word (* @ $(SML_LIB)/basis/primitive/prim-word.sml 207.11-207.11 *)
val Word16.~>> : Word16.word * word -> Word16.word (* @ $(SML_LIB)/basis/integer/word.sml 27.5-27.7 *)
structure Word16Array: MONO_ARRAY where type array = Word16Array.array where type elem = Word16.word where type vector = Word16Vector.vector (* @ $(SML_LIB)/basis/libs/basis-2002/top-level/top-level.sml 61.11-61.21 *)
type Word16Array.array = Word16Array.array (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array.fun 23.12-23.16 *)
type Word16Array.elem = Word16.word (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array.fun 22.12-22.15 *)
type Word16Array.vector = Word16Vector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array.fun 24.12-24.17 *)
val Word16Array.all: (Word16.word -> bool) -> Word16Array.array -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 476.13-476.15 *)
val Word16Array.app: (Word16.word -> unit) -> Word16Array.array -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 464.13-464.15 *)
val Word16Array.appi: (int * Word16.word -> unit) -> Word16Array.array -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 463.13-463.16 *)
val Word16Array.array: int * Word16.word -> Word16Array.array (* @ $(SML_LIB)/basis/arrays-and-vectors/array.sml 34.11-34.15 *)
val Word16Array.collate: (Word16.word * Word16.word -> order) -> Word16Array.array * Word16Array.array -> order (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 477.13-477.19 *)
val Word16Array.copy: {di: int, dst: Word16Array.array, src: Word16Array.array} -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 457.13-457.16 *)
val Word16Array.copyVec: {di: int, dst: Word16Array.array, src: Word16Vector.vector} -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array.sml 37.11-37.17 *)
val Word16Array.exists: (Word16.word -> bool) -> Word16Array.array -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 474.13-474.18 *)
val Word16Array.find: (Word16.word -> bool) -> Word16Array.array -> Word16.word option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 472.13-472.16 *)
val Word16Array.findi: (int * Word16.word -> bool) -> Word16Array.array -> (int * Word16.word) option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 471.13-471.17 *)
val Word16Array.foldl: (Word16.word * 'a -> 'a) -> 'a -> Word16Array.array -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 468.13-468.17 *)
val Word16Array.foldli: (int * Word16.word * 'a -> 'a) -> 'a -> Word16Array.array -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 467.13-467.18 *)
val Word16Array.foldr: (Word16.word * 'a -> 'a) -> 'a -> Word16Array.array -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 470.13-470.17 *)
val Word16Array.foldri: (int * Word16.word * 'a -> 'a) -> 'a -> Word16Array.array -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 469.13-469.18 *)
val Word16Array.fromList: Word16.word list -> Word16Array.array (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 122.11-122.18 *)
val Word16Array.length: Word16Array.array -> int (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 90.11-90.16 *)
val Word16Array.maxLen: int (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 88.11-88.16 *)
val Word16Array.modify: (Word16.word -> Word16.word) -> Word16Array.array -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array.sml 40.11-40.16 *)
val Word16Array.modifyi: (int * Word16.word -> Word16.word) -> Word16Array.array -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array.sml 39.11-39.17 *)
val Word16Array.sub: Word16Array.array * int -> Word16.word (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 450.13-450.15 *)
val Word16Array.tabulate: int * (int -> Word16.word) -> Word16Array.array (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 114.11-114.18 *)
val Word16Array.update: Word16Array.array * int * Word16.word -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 452.13-452.18 *)
val Word16Array.vector: Word16Array.array -> Word16Vector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/array.sml 36.11-36.16 *)
structure Word16Array2: MONO_ARRAY2 where type array = Word16Array2.array where type elem = Word16.word where type vector = Word16Vector.vector (* @ $(SML_LIB)/basis/libs/basis-2002/top-level/top-level.sml 62.11-62.22 *)
type Word16Array2.array = Word16Array2.array (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array2.fun 18.12-18.16 *)
type Word16Array2.elem = Word16.word (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array2.fun 15.12-15.15 *)
type Word16Array2.region = {base: Word16Array2.array, col: int, ncols: int option, nrows: int option, row: int} (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array2.fun 19.12-19.17 *)
datatype Word16Array2.traversal = ColMajor | RowMajor (* = datatype Array2.traversal *) (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 106.16-106.24 *)
type Word16Array2.vector = Word16Vector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array2.fun 16.12-16.17 *)
con Word16Array2.ColMajor: Array2.traversal (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 106.39-106.46 *)
con Word16Array2.RowMajor: Array2.traversal (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 106.28-106.35 *)
val Word16Array2.app: Array2.traversal -> (Word16.word -> unit) -> Word16Array2.array -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 294.11-294.13 *)
val Word16Array2.appi: Array2.traversal -> (int * int * Word16.word -> unit) -> {base: Word16Array2.array, col: int, ncols: int option, nrows: int option, row: int} -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 291.11-291.14 *)
val Word16Array2.array: int * int * Word16.word -> Word16Array2.array (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 140.14-140.18 *)
val Word16Array2.column: Word16Array2.array * int -> Word16Vector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 237.11-237.16 *)
val Word16Array2.copy: {dst: Word16Array2.array, dst_col: int, dst_row: int, src: {base: Word16Array2.array, col: int, ncols: int option, nrows: int option, row: int}} -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 309.11-309.14 *)
val Word16Array2.dimensions: Word16Array2.array -> int * int (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 33.11-33.20 *)
val Word16Array2.fold: Array2.traversal -> (Word16.word * 'a -> 'a) -> 'a -> Word16Array2.array -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 288.11-288.14 *)
val Word16Array2.foldi: Array2.traversal -> (int * int * Word16.word * 'a -> 'a) -> 'a -> {base: Word16Array2.array, col: int, ncols: int option, nrows: int option, row: int} -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 283.11-283.15 *)
val Word16Array2.fromList: Word16.word list list -> Word16Array2.array (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 188.14-188.21 *)
val Word16Array2.modify: Array2.traversal -> (Word16.word -> Word16.word) -> Word16Array2.array -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 299.11-299.16 *)
val Word16Array2.modifyi: Array2.traversal -> (int * int * Word16.word -> Word16.word) -> {base: Word16Array2.array, col: int, ncols: int option, nrows: int option, row: int} -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 296.11-296.17 *)
val Word16Array2.nCols: Word16Array2.array -> int (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 38.11-38.15 *)
val Word16Array2.nRows: Word16Array2.array -> int (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 36.11-36.15 *)
val Word16Array2.row: Word16Array2.array * int -> Word16Vector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 222.11-222.13 *)
val Word16Array2.sub: Word16Array2.array * int * int -> Word16.word (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 182.14-182.16 *)
val Word16Array2.tabulate: Array2.traversal -> int * int * (int * int -> Word16.word) -> Word16Array2.array (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 301.11-301.18 *)
val Word16Array2.update: Word16Array2.array * int * int * Word16.word -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 184.14-184.19 *)
structure Word16ArraySlice: MONO_ARRAY_SLICE where type array = Word16Array.array where type elem = Word16.word where type slice = Word16ArraySlice.slice where type vector = Word16Vector.vector where type vector_slice = Word16VectorSlice.slice (* @ $(SML_LIB)/basis/libs/basis-extra/top-level/basis.sml 240.17-240.32 *)
type Word16ArraySlice.array = Word16Array.array (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array.fun 35.18-35.22 *)
type Word16ArraySlice.elem = Word16.word (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array.fun 34.18-34.21 *)
type Word16ArraySlice.slice = Word16ArraySlice.slice (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array.fun 36.18-36.22 *)
type Word16ArraySlice.vector = Word16Vector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array.fun 37.18-37.23 *)
type Word16ArraySlice.vector_slice = Word16VectorSlice.slice (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array.fun 38.18-38.29 *)
val Word16ArraySlice.all: (Word16.word -> bool) -> Word16ArraySlice.slice -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 235.17-235.19 *)
val Word16ArraySlice.app: (Word16.word -> unit) -> Word16ArraySlice.slice -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 226.17-226.19 *)
val Word16ArraySlice.appi: (int * Word16.word -> unit) -> Word16ArraySlice.slice -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 225.17-225.20 *)
val Word16ArraySlice.base: Word16ArraySlice.slice -> Word16Array.array * int * int (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 208.17-208.20 *)
val Word16ArraySlice.collate: (Word16.word * Word16.word -> order) -> Word16ArraySlice.slice * Word16ArraySlice.slice -> order (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 236.17-236.23 *)
val Word16ArraySlice.copy: {di: int, dst: Word16Array.array, src: Word16ArraySlice.slice} -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 185.17-185.20 *)
val Word16ArraySlice.copyVec: {di: int, dst: Word16Array.array, src: Word16VectorSlice.slice} -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array.sml 28.17-28.23 *)
val Word16ArraySlice.exists: (Word16.word -> bool) -> Word16ArraySlice.slice -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 233.17-233.22 *)
val Word16ArraySlice.find: (Word16.word -> bool) -> Word16ArraySlice.slice -> Word16.word option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 231.17-231.20 *)
val Word16ArraySlice.findi: (int * Word16.word -> bool) -> Word16ArraySlice.slice -> (int * Word16.word) option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 229.17-229.21 *)
val Word16ArraySlice.foldl: (Word16.word * 'a -> 'a) -> 'a -> Word16ArraySlice.slice -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 223.17-223.21 *)
val Word16ArraySlice.foldli: (int * Word16.word * 'a -> 'a) -> 'a -> Word16ArraySlice.slice -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 221.17-221.22 *)
val Word16ArraySlice.foldr: (Word16.word * 'a -> 'a) -> 'a -> Word16ArraySlice.slice -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 224.17-224.21 *)
val Word16ArraySlice.foldri: (int * Word16.word * 'a -> 'a) -> 'a -> Word16ArraySlice.slice -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 222.17-222.22 *)
val Word16ArraySlice.full: Word16Array.array -> Word16ArraySlice.slice (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 192.17-192.20 *)
val Word16ArraySlice.getItem: Word16ArraySlice.slice -> (Word16.word * Word16ArraySlice.slice) option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 220.17-220.23 *)
val Word16ArraySlice.isEmpty: Word16ArraySlice.slice -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 219.17-219.23 *)
val Word16ArraySlice.length: Word16ArraySlice.slice -> int (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 134.17-134.22 *)
val Word16ArraySlice.modify: (Word16.word -> Word16.word) -> Word16ArraySlice.slice -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array.sml 31.17-31.22 *)
val Word16ArraySlice.modifyi: (int * Word16.word -> Word16.word) -> Word16ArraySlice.slice -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array.sml 30.17-30.23 *)
val Word16ArraySlice.slice: Word16Array.array * int * int option -> Word16ArraySlice.slice (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 206.17-206.21 *)
val Word16ArraySlice.sub: Word16ArraySlice.slice * int -> Word16.word (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 142.17-142.19 *)
val Word16ArraySlice.subslice: Word16ArraySlice.slice * int * int option -> Word16ArraySlice.slice (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 199.17-199.24 *)
val Word16ArraySlice.update: Word16ArraySlice.slice * int * Word16.word -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 155.17-155.22 *)
val Word16ArraySlice.vector: Word16ArraySlice.slice -> Word16Vector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/array.sml 27.17-27.22 *)
structure Word16Vector: MONO_VECTOR where type elem = Word16.word where type vector = Word16Vector.vector (* @ $(SML_LIB)/basis/libs/basis-2002/top-level/top-level.sml 63.11-63.22 *)
type Word16Vector.elem = Word16.word (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-vector.fun 35.12-35.15 *)
type Word16Vector.vector = Word16Vector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-vector.fun 36.12-36.17 *)
val Word16Vector.all: (Word16.word -> bool) -> Word16Vector.vector -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 476.13-476.15 *)
val Word16Vector.app: (Word16.word -> unit) -> Word16Vector.vector -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 464.13-464.15 *)
val Word16Vector.appi: (int * Word16.word -> unit) -> Word16Vector.vector -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 463.13-463.16 *)
val Word16Vector.collate: (Word16.word * Word16.word -> order) -> Word16Vector.vector * Word16Vector.vector -> order (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 477.13-477.19 *)
val Word16Vector.concat: Word16Vector.vector list -> Word16Vector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 462.13-462.18 *)
val Word16Vector.exists: (Word16.word -> bool) -> Word16Vector.vector -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 474.13-474.18 *)
val Word16Vector.find: (Word16.word -> bool) -> Word16Vector.vector -> Word16.word option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 472.13-472.16 *)
val Word16Vector.findi: (int * Word16.word -> bool) -> Word16Vector.vector -> (int * Word16.word) option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 471.13-471.17 *)
val Word16Vector.foldl: (Word16.word * 'a -> 'a) -> 'a -> Word16Vector.vector -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 468.13-468.17 *)
val Word16Vector.foldli: (int * Word16.word * 'a -> 'a) -> 'a -> Word16Vector.vector -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 467.13-467.18 *)
val Word16Vector.foldr: (Word16.word * 'a -> 'a) -> 'a -> Word16Vector.vector -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 470.13-470.17 *)
val Word16Vector.foldri: (int * Word16.word * 'a -> 'a) -> 'a -> Word16Vector.vector -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 469.13-469.18 *)
val Word16Vector.fromList: Word16.word list -> Word16Vector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 122.11-122.18 *)
val Word16Vector.length: Word16Vector.vector -> int (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 90.11-90.16 *)
val Word16Vector.map: (Word16.word -> Word16.word) -> Word16Vector.vector -> Word16Vector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 466.13-466.15 *)
val Word16Vector.mapi: (int * Word16.word -> Word16.word) -> Word16Vector.vector -> Word16Vector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 465.13-465.16 *)
val Word16Vector.maxLen: int (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 88.11-88.16 *)
val Word16Vector.sub: Word16Vector.vector * int -> Word16.word (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 450.13-450.15 *)
val Word16Vector.tabulate: int * (int -> Word16.word) -> Word16Vector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 114.11-114.18 *)
val Word16Vector.update: Word16Vector.vector * int * Word16.word -> Word16Vector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/vector.sml 30.11-30.16 *)
structure Word16VectorSlice: MONO_VECTOR_SLICE where type elem = Word16.word where type slice = Word16VectorSlice.slice where type vector = Word16Vector.vector (* @ $(SML_LIB)/basis/libs/basis-extra/top-level/basis.sml 242.17-242.33 *)
type Word16VectorSlice.elem = Word16.word (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-vector.fun 43.18-43.21 *)
type Word16VectorSlice.slice = Word16VectorSlice.slice (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-vector.fun 45.18-45.22 *)
type Word16VectorSlice.vector = Word16Vector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-vector.fun 44.18-44.23 *)
val Word16VectorSlice.all: (Word16.word -> bool) -> Word16VectorSlice.slice -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 235.17-235.19 *)
val Word16VectorSlice.app: (Word16.word -> unit) -> Word16VectorSlice.slice -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 226.17-226.19 *)
val Word16VectorSlice.appi: (int * Word16.word -> unit) -> Word16VectorSlice.slice -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 225.17-225.20 *)
val Word16VectorSlice.base: Word16VectorSlice.slice -> Word16Vector.vector * int * int (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 208.17-208.20 *)
val Word16VectorSlice.collate: (Word16.word * Word16.word -> order) -> Word16VectorSlice.slice * Word16VectorSlice.slice -> order (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 236.17-236.23 *)
val Word16VectorSlice.concat: Word16VectorSlice.slice list -> Word16Vector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 240.17-240.22 *)
val Word16VectorSlice.exists: (Word16.word -> bool) -> Word16VectorSlice.slice -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 233.17-233.22 *)
val Word16VectorSlice.find: (Word16.word -> bool) -> Word16VectorSlice.slice -> Word16.word option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 231.17-231.20 *)
val Word16VectorSlice.findi: (int * Word16.word -> bool) -> Word16VectorSlice.slice -> (int * Word16.word) option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 229.17-229.21 *)
val Word16VectorSlice.foldl: (Word16.word * 'a -> 'a) -> 'a -> Word16VectorSlice.slice -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 223.17-223.21 *)
val Word16VectorSlice.foldli: (int * Word16.word * 'a -> 'a) -> 'a -> Word16VectorSlice.slice -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 221.17-221.22 *)
val Word16VectorSlice.foldr: (Word16.word * 'a -> 'a) -> 'a -> Word16VectorSlice.slice -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 224.17-224.21 *)
val Word16VectorSlice.foldri: (int * Word16.word * 'a -> 'a) -> 'a -> Word16VectorSlice.slice -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 222.17-222.22 *)
val Word16VectorSlice.full: Word16Vector.vector -> Word16VectorSlice.slice (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 192.17-192.20 *)
val Word16VectorSlice.getItem: Word16VectorSlice.slice -> (Word16.word * Word16VectorSlice.slice) option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 220.17-220.23 *)
val Word16VectorSlice.isEmpty: Word16VectorSlice.slice -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 219.17-219.23 *)
val Word16VectorSlice.length: Word16VectorSlice.slice -> int (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 134.17-134.22 *)
val Word16VectorSlice.map: (Word16.word -> Word16.word) -> Word16VectorSlice.slice -> Word16Vector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 228.17-228.19 *)
val Word16VectorSlice.mapi: (int * Word16.word -> Word16.word) -> Word16VectorSlice.slice -> Word16Vector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 227.17-227.20 *)
val Word16VectorSlice.slice: Word16Vector.vector * int * int option -> Word16VectorSlice.slice (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 206.17-206.21 *)
val Word16VectorSlice.sub: Word16VectorSlice.slice * int -> Word16.word (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 142.17-142.19 *)
val Word16VectorSlice.subslice: Word16VectorSlice.slice * int * int option -> Word16VectorSlice.slice (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 199.17-199.24 *)
val Word16VectorSlice.vector: Word16VectorSlice.slice -> Word16Vector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/vector.sml 21.17-21.22 *)
structure Word17: WORD where type word = Word17.word (* @ $(SML_LIB)/basis/libs/basis-extra/top-level/basis.sml 215.17-215.22 *)
type Word17.word = Word17.word (* @ $(SML_LIB)/basis/primitive/prim-basis.sml 351.12-351.15 *)
val Word17.* : Word17.word * Word17.word -> Word17.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 62.17-62.17 *)
val Word17.+ : Word17.word * Word17.word -> Word17.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 63.17-63.17 *)
val Word17.- : Word17.word * Word17.word -> Word17.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 64.17-64.17 *)
val Word17.< : Word17.word * Word17.word -> bool (* @ $(SML_LIB)/basis/integer/embed-word.sml 87.17-87.17 *)
val Word17.<< : Word17.word * word -> Word17.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 78.14-78.15 *)
val Word17.<= : Word17.word * Word17.word -> bool (* @ $(SML_LIB)/basis/integer/embed-word.sml 88.17-88.18 *)
val Word17.> : Word17.word * Word17.word -> bool (* @ $(SML_LIB)/basis/integer/embed-word.sml 89.17-89.17 *)
val Word17.>= : Word17.word * Word17.word -> bool (* @ $(SML_LIB)/basis/integer/embed-word.sml 90.17-90.18 *)
val Word17.>> : Word17.word * word -> Word17.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 77.14-77.15 *)
val Word17.andb: Word17.word * Word17.word -> Word17.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 65.14-65.17 *)
val Word17.compare: Word17.word * Word17.word -> order (* @ $(SML_LIB)/basis/integer/embed-word.sml 91.14-91.20 *)
val Word17.div: Word17.word * Word17.word -> Word17.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 66.17-66.19 *)
val Word17.fmt: StringCvt.radix -> Word17.word -> string (* @ $(SML_LIB)/basis/integer/embed-word.sml 129.11-129.13 *)
val Word17.fromInt: int -> Word17.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 105.14-105.20 *)
val Word17.fromLarge: LargeWord.word -> Word17.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 106.14-106.22 *)
val Word17.fromLargeInt: LargeInt.int -> Word17.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 107.14-107.25 *)
val Word17.fromLargeWord: LargeWord.word -> Word17.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 131.11-131.23 *)
val Word17.fromString: string -> Word17.word option (* @ $(SML_LIB)/basis/integer/embed-word.sml 133.11-133.20 *)
val Word17.max: Word17.word * Word17.word -> Word17.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 135.11-135.13 *)
val Word17.min: Word17.word * Word17.word -> Word17.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 137.11-137.13 *)
val Word17.mod: Word17.word * Word17.word -> Word17.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 67.17-67.19 *)
val Word17.notb: Word17.word -> Word17.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 98.14-98.17 *)
val Word17.orb: Word17.word * Word17.word -> Word17.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 68.14-68.16 *)
val Word17.scan: StringCvt.radix -> ('a -> (char * 'a) option) -> 'a -> (Word17.word * 'a) option (* @ $(SML_LIB)/basis/integer/embed-word.sml 139.11-139.14 *)
val Word17.toInt: Word17.word -> int (* @ $(SML_LIB)/basis/integer/embed-word.sml 114.14-114.18 *)
val Word17.toIntX: Word17.word -> int (* @ $(SML_LIB)/basis/integer/embed-word.sml 124.14-124.19 *)
val Word17.toLarge: Word17.word -> LargeWord.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 115.14-115.20 *)
val Word17.toLargeInt: Word17.word -> LargeInt.int (* @ $(SML_LIB)/basis/integer/embed-word.sml 116.14-116.23 *)
val Word17.toLargeIntX: Word17.word -> LargeInt.int (* @ $(SML_LIB)/basis/integer/embed-word.sml 125.14-125.24 *)
val Word17.toLargeWord: Word17.word -> LargeWord.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 144.11-144.21 *)
val Word17.toLargeWordX: Word17.word -> LargeWord.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 146.11-146.22 *)
val Word17.toLargeX: Word17.word -> LargeWord.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 126.14-126.21 *)
val Word17.toString: Word17.word -> string (* @ $(SML_LIB)/basis/integer/embed-word.sml 117.14-117.21 *)
val Word17.wordSize: int (* @ $(SML_LIB)/basis/integer/embed-word.sml 24.17-24.24 *)
val Word17.xorb: Word17.word * Word17.word -> Word17.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 69.14-69.17 *)
val Word17.~ : Word17.word -> Word17.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 148.11-148.11 *)
val Word17.~>> : Word17.word * word -> Word17.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 81.11-81.13 *)
structure Word18: WORD where type word = Word18.word (* @ $(SML_LIB)/basis/libs/basis-extra/top-level/basis.sml 216.17-216.22 *)
type Word18.word = Word18.word (* @ $(SML_LIB)/basis/primitive/prim-basis.sml 356.12-356.15 *)
val Word18.* : Word18.word * Word18.word -> Word18.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 62.17-62.17 *)
val Word18.+ : Word18.word * Word18.word -> Word18.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 63.17-63.17 *)
val Word18.- : Word18.word * Word18.word -> Word18.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 64.17-64.17 *)
val Word18.< : Word18.word * Word18.word -> bool (* @ $(SML_LIB)/basis/integer/embed-word.sml 87.17-87.17 *)
val Word18.<< : Word18.word * word -> Word18.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 78.14-78.15 *)
val Word18.<= : Word18.word * Word18.word -> bool (* @ $(SML_LIB)/basis/integer/embed-word.sml 88.17-88.18 *)
val Word18.> : Word18.word * Word18.word -> bool (* @ $(SML_LIB)/basis/integer/embed-word.sml 89.17-89.17 *)
val Word18.>= : Word18.word * Word18.word -> bool (* @ $(SML_LIB)/basis/integer/embed-word.sml 90.17-90.18 *)
val Word18.>> : Word18.word * word -> Word18.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 77.14-77.15 *)
val Word18.andb: Word18.word * Word18.word -> Word18.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 65.14-65.17 *)
val Word18.compare: Word18.word * Word18.word -> order (* @ $(SML_LIB)/basis/integer/embed-word.sml 91.14-91.20 *)
val Word18.div: Word18.word * Word18.word -> Word18.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 66.17-66.19 *)
val Word18.fmt: StringCvt.radix -> Word18.word -> string (* @ $(SML_LIB)/basis/integer/embed-word.sml 129.11-129.13 *)
val Word18.fromInt: int -> Word18.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 105.14-105.20 *)
val Word18.fromLarge: LargeWord.word -> Word18.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 106.14-106.22 *)
val Word18.fromLargeInt: LargeInt.int -> Word18.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 107.14-107.25 *)
val Word18.fromLargeWord: LargeWord.word -> Word18.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 131.11-131.23 *)
val Word18.fromString: string -> Word18.word option (* @ $(SML_LIB)/basis/integer/embed-word.sml 133.11-133.20 *)
val Word18.max: Word18.word * Word18.word -> Word18.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 135.11-135.13 *)
val Word18.min: Word18.word * Word18.word -> Word18.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 137.11-137.13 *)
val Word18.mod: Word18.word * Word18.word -> Word18.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 67.17-67.19 *)
val Word18.notb: Word18.word -> Word18.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 98.14-98.17 *)
val Word18.orb: Word18.word * Word18.word -> Word18.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 68.14-68.16 *)
val Word18.scan: StringCvt.radix -> ('a -> (char * 'a) option) -> 'a -> (Word18.word * 'a) option (* @ $(SML_LIB)/basis/integer/embed-word.sml 139.11-139.14 *)
val Word18.toInt: Word18.word -> int (* @ $(SML_LIB)/basis/integer/embed-word.sml 114.14-114.18 *)
val Word18.toIntX: Word18.word -> int (* @ $(SML_LIB)/basis/integer/embed-word.sml 124.14-124.19 *)
val Word18.toLarge: Word18.word -> LargeWord.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 115.14-115.20 *)
val Word18.toLargeInt: Word18.word -> LargeInt.int (* @ $(SML_LIB)/basis/integer/embed-word.sml 116.14-116.23 *)
val Word18.toLargeIntX: Word18.word -> LargeInt.int (* @ $(SML_LIB)/basis/integer/embed-word.sml 125.14-125.24 *)
val Word18.toLargeWord: Word18.word -> LargeWord.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 144.11-144.21 *)
val Word18.toLargeWordX: Word18.word -> LargeWord.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 146.11-146.22 *)
val Word18.toLargeX: Word18.word -> LargeWord.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 126.14-126.21 *)
val Word18.toString: Word18.word -> string (* @ $(SML_LIB)/basis/integer/embed-word.sml 117.14-117.21 *)
val Word18.wordSize: int (* @ $(SML_LIB)/basis/integer/embed-word.sml 24.17-24.24 *)
val Word18.xorb: Word18.word * Word18.word -> Word18.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 69.14-69.17 *)
val Word18.~ : Word18.word -> Word18.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 148.11-148.11 *)
val Word18.~>> : Word18.word * word -> Word18.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 81.11-81.13 *)
structure Word19: WORD where type word = Word19.word (* @ $(SML_LIB)/basis/libs/basis-extra/top-level/basis.sml 217.17-217.22 *)
type Word19.word = Word19.word (* @ $(SML_LIB)/basis/primitive/prim-basis.sml 361.12-361.15 *)
val Word19.* : Word19.word * Word19.word -> Word19.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 62.17-62.17 *)
val Word19.+ : Word19.word * Word19.word -> Word19.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 63.17-63.17 *)
val Word19.- : Word19.word * Word19.word -> Word19.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 64.17-64.17 *)
val Word19.< : Word19.word * Word19.word -> bool (* @ $(SML_LIB)/basis/integer/embed-word.sml 87.17-87.17 *)
val Word19.<< : Word19.word * word -> Word19.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 78.14-78.15 *)
val Word19.<= : Word19.word * Word19.word -> bool (* @ $(SML_LIB)/basis/integer/embed-word.sml 88.17-88.18 *)
val Word19.> : Word19.word * Word19.word -> bool (* @ $(SML_LIB)/basis/integer/embed-word.sml 89.17-89.17 *)
val Word19.>= : Word19.word * Word19.word -> bool (* @ $(SML_LIB)/basis/integer/embed-word.sml 90.17-90.18 *)
val Word19.>> : Word19.word * word -> Word19.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 77.14-77.15 *)
val Word19.andb: Word19.word * Word19.word -> Word19.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 65.14-65.17 *)
val Word19.compare: Word19.word * Word19.word -> order (* @ $(SML_LIB)/basis/integer/embed-word.sml 91.14-91.20 *)
val Word19.div: Word19.word * Word19.word -> Word19.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 66.17-66.19 *)
val Word19.fmt: StringCvt.radix -> Word19.word -> string (* @ $(SML_LIB)/basis/integer/embed-word.sml 129.11-129.13 *)
val Word19.fromInt: int -> Word19.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 105.14-105.20 *)
val Word19.fromLarge: LargeWord.word -> Word19.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 106.14-106.22 *)
val Word19.fromLargeInt: LargeInt.int -> Word19.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 107.14-107.25 *)
val Word19.fromLargeWord: LargeWord.word -> Word19.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 131.11-131.23 *)
val Word19.fromString: string -> Word19.word option (* @ $(SML_LIB)/basis/integer/embed-word.sml 133.11-133.20 *)
val Word19.max: Word19.word * Word19.word -> Word19.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 135.11-135.13 *)
val Word19.min: Word19.word * Word19.word -> Word19.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 137.11-137.13 *)
val Word19.mod: Word19.word * Word19.word -> Word19.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 67.17-67.19 *)
val Word19.notb: Word19.word -> Word19.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 98.14-98.17 *)
val Word19.orb: Word19.word * Word19.word -> Word19.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 68.14-68.16 *)
val Word19.scan: StringCvt.radix -> ('a -> (char * 'a) option) -> 'a -> (Word19.word * 'a) option (* @ $(SML_LIB)/basis/integer/embed-word.sml 139.11-139.14 *)
val Word19.toInt: Word19.word -> int (* @ $(SML_LIB)/basis/integer/embed-word.sml 114.14-114.18 *)
val Word19.toIntX: Word19.word -> int (* @ $(SML_LIB)/basis/integer/embed-word.sml 124.14-124.19 *)
val Word19.toLarge: Word19.word -> LargeWord.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 115.14-115.20 *)
val Word19.toLargeInt: Word19.word -> LargeInt.int (* @ $(SML_LIB)/basis/integer/embed-word.sml 116.14-116.23 *)
val Word19.toLargeIntX: Word19.word -> LargeInt.int (* @ $(SML_LIB)/basis/integer/embed-word.sml 125.14-125.24 *)
val Word19.toLargeWord: Word19.word -> LargeWord.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 144.11-144.21 *)
val Word19.toLargeWordX: Word19.word -> LargeWord.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 146.11-146.22 *)
val Word19.toLargeX: Word19.word -> LargeWord.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 126.14-126.21 *)
val Word19.toString: Word19.word -> string (* @ $(SML_LIB)/basis/integer/embed-word.sml 117.14-117.21 *)
val Word19.wordSize: int (* @ $(SML_LIB)/basis/integer/embed-word.sml 24.17-24.24 *)
val Word19.xorb: Word19.word * Word19.word -> Word19.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 69.14-69.17 *)
val Word19.~ : Word19.word -> Word19.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 148.11-148.11 *)
val Word19.~>> : Word19.word * word -> Word19.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 81.11-81.13 *)
structure Word2: WORD where type word = Word2.word (* @ $(SML_LIB)/basis/libs/basis-extra/top-level/basis.sml 200.17-200.21 *)
type Word2.word = Word2.word (* @ $(SML_LIB)/basis/primitive/prim-basis.sml 276.12-276.15 *)
val Word2.* : Word2.word * Word2.word -> Word2.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 62.17-62.17 *)
val Word2.+ : Word2.word * Word2.word -> Word2.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 63.17-63.17 *)
val Word2.- : Word2.word * Word2.word -> Word2.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 64.17-64.17 *)
val Word2.< : Word2.word * Word2.word -> bool (* @ $(SML_LIB)/basis/integer/embed-word.sml 87.17-87.17 *)
val Word2.<< : Word2.word * word -> Word2.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 78.14-78.15 *)
val Word2.<= : Word2.word * Word2.word -> bool (* @ $(SML_LIB)/basis/integer/embed-word.sml 88.17-88.18 *)
val Word2.> : Word2.word * Word2.word -> bool (* @ $(SML_LIB)/basis/integer/embed-word.sml 89.17-89.17 *)
val Word2.>= : Word2.word * Word2.word -> bool (* @ $(SML_LIB)/basis/integer/embed-word.sml 90.17-90.18 *)
val Word2.>> : Word2.word * word -> Word2.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 77.14-77.15 *)
val Word2.andb: Word2.word * Word2.word -> Word2.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 65.14-65.17 *)
val Word2.compare: Word2.word * Word2.word -> order (* @ $(SML_LIB)/basis/integer/embed-word.sml 91.14-91.20 *)
val Word2.div: Word2.word * Word2.word -> Word2.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 66.17-66.19 *)
val Word2.fmt: StringCvt.radix -> Word2.word -> string (* @ $(SML_LIB)/basis/integer/embed-word.sml 129.11-129.13 *)
val Word2.fromInt: int -> Word2.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 105.14-105.20 *)
val Word2.fromLarge: LargeWord.word -> Word2.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 106.14-106.22 *)
val Word2.fromLargeInt: LargeInt.int -> Word2.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 107.14-107.25 *)
val Word2.fromLargeWord: LargeWord.word -> Word2.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 131.11-131.23 *)
val Word2.fromString: string -> Word2.word option (* @ $(SML_LIB)/basis/integer/embed-word.sml 133.11-133.20 *)
val Word2.max: Word2.word * Word2.word -> Word2.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 135.11-135.13 *)
val Word2.min: Word2.word * Word2.word -> Word2.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 137.11-137.13 *)
val Word2.mod: Word2.word * Word2.word -> Word2.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 67.17-67.19 *)
val Word2.notb: Word2.word -> Word2.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 98.14-98.17 *)
val Word2.orb: Word2.word * Word2.word -> Word2.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 68.14-68.16 *)
val Word2.scan: StringCvt.radix -> ('a -> (char * 'a) option) -> 'a -> (Word2.word * 'a) option (* @ $(SML_LIB)/basis/integer/embed-word.sml 139.11-139.14 *)
val Word2.toInt: Word2.word -> int (* @ $(SML_LIB)/basis/integer/embed-word.sml 114.14-114.18 *)
val Word2.toIntX: Word2.word -> int (* @ $(SML_LIB)/basis/integer/embed-word.sml 124.14-124.19 *)
val Word2.toLarge: Word2.word -> LargeWord.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 115.14-115.20 *)
val Word2.toLargeInt: Word2.word -> LargeInt.int (* @ $(SML_LIB)/basis/integer/embed-word.sml 116.14-116.23 *)
val Word2.toLargeIntX: Word2.word -> LargeInt.int (* @ $(SML_LIB)/basis/integer/embed-word.sml 125.14-125.24 *)
val Word2.toLargeWord: Word2.word -> LargeWord.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 144.11-144.21 *)
val Word2.toLargeWordX: Word2.word -> LargeWord.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 146.11-146.22 *)
val Word2.toLargeX: Word2.word -> LargeWord.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 126.14-126.21 *)
val Word2.toString: Word2.word -> string (* @ $(SML_LIB)/basis/integer/embed-word.sml 117.14-117.21 *)
val Word2.wordSize: int (* @ $(SML_LIB)/basis/integer/embed-word.sml 24.17-24.24 *)
val Word2.xorb: Word2.word * Word2.word -> Word2.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 69.14-69.17 *)
val Word2.~ : Word2.word -> Word2.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 148.11-148.11 *)
val Word2.~>> : Word2.word * word -> Word2.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 81.11-81.13 *)
structure Word20: WORD where type word = Word20.word (* @ $(SML_LIB)/basis/libs/basis-extra/top-level/basis.sml 218.17-218.22 *)
type Word20.word = Word20.word (* @ $(SML_LIB)/basis/primitive/prim-basis.sml 366.12-366.15 *)
val Word20.* : Word20.word * Word20.word -> Word20.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 62.17-62.17 *)
val Word20.+ : Word20.word * Word20.word -> Word20.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 63.17-63.17 *)
val Word20.- : Word20.word * Word20.word -> Word20.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 64.17-64.17 *)
val Word20.< : Word20.word * Word20.word -> bool (* @ $(SML_LIB)/basis/integer/embed-word.sml 87.17-87.17 *)
val Word20.<< : Word20.word * word -> Word20.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 78.14-78.15 *)
val Word20.<= : Word20.word * Word20.word -> bool (* @ $(SML_LIB)/basis/integer/embed-word.sml 88.17-88.18 *)
val Word20.> : Word20.word * Word20.word -> bool (* @ $(SML_LIB)/basis/integer/embed-word.sml 89.17-89.17 *)
val Word20.>= : Word20.word * Word20.word -> bool (* @ $(SML_LIB)/basis/integer/embed-word.sml 90.17-90.18 *)
val Word20.>> : Word20.word * word -> Word20.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 77.14-77.15 *)
val Word20.andb: Word20.word * Word20.word -> Word20.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 65.14-65.17 *)
val Word20.compare: Word20.word * Word20.word -> order (* @ $(SML_LIB)/basis/integer/embed-word.sml 91.14-91.20 *)
val Word20.div: Word20.word * Word20.word -> Word20.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 66.17-66.19 *)
val Word20.fmt: StringCvt.radix -> Word20.word -> string (* @ $(SML_LIB)/basis/integer/embed-word.sml 129.11-129.13 *)
val Word20.fromInt: int -> Word20.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 105.14-105.20 *)
val Word20.fromLarge: LargeWord.word -> Word20.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 106.14-106.22 *)
val Word20.fromLargeInt: LargeInt.int -> Word20.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 107.14-107.25 *)
val Word20.fromLargeWord: LargeWord.word -> Word20.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 131.11-131.23 *)
val Word20.fromString: string -> Word20.word option (* @ $(SML_LIB)/basis/integer/embed-word.sml 133.11-133.20 *)
val Word20.max: Word20.word * Word20.word -> Word20.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 135.11-135.13 *)
val Word20.min: Word20.word * Word20.word -> Word20.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 137.11-137.13 *)
val Word20.mod: Word20.word * Word20.word -> Word20.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 67.17-67.19 *)
val Word20.notb: Word20.word -> Word20.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 98.14-98.17 *)
val Word20.orb: Word20.word * Word20.word -> Word20.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 68.14-68.16 *)
val Word20.scan: StringCvt.radix -> ('a -> (char * 'a) option) -> 'a -> (Word20.word * 'a) option (* @ $(SML_LIB)/basis/integer/embed-word.sml 139.11-139.14 *)
val Word20.toInt: Word20.word -> int (* @ $(SML_LIB)/basis/integer/embed-word.sml 114.14-114.18 *)
val Word20.toIntX: Word20.word -> int (* @ $(SML_LIB)/basis/integer/embed-word.sml 124.14-124.19 *)
val Word20.toLarge: Word20.word -> LargeWord.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 115.14-115.20 *)
val Word20.toLargeInt: Word20.word -> LargeInt.int (* @ $(SML_LIB)/basis/integer/embed-word.sml 116.14-116.23 *)
val Word20.toLargeIntX: Word20.word -> LargeInt.int (* @ $(SML_LIB)/basis/integer/embed-word.sml 125.14-125.24 *)
val Word20.toLargeWord: Word20.word -> LargeWord.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 144.11-144.21 *)
val Word20.toLargeWordX: Word20.word -> LargeWord.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 146.11-146.22 *)
val Word20.toLargeX: Word20.word -> LargeWord.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 126.14-126.21 *)
val Word20.toString: Word20.word -> string (* @ $(SML_LIB)/basis/integer/embed-word.sml 117.14-117.21 *)
val Word20.wordSize: int (* @ $(SML_LIB)/basis/integer/embed-word.sml 24.17-24.24 *)
val Word20.xorb: Word20.word * Word20.word -> Word20.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 69.14-69.17 *)
val Word20.~ : Word20.word -> Word20.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 148.11-148.11 *)
val Word20.~>> : Word20.word * word -> Word20.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 81.11-81.13 *)
structure Word21: WORD where type word = Word21.word (* @ $(SML_LIB)/basis/libs/basis-extra/top-level/basis.sml 219.17-219.22 *)
type Word21.word = Word21.word (* @ $(SML_LIB)/basis/primitive/prim-basis.sml 371.12-371.15 *)
val Word21.* : Word21.word * Word21.word -> Word21.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 62.17-62.17 *)
val Word21.+ : Word21.word * Word21.word -> Word21.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 63.17-63.17 *)
val Word21.- : Word21.word * Word21.word -> Word21.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 64.17-64.17 *)
val Word21.< : Word21.word * Word21.word -> bool (* @ $(SML_LIB)/basis/integer/embed-word.sml 87.17-87.17 *)
val Word21.<< : Word21.word * word -> Word21.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 78.14-78.15 *)
val Word21.<= : Word21.word * Word21.word -> bool (* @ $(SML_LIB)/basis/integer/embed-word.sml 88.17-88.18 *)
val Word21.> : Word21.word * Word21.word -> bool (* @ $(SML_LIB)/basis/integer/embed-word.sml 89.17-89.17 *)
val Word21.>= : Word21.word * Word21.word -> bool (* @ $(SML_LIB)/basis/integer/embed-word.sml 90.17-90.18 *)
val Word21.>> : Word21.word * word -> Word21.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 77.14-77.15 *)
val Word21.andb: Word21.word * Word21.word -> Word21.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 65.14-65.17 *)
val Word21.compare: Word21.word * Word21.word -> order (* @ $(SML_LIB)/basis/integer/embed-word.sml 91.14-91.20 *)
val Word21.div: Word21.word * Word21.word -> Word21.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 66.17-66.19 *)
val Word21.fmt: StringCvt.radix -> Word21.word -> string (* @ $(SML_LIB)/basis/integer/embed-word.sml 129.11-129.13 *)
val Word21.fromInt: int -> Word21.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 105.14-105.20 *)
val Word21.fromLarge: LargeWord.word -> Word21.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 106.14-106.22 *)
val Word21.fromLargeInt: LargeInt.int -> Word21.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 107.14-107.25 *)
val Word21.fromLargeWord: LargeWord.word -> Word21.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 131.11-131.23 *)
val Word21.fromString: string -> Word21.word option (* @ $(SML_LIB)/basis/integer/embed-word.sml 133.11-133.20 *)
val Word21.max: Word21.word * Word21.word -> Word21.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 135.11-135.13 *)
val Word21.min: Word21.word * Word21.word -> Word21.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 137.11-137.13 *)
val Word21.mod: Word21.word * Word21.word -> Word21.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 67.17-67.19 *)
val Word21.notb: Word21.word -> Word21.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 98.14-98.17 *)
val Word21.orb: Word21.word * Word21.word -> Word21.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 68.14-68.16 *)
val Word21.scan: StringCvt.radix -> ('a -> (char * 'a) option) -> 'a -> (Word21.word * 'a) option (* @ $(SML_LIB)/basis/integer/embed-word.sml 139.11-139.14 *)
val Word21.toInt: Word21.word -> int (* @ $(SML_LIB)/basis/integer/embed-word.sml 114.14-114.18 *)
val Word21.toIntX: Word21.word -> int (* @ $(SML_LIB)/basis/integer/embed-word.sml 124.14-124.19 *)
val Word21.toLarge: Word21.word -> LargeWord.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 115.14-115.20 *)
val Word21.toLargeInt: Word21.word -> LargeInt.int (* @ $(SML_LIB)/basis/integer/embed-word.sml 116.14-116.23 *)
val Word21.toLargeIntX: Word21.word -> LargeInt.int (* @ $(SML_LIB)/basis/integer/embed-word.sml 125.14-125.24 *)
val Word21.toLargeWord: Word21.word -> LargeWord.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 144.11-144.21 *)
val Word21.toLargeWordX: Word21.word -> LargeWord.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 146.11-146.22 *)
val Word21.toLargeX: Word21.word -> LargeWord.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 126.14-126.21 *)
val Word21.toString: Word21.word -> string (* @ $(SML_LIB)/basis/integer/embed-word.sml 117.14-117.21 *)
val Word21.wordSize: int (* @ $(SML_LIB)/basis/integer/embed-word.sml 24.17-24.24 *)
val Word21.xorb: Word21.word * Word21.word -> Word21.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 69.14-69.17 *)
val Word21.~ : Word21.word -> Word21.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 148.11-148.11 *)
val Word21.~>> : Word21.word * word -> Word21.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 81.11-81.13 *)
structure Word22: WORD where type word = Word22.word (* @ $(SML_LIB)/basis/libs/basis-extra/top-level/basis.sml 220.17-220.22 *)
type Word22.word = Word22.word (* @ $(SML_LIB)/basis/primitive/prim-basis.sml 376.12-376.15 *)
val Word22.* : Word22.word * Word22.word -> Word22.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 62.17-62.17 *)
val Word22.+ : Word22.word * Word22.word -> Word22.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 63.17-63.17 *)
val Word22.- : Word22.word * Word22.word -> Word22.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 64.17-64.17 *)
val Word22.< : Word22.word * Word22.word -> bool (* @ $(SML_LIB)/basis/integer/embed-word.sml 87.17-87.17 *)
val Word22.<< : Word22.word * word -> Word22.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 78.14-78.15 *)
val Word22.<= : Word22.word * Word22.word -> bool (* @ $(SML_LIB)/basis/integer/embed-word.sml 88.17-88.18 *)
val Word22.> : Word22.word * Word22.word -> bool (* @ $(SML_LIB)/basis/integer/embed-word.sml 89.17-89.17 *)
val Word22.>= : Word22.word * Word22.word -> bool (* @ $(SML_LIB)/basis/integer/embed-word.sml 90.17-90.18 *)
val Word22.>> : Word22.word * word -> Word22.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 77.14-77.15 *)
val Word22.andb: Word22.word * Word22.word -> Word22.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 65.14-65.17 *)
val Word22.compare: Word22.word * Word22.word -> order (* @ $(SML_LIB)/basis/integer/embed-word.sml 91.14-91.20 *)
val Word22.div: Word22.word * Word22.word -> Word22.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 66.17-66.19 *)
val Word22.fmt: StringCvt.radix -> Word22.word -> string (* @ $(SML_LIB)/basis/integer/embed-word.sml 129.11-129.13 *)
val Word22.fromInt: int -> Word22.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 105.14-105.20 *)
val Word22.fromLarge: LargeWord.word -> Word22.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 106.14-106.22 *)
val Word22.fromLargeInt: LargeInt.int -> Word22.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 107.14-107.25 *)
val Word22.fromLargeWord: LargeWord.word -> Word22.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 131.11-131.23 *)
val Word22.fromString: string -> Word22.word option (* @ $(SML_LIB)/basis/integer/embed-word.sml 133.11-133.20 *)
val Word22.max: Word22.word * Word22.word -> Word22.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 135.11-135.13 *)
val Word22.min: Word22.word * Word22.word -> Word22.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 137.11-137.13 *)
val Word22.mod: Word22.word * Word22.word -> Word22.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 67.17-67.19 *)
val Word22.notb: Word22.word -> Word22.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 98.14-98.17 *)
val Word22.orb: Word22.word * Word22.word -> Word22.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 68.14-68.16 *)
val Word22.scan: StringCvt.radix -> ('a -> (char * 'a) option) -> 'a -> (Word22.word * 'a) option (* @ $(SML_LIB)/basis/integer/embed-word.sml 139.11-139.14 *)
val Word22.toInt: Word22.word -> int (* @ $(SML_LIB)/basis/integer/embed-word.sml 114.14-114.18 *)
val Word22.toIntX: Word22.word -> int (* @ $(SML_LIB)/basis/integer/embed-word.sml 124.14-124.19 *)
val Word22.toLarge: Word22.word -> LargeWord.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 115.14-115.20 *)
val Word22.toLargeInt: Word22.word -> LargeInt.int (* @ $(SML_LIB)/basis/integer/embed-word.sml 116.14-116.23 *)
val Word22.toLargeIntX: Word22.word -> LargeInt.int (* @ $(SML_LIB)/basis/integer/embed-word.sml 125.14-125.24 *)
val Word22.toLargeWord: Word22.word -> LargeWord.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 144.11-144.21 *)
val Word22.toLargeWordX: Word22.word -> LargeWord.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 146.11-146.22 *)
val Word22.toLargeX: Word22.word -> LargeWord.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 126.14-126.21 *)
val Word22.toString: Word22.word -> string (* @ $(SML_LIB)/basis/integer/embed-word.sml 117.14-117.21 *)
val Word22.wordSize: int (* @ $(SML_LIB)/basis/integer/embed-word.sml 24.17-24.24 *)
val Word22.xorb: Word22.word * Word22.word -> Word22.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 69.14-69.17 *)
val Word22.~ : Word22.word -> Word22.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 148.11-148.11 *)
val Word22.~>> : Word22.word * word -> Word22.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 81.11-81.13 *)
structure Word23: WORD where type word = Word23.word (* @ $(SML_LIB)/basis/libs/basis-extra/top-level/basis.sml 221.17-221.22 *)
type Word23.word = Word23.word (* @ $(SML_LIB)/basis/primitive/prim-basis.sml 381.12-381.15 *)
val Word23.* : Word23.word * Word23.word -> Word23.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 62.17-62.17 *)
val Word23.+ : Word23.word * Word23.word -> Word23.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 63.17-63.17 *)
val Word23.- : Word23.word * Word23.word -> Word23.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 64.17-64.17 *)
val Word23.< : Word23.word * Word23.word -> bool (* @ $(SML_LIB)/basis/integer/embed-word.sml 87.17-87.17 *)
val Word23.<< : Word23.word * word -> Word23.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 78.14-78.15 *)
val Word23.<= : Word23.word * Word23.word -> bool (* @ $(SML_LIB)/basis/integer/embed-word.sml 88.17-88.18 *)
val Word23.> : Word23.word * Word23.word -> bool (* @ $(SML_LIB)/basis/integer/embed-word.sml 89.17-89.17 *)
val Word23.>= : Word23.word * Word23.word -> bool (* @ $(SML_LIB)/basis/integer/embed-word.sml 90.17-90.18 *)
val Word23.>> : Word23.word * word -> Word23.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 77.14-77.15 *)
val Word23.andb: Word23.word * Word23.word -> Word23.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 65.14-65.17 *)
val Word23.compare: Word23.word * Word23.word -> order (* @ $(SML_LIB)/basis/integer/embed-word.sml 91.14-91.20 *)
val Word23.div: Word23.word * Word23.word -> Word23.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 66.17-66.19 *)
val Word23.fmt: StringCvt.radix -> Word23.word -> string (* @ $(SML_LIB)/basis/integer/embed-word.sml 129.11-129.13 *)
val Word23.fromInt: int -> Word23.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 105.14-105.20 *)
val Word23.fromLarge: LargeWord.word -> Word23.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 106.14-106.22 *)
val Word23.fromLargeInt: LargeInt.int -> Word23.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 107.14-107.25 *)
val Word23.fromLargeWord: LargeWord.word -> Word23.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 131.11-131.23 *)
val Word23.fromString: string -> Word23.word option (* @ $(SML_LIB)/basis/integer/embed-word.sml 133.11-133.20 *)
val Word23.max: Word23.word * Word23.word -> Word23.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 135.11-135.13 *)
val Word23.min: Word23.word * Word23.word -> Word23.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 137.11-137.13 *)
val Word23.mod: Word23.word * Word23.word -> Word23.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 67.17-67.19 *)
val Word23.notb: Word23.word -> Word23.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 98.14-98.17 *)
val Word23.orb: Word23.word * Word23.word -> Word23.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 68.14-68.16 *)
val Word23.scan: StringCvt.radix -> ('a -> (char * 'a) option) -> 'a -> (Word23.word * 'a) option (* @ $(SML_LIB)/basis/integer/embed-word.sml 139.11-139.14 *)
val Word23.toInt: Word23.word -> int (* @ $(SML_LIB)/basis/integer/embed-word.sml 114.14-114.18 *)
val Word23.toIntX: Word23.word -> int (* @ $(SML_LIB)/basis/integer/embed-word.sml 124.14-124.19 *)
val Word23.toLarge: Word23.word -> LargeWord.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 115.14-115.20 *)
val Word23.toLargeInt: Word23.word -> LargeInt.int (* @ $(SML_LIB)/basis/integer/embed-word.sml 116.14-116.23 *)
val Word23.toLargeIntX: Word23.word -> LargeInt.int (* @ $(SML_LIB)/basis/integer/embed-word.sml 125.14-125.24 *)
val Word23.toLargeWord: Word23.word -> LargeWord.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 144.11-144.21 *)
val Word23.toLargeWordX: Word23.word -> LargeWord.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 146.11-146.22 *)
val Word23.toLargeX: Word23.word -> LargeWord.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 126.14-126.21 *)
val Word23.toString: Word23.word -> string (* @ $(SML_LIB)/basis/integer/embed-word.sml 117.14-117.21 *)
val Word23.wordSize: int (* @ $(SML_LIB)/basis/integer/embed-word.sml 24.17-24.24 *)
val Word23.xorb: Word23.word * Word23.word -> Word23.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 69.14-69.17 *)
val Word23.~ : Word23.word -> Word23.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 148.11-148.11 *)
val Word23.~>> : Word23.word * word -> Word23.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 81.11-81.13 *)
structure Word24: WORD where type word = Word24.word (* @ $(SML_LIB)/basis/libs/basis-extra/top-level/basis.sml 222.17-222.22 *)
type Word24.word = Word24.word (* @ $(SML_LIB)/basis/primitive/prim-basis.sml 386.12-386.15 *)
val Word24.* : Word24.word * Word24.word -> Word24.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 62.17-62.17 *)
val Word24.+ : Word24.word * Word24.word -> Word24.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 63.17-63.17 *)
val Word24.- : Word24.word * Word24.word -> Word24.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 64.17-64.17 *)
val Word24.< : Word24.word * Word24.word -> bool (* @ $(SML_LIB)/basis/integer/embed-word.sml 87.17-87.17 *)
val Word24.<< : Word24.word * word -> Word24.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 78.14-78.15 *)
val Word24.<= : Word24.word * Word24.word -> bool (* @ $(SML_LIB)/basis/integer/embed-word.sml 88.17-88.18 *)
val Word24.> : Word24.word * Word24.word -> bool (* @ $(SML_LIB)/basis/integer/embed-word.sml 89.17-89.17 *)
val Word24.>= : Word24.word * Word24.word -> bool (* @ $(SML_LIB)/basis/integer/embed-word.sml 90.17-90.18 *)
val Word24.>> : Word24.word * word -> Word24.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 77.14-77.15 *)
val Word24.andb: Word24.word * Word24.word -> Word24.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 65.14-65.17 *)
val Word24.compare: Word24.word * Word24.word -> order (* @ $(SML_LIB)/basis/integer/embed-word.sml 91.14-91.20 *)
val Word24.div: Word24.word * Word24.word -> Word24.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 66.17-66.19 *)
val Word24.fmt: StringCvt.radix -> Word24.word -> string (* @ $(SML_LIB)/basis/integer/embed-word.sml 129.11-129.13 *)
val Word24.fromInt: int -> Word24.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 105.14-105.20 *)
val Word24.fromLarge: LargeWord.word -> Word24.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 106.14-106.22 *)
val Word24.fromLargeInt: LargeInt.int -> Word24.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 107.14-107.25 *)
val Word24.fromLargeWord: LargeWord.word -> Word24.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 131.11-131.23 *)
val Word24.fromString: string -> Word24.word option (* @ $(SML_LIB)/basis/integer/embed-word.sml 133.11-133.20 *)
val Word24.max: Word24.word * Word24.word -> Word24.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 135.11-135.13 *)
val Word24.min: Word24.word * Word24.word -> Word24.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 137.11-137.13 *)
val Word24.mod: Word24.word * Word24.word -> Word24.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 67.17-67.19 *)
val Word24.notb: Word24.word -> Word24.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 98.14-98.17 *)
val Word24.orb: Word24.word * Word24.word -> Word24.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 68.14-68.16 *)
val Word24.scan: StringCvt.radix -> ('a -> (char * 'a) option) -> 'a -> (Word24.word * 'a) option (* @ $(SML_LIB)/basis/integer/embed-word.sml 139.11-139.14 *)
val Word24.toInt: Word24.word -> int (* @ $(SML_LIB)/basis/integer/embed-word.sml 114.14-114.18 *)
val Word24.toIntX: Word24.word -> int (* @ $(SML_LIB)/basis/integer/embed-word.sml 124.14-124.19 *)
val Word24.toLarge: Word24.word -> LargeWord.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 115.14-115.20 *)
val Word24.toLargeInt: Word24.word -> LargeInt.int (* @ $(SML_LIB)/basis/integer/embed-word.sml 116.14-116.23 *)
val Word24.toLargeIntX: Word24.word -> LargeInt.int (* @ $(SML_LIB)/basis/integer/embed-word.sml 125.14-125.24 *)
val Word24.toLargeWord: Word24.word -> LargeWord.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 144.11-144.21 *)
val Word24.toLargeWordX: Word24.word -> LargeWord.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 146.11-146.22 *)
val Word24.toLargeX: Word24.word -> LargeWord.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 126.14-126.21 *)
val Word24.toString: Word24.word -> string (* @ $(SML_LIB)/basis/integer/embed-word.sml 117.14-117.21 *)
val Word24.wordSize: int (* @ $(SML_LIB)/basis/integer/embed-word.sml 24.17-24.24 *)
val Word24.xorb: Word24.word * Word24.word -> Word24.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 69.14-69.17 *)
val Word24.~ : Word24.word -> Word24.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 148.11-148.11 *)
val Word24.~>> : Word24.word * word -> Word24.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 81.11-81.13 *)
structure Word25: WORD where type word = Word25.word (* @ $(SML_LIB)/basis/libs/basis-extra/top-level/basis.sml 223.17-223.22 *)
type Word25.word = Word25.word (* @ $(SML_LIB)/basis/primitive/prim-basis.sml 391.12-391.15 *)
val Word25.* : Word25.word * Word25.word -> Word25.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 62.17-62.17 *)
val Word25.+ : Word25.word * Word25.word -> Word25.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 63.17-63.17 *)
val Word25.- : Word25.word * Word25.word -> Word25.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 64.17-64.17 *)
val Word25.< : Word25.word * Word25.word -> bool (* @ $(SML_LIB)/basis/integer/embed-word.sml 87.17-87.17 *)
val Word25.<< : Word25.word * word -> Word25.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 78.14-78.15 *)
val Word25.<= : Word25.word * Word25.word -> bool (* @ $(SML_LIB)/basis/integer/embed-word.sml 88.17-88.18 *)
val Word25.> : Word25.word * Word25.word -> bool (* @ $(SML_LIB)/basis/integer/embed-word.sml 89.17-89.17 *)
val Word25.>= : Word25.word * Word25.word -> bool (* @ $(SML_LIB)/basis/integer/embed-word.sml 90.17-90.18 *)
val Word25.>> : Word25.word * word -> Word25.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 77.14-77.15 *)
val Word25.andb: Word25.word * Word25.word -> Word25.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 65.14-65.17 *)
val Word25.compare: Word25.word * Word25.word -> order (* @ $(SML_LIB)/basis/integer/embed-word.sml 91.14-91.20 *)
val Word25.div: Word25.word * Word25.word -> Word25.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 66.17-66.19 *)
val Word25.fmt: StringCvt.radix -> Word25.word -> string (* @ $(SML_LIB)/basis/integer/embed-word.sml 129.11-129.13 *)
val Word25.fromInt: int -> Word25.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 105.14-105.20 *)
val Word25.fromLarge: LargeWord.word -> Word25.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 106.14-106.22 *)
val Word25.fromLargeInt: LargeInt.int -> Word25.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 107.14-107.25 *)
val Word25.fromLargeWord: LargeWord.word -> Word25.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 131.11-131.23 *)
val Word25.fromString: string -> Word25.word option (* @ $(SML_LIB)/basis/integer/embed-word.sml 133.11-133.20 *)
val Word25.max: Word25.word * Word25.word -> Word25.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 135.11-135.13 *)
val Word25.min: Word25.word * Word25.word -> Word25.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 137.11-137.13 *)
val Word25.mod: Word25.word * Word25.word -> Word25.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 67.17-67.19 *)
val Word25.notb: Word25.word -> Word25.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 98.14-98.17 *)
val Word25.orb: Word25.word * Word25.word -> Word25.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 68.14-68.16 *)
val Word25.scan: StringCvt.radix -> ('a -> (char * 'a) option) -> 'a -> (Word25.word * 'a) option (* @ $(SML_LIB)/basis/integer/embed-word.sml 139.11-139.14 *)
val Word25.toInt: Word25.word -> int (* @ $(SML_LIB)/basis/integer/embed-word.sml 114.14-114.18 *)
val Word25.toIntX: Word25.word -> int (* @ $(SML_LIB)/basis/integer/embed-word.sml 124.14-124.19 *)
val Word25.toLarge: Word25.word -> LargeWord.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 115.14-115.20 *)
val Word25.toLargeInt: Word25.word -> LargeInt.int (* @ $(SML_LIB)/basis/integer/embed-word.sml 116.14-116.23 *)
val Word25.toLargeIntX: Word25.word -> LargeInt.int (* @ $(SML_LIB)/basis/integer/embed-word.sml 125.14-125.24 *)
val Word25.toLargeWord: Word25.word -> LargeWord.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 144.11-144.21 *)
val Word25.toLargeWordX: Word25.word -> LargeWord.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 146.11-146.22 *)
val Word25.toLargeX: Word25.word -> LargeWord.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 126.14-126.21 *)
val Word25.toString: Word25.word -> string (* @ $(SML_LIB)/basis/integer/embed-word.sml 117.14-117.21 *)
val Word25.wordSize: int (* @ $(SML_LIB)/basis/integer/embed-word.sml 24.17-24.24 *)
val Word25.xorb: Word25.word * Word25.word -> Word25.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 69.14-69.17 *)
val Word25.~ : Word25.word -> Word25.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 148.11-148.11 *)
val Word25.~>> : Word25.word * word -> Word25.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 81.11-81.13 *)
structure Word26: WORD where type word = Word26.word (* @ $(SML_LIB)/basis/libs/basis-extra/top-level/basis.sml 224.17-224.22 *)
type Word26.word = Word26.word (* @ $(SML_LIB)/basis/primitive/prim-basis.sml 396.12-396.15 *)
val Word26.* : Word26.word * Word26.word -> Word26.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 62.17-62.17 *)
val Word26.+ : Word26.word * Word26.word -> Word26.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 63.17-63.17 *)
val Word26.- : Word26.word * Word26.word -> Word26.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 64.17-64.17 *)
val Word26.< : Word26.word * Word26.word -> bool (* @ $(SML_LIB)/basis/integer/embed-word.sml 87.17-87.17 *)
val Word26.<< : Word26.word * word -> Word26.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 78.14-78.15 *)
val Word26.<= : Word26.word * Word26.word -> bool (* @ $(SML_LIB)/basis/integer/embed-word.sml 88.17-88.18 *)
val Word26.> : Word26.word * Word26.word -> bool (* @ $(SML_LIB)/basis/integer/embed-word.sml 89.17-89.17 *)
val Word26.>= : Word26.word * Word26.word -> bool (* @ $(SML_LIB)/basis/integer/embed-word.sml 90.17-90.18 *)
val Word26.>> : Word26.word * word -> Word26.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 77.14-77.15 *)
val Word26.andb: Word26.word * Word26.word -> Word26.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 65.14-65.17 *)
val Word26.compare: Word26.word * Word26.word -> order (* @ $(SML_LIB)/basis/integer/embed-word.sml 91.14-91.20 *)
val Word26.div: Word26.word * Word26.word -> Word26.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 66.17-66.19 *)
val Word26.fmt: StringCvt.radix -> Word26.word -> string (* @ $(SML_LIB)/basis/integer/embed-word.sml 129.11-129.13 *)
val Word26.fromInt: int -> Word26.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 105.14-105.20 *)
val Word26.fromLarge: LargeWord.word -> Word26.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 106.14-106.22 *)
val Word26.fromLargeInt: LargeInt.int -> Word26.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 107.14-107.25 *)
val Word26.fromLargeWord: LargeWord.word -> Word26.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 131.11-131.23 *)
val Word26.fromString: string -> Word26.word option (* @ $(SML_LIB)/basis/integer/embed-word.sml 133.11-133.20 *)
val Word26.max: Word26.word * Word26.word -> Word26.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 135.11-135.13 *)
val Word26.min: Word26.word * Word26.word -> Word26.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 137.11-137.13 *)
val Word26.mod: Word26.word * Word26.word -> Word26.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 67.17-67.19 *)
val Word26.notb: Word26.word -> Word26.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 98.14-98.17 *)
val Word26.orb: Word26.word * Word26.word -> Word26.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 68.14-68.16 *)
val Word26.scan: StringCvt.radix -> ('a -> (char * 'a) option) -> 'a -> (Word26.word * 'a) option (* @ $(SML_LIB)/basis/integer/embed-word.sml 139.11-139.14 *)
val Word26.toInt: Word26.word -> int (* @ $(SML_LIB)/basis/integer/embed-word.sml 114.14-114.18 *)
val Word26.toIntX: Word26.word -> int (* @ $(SML_LIB)/basis/integer/embed-word.sml 124.14-124.19 *)
val Word26.toLarge: Word26.word -> LargeWord.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 115.14-115.20 *)
val Word26.toLargeInt: Word26.word -> LargeInt.int (* @ $(SML_LIB)/basis/integer/embed-word.sml 116.14-116.23 *)
val Word26.toLargeIntX: Word26.word -> LargeInt.int (* @ $(SML_LIB)/basis/integer/embed-word.sml 125.14-125.24 *)
val Word26.toLargeWord: Word26.word -> LargeWord.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 144.11-144.21 *)
val Word26.toLargeWordX: Word26.word -> LargeWord.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 146.11-146.22 *)
val Word26.toLargeX: Word26.word -> LargeWord.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 126.14-126.21 *)
val Word26.toString: Word26.word -> string (* @ $(SML_LIB)/basis/integer/embed-word.sml 117.14-117.21 *)
val Word26.wordSize: int (* @ $(SML_LIB)/basis/integer/embed-word.sml 24.17-24.24 *)
val Word26.xorb: Word26.word * Word26.word -> Word26.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 69.14-69.17 *)
val Word26.~ : Word26.word -> Word26.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 148.11-148.11 *)
val Word26.~>> : Word26.word * word -> Word26.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 81.11-81.13 *)
structure Word27: WORD where type word = Word27.word (* @ $(SML_LIB)/basis/libs/basis-extra/top-level/basis.sml 225.17-225.22 *)
type Word27.word = Word27.word (* @ $(SML_LIB)/basis/primitive/prim-basis.sml 401.12-401.15 *)
val Word27.* : Word27.word * Word27.word -> Word27.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 62.17-62.17 *)
val Word27.+ : Word27.word * Word27.word -> Word27.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 63.17-63.17 *)
val Word27.- : Word27.word * Word27.word -> Word27.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 64.17-64.17 *)
val Word27.< : Word27.word * Word27.word -> bool (* @ $(SML_LIB)/basis/integer/embed-word.sml 87.17-87.17 *)
val Word27.<< : Word27.word * word -> Word27.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 78.14-78.15 *)
val Word27.<= : Word27.word * Word27.word -> bool (* @ $(SML_LIB)/basis/integer/embed-word.sml 88.17-88.18 *)
val Word27.> : Word27.word * Word27.word -> bool (* @ $(SML_LIB)/basis/integer/embed-word.sml 89.17-89.17 *)
val Word27.>= : Word27.word * Word27.word -> bool (* @ $(SML_LIB)/basis/integer/embed-word.sml 90.17-90.18 *)
val Word27.>> : Word27.word * word -> Word27.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 77.14-77.15 *)
val Word27.andb: Word27.word * Word27.word -> Word27.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 65.14-65.17 *)
val Word27.compare: Word27.word * Word27.word -> order (* @ $(SML_LIB)/basis/integer/embed-word.sml 91.14-91.20 *)
val Word27.div: Word27.word * Word27.word -> Word27.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 66.17-66.19 *)
val Word27.fmt: StringCvt.radix -> Word27.word -> string (* @ $(SML_LIB)/basis/integer/embed-word.sml 129.11-129.13 *)
val Word27.fromInt: int -> Word27.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 105.14-105.20 *)
val Word27.fromLarge: LargeWord.word -> Word27.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 106.14-106.22 *)
val Word27.fromLargeInt: LargeInt.int -> Word27.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 107.14-107.25 *)
val Word27.fromLargeWord: LargeWord.word -> Word27.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 131.11-131.23 *)
val Word27.fromString: string -> Word27.word option (* @ $(SML_LIB)/basis/integer/embed-word.sml 133.11-133.20 *)
val Word27.max: Word27.word * Word27.word -> Word27.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 135.11-135.13 *)
val Word27.min: Word27.word * Word27.word -> Word27.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 137.11-137.13 *)
val Word27.mod: Word27.word * Word27.word -> Word27.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 67.17-67.19 *)
val Word27.notb: Word27.word -> Word27.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 98.14-98.17 *)
val Word27.orb: Word27.word * Word27.word -> Word27.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 68.14-68.16 *)
val Word27.scan: StringCvt.radix -> ('a -> (char * 'a) option) -> 'a -> (Word27.word * 'a) option (* @ $(SML_LIB)/basis/integer/embed-word.sml 139.11-139.14 *)
val Word27.toInt: Word27.word -> int (* @ $(SML_LIB)/basis/integer/embed-word.sml 114.14-114.18 *)
val Word27.toIntX: Word27.word -> int (* @ $(SML_LIB)/basis/integer/embed-word.sml 124.14-124.19 *)
val Word27.toLarge: Word27.word -> LargeWord.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 115.14-115.20 *)
val Word27.toLargeInt: Word27.word -> LargeInt.int (* @ $(SML_LIB)/basis/integer/embed-word.sml 116.14-116.23 *)
val Word27.toLargeIntX: Word27.word -> LargeInt.int (* @ $(SML_LIB)/basis/integer/embed-word.sml 125.14-125.24 *)
val Word27.toLargeWord: Word27.word -> LargeWord.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 144.11-144.21 *)
val Word27.toLargeWordX: Word27.word -> LargeWord.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 146.11-146.22 *)
val Word27.toLargeX: Word27.word -> LargeWord.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 126.14-126.21 *)
val Word27.toString: Word27.word -> string (* @ $(SML_LIB)/basis/integer/embed-word.sml 117.14-117.21 *)
val Word27.wordSize: int (* @ $(SML_LIB)/basis/integer/embed-word.sml 24.17-24.24 *)
val Word27.xorb: Word27.word * Word27.word -> Word27.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 69.14-69.17 *)
val Word27.~ : Word27.word -> Word27.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 148.11-148.11 *)
val Word27.~>> : Word27.word * word -> Word27.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 81.11-81.13 *)
structure Word28: WORD where type word = Word28.word (* @ $(SML_LIB)/basis/libs/basis-extra/top-level/basis.sml 226.17-226.22 *)
type Word28.word = Word28.word (* @ $(SML_LIB)/basis/primitive/prim-basis.sml 406.12-406.15 *)
val Word28.* : Word28.word * Word28.word -> Word28.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 62.17-62.17 *)
val Word28.+ : Word28.word * Word28.word -> Word28.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 63.17-63.17 *)
val Word28.- : Word28.word * Word28.word -> Word28.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 64.17-64.17 *)
val Word28.< : Word28.word * Word28.word -> bool (* @ $(SML_LIB)/basis/integer/embed-word.sml 87.17-87.17 *)
val Word28.<< : Word28.word * word -> Word28.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 78.14-78.15 *)
val Word28.<= : Word28.word * Word28.word -> bool (* @ $(SML_LIB)/basis/integer/embed-word.sml 88.17-88.18 *)
val Word28.> : Word28.word * Word28.word -> bool (* @ $(SML_LIB)/basis/integer/embed-word.sml 89.17-89.17 *)
val Word28.>= : Word28.word * Word28.word -> bool (* @ $(SML_LIB)/basis/integer/embed-word.sml 90.17-90.18 *)
val Word28.>> : Word28.word * word -> Word28.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 77.14-77.15 *)
val Word28.andb: Word28.word * Word28.word -> Word28.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 65.14-65.17 *)
val Word28.compare: Word28.word * Word28.word -> order (* @ $(SML_LIB)/basis/integer/embed-word.sml 91.14-91.20 *)
val Word28.div: Word28.word * Word28.word -> Word28.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 66.17-66.19 *)
val Word28.fmt: StringCvt.radix -> Word28.word -> string (* @ $(SML_LIB)/basis/integer/embed-word.sml 129.11-129.13 *)
val Word28.fromInt: int -> Word28.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 105.14-105.20 *)
val Word28.fromLarge: LargeWord.word -> Word28.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 106.14-106.22 *)
val Word28.fromLargeInt: LargeInt.int -> Word28.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 107.14-107.25 *)
val Word28.fromLargeWord: LargeWord.word -> Word28.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 131.11-131.23 *)
val Word28.fromString: string -> Word28.word option (* @ $(SML_LIB)/basis/integer/embed-word.sml 133.11-133.20 *)
val Word28.max: Word28.word * Word28.word -> Word28.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 135.11-135.13 *)
val Word28.min: Word28.word * Word28.word -> Word28.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 137.11-137.13 *)
val Word28.mod: Word28.word * Word28.word -> Word28.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 67.17-67.19 *)
val Word28.notb: Word28.word -> Word28.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 98.14-98.17 *)
val Word28.orb: Word28.word * Word28.word -> Word28.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 68.14-68.16 *)
val Word28.scan: StringCvt.radix -> ('a -> (char * 'a) option) -> 'a -> (Word28.word * 'a) option (* @ $(SML_LIB)/basis/integer/embed-word.sml 139.11-139.14 *)
val Word28.toInt: Word28.word -> int (* @ $(SML_LIB)/basis/integer/embed-word.sml 114.14-114.18 *)
val Word28.toIntX: Word28.word -> int (* @ $(SML_LIB)/basis/integer/embed-word.sml 124.14-124.19 *)
val Word28.toLarge: Word28.word -> LargeWord.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 115.14-115.20 *)
val Word28.toLargeInt: Word28.word -> LargeInt.int (* @ $(SML_LIB)/basis/integer/embed-word.sml 116.14-116.23 *)
val Word28.toLargeIntX: Word28.word -> LargeInt.int (* @ $(SML_LIB)/basis/integer/embed-word.sml 125.14-125.24 *)
val Word28.toLargeWord: Word28.word -> LargeWord.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 144.11-144.21 *)
val Word28.toLargeWordX: Word28.word -> LargeWord.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 146.11-146.22 *)
val Word28.toLargeX: Word28.word -> LargeWord.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 126.14-126.21 *)
val Word28.toString: Word28.word -> string (* @ $(SML_LIB)/basis/integer/embed-word.sml 117.14-117.21 *)
val Word28.wordSize: int (* @ $(SML_LIB)/basis/integer/embed-word.sml 24.17-24.24 *)
val Word28.xorb: Word28.word * Word28.word -> Word28.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 69.14-69.17 *)
val Word28.~ : Word28.word -> Word28.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 148.11-148.11 *)
val Word28.~>> : Word28.word * word -> Word28.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 81.11-81.13 *)
structure Word29: WORD where type word = Word29.word (* @ $(SML_LIB)/basis/libs/basis-extra/top-level/basis.sml 227.17-227.22 *)
type Word29.word = Word29.word (* @ $(SML_LIB)/basis/primitive/prim-basis.sml 411.12-411.15 *)
val Word29.* : Word29.word * Word29.word -> Word29.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 62.17-62.17 *)
val Word29.+ : Word29.word * Word29.word -> Word29.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 63.17-63.17 *)
val Word29.- : Word29.word * Word29.word -> Word29.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 64.17-64.17 *)
val Word29.< : Word29.word * Word29.word -> bool (* @ $(SML_LIB)/basis/integer/embed-word.sml 87.17-87.17 *)
val Word29.<< : Word29.word * word -> Word29.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 78.14-78.15 *)
val Word29.<= : Word29.word * Word29.word -> bool (* @ $(SML_LIB)/basis/integer/embed-word.sml 88.17-88.18 *)
val Word29.> : Word29.word * Word29.word -> bool (* @ $(SML_LIB)/basis/integer/embed-word.sml 89.17-89.17 *)
val Word29.>= : Word29.word * Word29.word -> bool (* @ $(SML_LIB)/basis/integer/embed-word.sml 90.17-90.18 *)
val Word29.>> : Word29.word * word -> Word29.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 77.14-77.15 *)
val Word29.andb: Word29.word * Word29.word -> Word29.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 65.14-65.17 *)
val Word29.compare: Word29.word * Word29.word -> order (* @ $(SML_LIB)/basis/integer/embed-word.sml 91.14-91.20 *)
val Word29.div: Word29.word * Word29.word -> Word29.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 66.17-66.19 *)
val Word29.fmt: StringCvt.radix -> Word29.word -> string (* @ $(SML_LIB)/basis/integer/embed-word.sml 129.11-129.13 *)
val Word29.fromInt: int -> Word29.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 105.14-105.20 *)
val Word29.fromLarge: LargeWord.word -> Word29.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 106.14-106.22 *)
val Word29.fromLargeInt: LargeInt.int -> Word29.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 107.14-107.25 *)
val Word29.fromLargeWord: LargeWord.word -> Word29.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 131.11-131.23 *)
val Word29.fromString: string -> Word29.word option (* @ $(SML_LIB)/basis/integer/embed-word.sml 133.11-133.20 *)
val Word29.max: Word29.word * Word29.word -> Word29.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 135.11-135.13 *)
val Word29.min: Word29.word * Word29.word -> Word29.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 137.11-137.13 *)
val Word29.mod: Word29.word * Word29.word -> Word29.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 67.17-67.19 *)
val Word29.notb: Word29.word -> Word29.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 98.14-98.17 *)
val Word29.orb: Word29.word * Word29.word -> Word29.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 68.14-68.16 *)
val Word29.scan: StringCvt.radix -> ('a -> (char * 'a) option) -> 'a -> (Word29.word * 'a) option (* @ $(SML_LIB)/basis/integer/embed-word.sml 139.11-139.14 *)
val Word29.toInt: Word29.word -> int (* @ $(SML_LIB)/basis/integer/embed-word.sml 114.14-114.18 *)
val Word29.toIntX: Word29.word -> int (* @ $(SML_LIB)/basis/integer/embed-word.sml 124.14-124.19 *)
val Word29.toLarge: Word29.word -> LargeWord.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 115.14-115.20 *)
val Word29.toLargeInt: Word29.word -> LargeInt.int (* @ $(SML_LIB)/basis/integer/embed-word.sml 116.14-116.23 *)
val Word29.toLargeIntX: Word29.word -> LargeInt.int (* @ $(SML_LIB)/basis/integer/embed-word.sml 125.14-125.24 *)
val Word29.toLargeWord: Word29.word -> LargeWord.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 144.11-144.21 *)
val Word29.toLargeWordX: Word29.word -> LargeWord.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 146.11-146.22 *)
val Word29.toLargeX: Word29.word -> LargeWord.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 126.14-126.21 *)
val Word29.toString: Word29.word -> string (* @ $(SML_LIB)/basis/integer/embed-word.sml 117.14-117.21 *)
val Word29.wordSize: int (* @ $(SML_LIB)/basis/integer/embed-word.sml 24.17-24.24 *)
val Word29.xorb: Word29.word * Word29.word -> Word29.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 69.14-69.17 *)
val Word29.~ : Word29.word -> Word29.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 148.11-148.11 *)
val Word29.~>> : Word29.word * word -> Word29.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 81.11-81.13 *)
structure Word3: WORD where type word = Word3.word (* @ $(SML_LIB)/basis/libs/basis-extra/top-level/basis.sml 201.17-201.21 *)
type Word3.word = Word3.word (* @ $(SML_LIB)/basis/primitive/prim-basis.sml 281.12-281.15 *)
val Word3.* : Word3.word * Word3.word -> Word3.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 62.17-62.17 *)
val Word3.+ : Word3.word * Word3.word -> Word3.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 63.17-63.17 *)
val Word3.- : Word3.word * Word3.word -> Word3.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 64.17-64.17 *)
val Word3.< : Word3.word * Word3.word -> bool (* @ $(SML_LIB)/basis/integer/embed-word.sml 87.17-87.17 *)
val Word3.<< : Word3.word * word -> Word3.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 78.14-78.15 *)
val Word3.<= : Word3.word * Word3.word -> bool (* @ $(SML_LIB)/basis/integer/embed-word.sml 88.17-88.18 *)
val Word3.> : Word3.word * Word3.word -> bool (* @ $(SML_LIB)/basis/integer/embed-word.sml 89.17-89.17 *)
val Word3.>= : Word3.word * Word3.word -> bool (* @ $(SML_LIB)/basis/integer/embed-word.sml 90.17-90.18 *)
val Word3.>> : Word3.word * word -> Word3.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 77.14-77.15 *)
val Word3.andb: Word3.word * Word3.word -> Word3.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 65.14-65.17 *)
val Word3.compare: Word3.word * Word3.word -> order (* @ $(SML_LIB)/basis/integer/embed-word.sml 91.14-91.20 *)
val Word3.div: Word3.word * Word3.word -> Word3.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 66.17-66.19 *)
val Word3.fmt: StringCvt.radix -> Word3.word -> string (* @ $(SML_LIB)/basis/integer/embed-word.sml 129.11-129.13 *)
val Word3.fromInt: int -> Word3.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 105.14-105.20 *)
val Word3.fromLarge: LargeWord.word -> Word3.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 106.14-106.22 *)
val Word3.fromLargeInt: LargeInt.int -> Word3.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 107.14-107.25 *)
val Word3.fromLargeWord: LargeWord.word -> Word3.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 131.11-131.23 *)
val Word3.fromString: string -> Word3.word option (* @ $(SML_LIB)/basis/integer/embed-word.sml 133.11-133.20 *)
val Word3.max: Word3.word * Word3.word -> Word3.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 135.11-135.13 *)
val Word3.min: Word3.word * Word3.word -> Word3.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 137.11-137.13 *)
val Word3.mod: Word3.word * Word3.word -> Word3.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 67.17-67.19 *)
val Word3.notb: Word3.word -> Word3.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 98.14-98.17 *)
val Word3.orb: Word3.word * Word3.word -> Word3.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 68.14-68.16 *)
val Word3.scan: StringCvt.radix -> ('a -> (char * 'a) option) -> 'a -> (Word3.word * 'a) option (* @ $(SML_LIB)/basis/integer/embed-word.sml 139.11-139.14 *)
val Word3.toInt: Word3.word -> int (* @ $(SML_LIB)/basis/integer/embed-word.sml 114.14-114.18 *)
val Word3.toIntX: Word3.word -> int (* @ $(SML_LIB)/basis/integer/embed-word.sml 124.14-124.19 *)
val Word3.toLarge: Word3.word -> LargeWord.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 115.14-115.20 *)
val Word3.toLargeInt: Word3.word -> LargeInt.int (* @ $(SML_LIB)/basis/integer/embed-word.sml 116.14-116.23 *)
val Word3.toLargeIntX: Word3.word -> LargeInt.int (* @ $(SML_LIB)/basis/integer/embed-word.sml 125.14-125.24 *)
val Word3.toLargeWord: Word3.word -> LargeWord.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 144.11-144.21 *)
val Word3.toLargeWordX: Word3.word -> LargeWord.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 146.11-146.22 *)
val Word3.toLargeX: Word3.word -> LargeWord.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 126.14-126.21 *)
val Word3.toString: Word3.word -> string (* @ $(SML_LIB)/basis/integer/embed-word.sml 117.14-117.21 *)
val Word3.wordSize: int (* @ $(SML_LIB)/basis/integer/embed-word.sml 24.17-24.24 *)
val Word3.xorb: Word3.word * Word3.word -> Word3.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 69.14-69.17 *)
val Word3.~ : Word3.word -> Word3.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 148.11-148.11 *)
val Word3.~>> : Word3.word * word -> Word3.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 81.11-81.13 *)
structure Word30: WORD where type word = Word30.word (* @ $(SML_LIB)/basis/libs/basis-extra/top-level/basis.sml 228.17-228.22 *)
type Word30.word = Word30.word (* @ $(SML_LIB)/basis/primitive/prim-basis.sml 416.12-416.15 *)
val Word30.* : Word30.word * Word30.word -> Word30.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 62.17-62.17 *)
val Word30.+ : Word30.word * Word30.word -> Word30.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 63.17-63.17 *)
val Word30.- : Word30.word * Word30.word -> Word30.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 64.17-64.17 *)
val Word30.< : Word30.word * Word30.word -> bool (* @ $(SML_LIB)/basis/integer/embed-word.sml 87.17-87.17 *)
val Word30.<< : Word30.word * word -> Word30.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 78.14-78.15 *)
val Word30.<= : Word30.word * Word30.word -> bool (* @ $(SML_LIB)/basis/integer/embed-word.sml 88.17-88.18 *)
val Word30.> : Word30.word * Word30.word -> bool (* @ $(SML_LIB)/basis/integer/embed-word.sml 89.17-89.17 *)
val Word30.>= : Word30.word * Word30.word -> bool (* @ $(SML_LIB)/basis/integer/embed-word.sml 90.17-90.18 *)
val Word30.>> : Word30.word * word -> Word30.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 77.14-77.15 *)
val Word30.andb: Word30.word * Word30.word -> Word30.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 65.14-65.17 *)
val Word30.compare: Word30.word * Word30.word -> order (* @ $(SML_LIB)/basis/integer/embed-word.sml 91.14-91.20 *)
val Word30.div: Word30.word * Word30.word -> Word30.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 66.17-66.19 *)
val Word30.fmt: StringCvt.radix -> Word30.word -> string (* @ $(SML_LIB)/basis/integer/embed-word.sml 129.11-129.13 *)
val Word30.fromInt: int -> Word30.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 105.14-105.20 *)
val Word30.fromLarge: LargeWord.word -> Word30.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 106.14-106.22 *)
val Word30.fromLargeInt: LargeInt.int -> Word30.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 107.14-107.25 *)
val Word30.fromLargeWord: LargeWord.word -> Word30.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 131.11-131.23 *)
val Word30.fromString: string -> Word30.word option (* @ $(SML_LIB)/basis/integer/embed-word.sml 133.11-133.20 *)
val Word30.max: Word30.word * Word30.word -> Word30.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 135.11-135.13 *)
val Word30.min: Word30.word * Word30.word -> Word30.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 137.11-137.13 *)
val Word30.mod: Word30.word * Word30.word -> Word30.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 67.17-67.19 *)
val Word30.notb: Word30.word -> Word30.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 98.14-98.17 *)
val Word30.orb: Word30.word * Word30.word -> Word30.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 68.14-68.16 *)
val Word30.scan: StringCvt.radix -> ('a -> (char * 'a) option) -> 'a -> (Word30.word * 'a) option (* @ $(SML_LIB)/basis/integer/embed-word.sml 139.11-139.14 *)
val Word30.toInt: Word30.word -> int (* @ $(SML_LIB)/basis/integer/embed-word.sml 114.14-114.18 *)
val Word30.toIntX: Word30.word -> int (* @ $(SML_LIB)/basis/integer/embed-word.sml 124.14-124.19 *)
val Word30.toLarge: Word30.word -> LargeWord.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 115.14-115.20 *)
val Word30.toLargeInt: Word30.word -> LargeInt.int (* @ $(SML_LIB)/basis/integer/embed-word.sml 116.14-116.23 *)
val Word30.toLargeIntX: Word30.word -> LargeInt.int (* @ $(SML_LIB)/basis/integer/embed-word.sml 125.14-125.24 *)
val Word30.toLargeWord: Word30.word -> LargeWord.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 144.11-144.21 *)
val Word30.toLargeWordX: Word30.word -> LargeWord.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 146.11-146.22 *)
val Word30.toLargeX: Word30.word -> LargeWord.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 126.14-126.21 *)
val Word30.toString: Word30.word -> string (* @ $(SML_LIB)/basis/integer/embed-word.sml 117.14-117.21 *)
val Word30.wordSize: int (* @ $(SML_LIB)/basis/integer/embed-word.sml 24.17-24.24 *)
val Word30.xorb: Word30.word * Word30.word -> Word30.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 69.14-69.17 *)
val Word30.~ : Word30.word -> Word30.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 148.11-148.11 *)
val Word30.~>> : Word30.word * word -> Word30.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 81.11-81.13 *)
structure Word31: WORD where type word = Word31.word (* @ $(SML_LIB)/basis/libs/basis-extra/top-level/basis.sml 229.17-229.22 *)
type Word31.word = Word31.word (* @ $(SML_LIB)/basis/primitive/prim-basis.sml 421.12-421.15 *)
val Word31.* : Word31.word * Word31.word -> Word31.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 62.17-62.17 *)
val Word31.+ : Word31.word * Word31.word -> Word31.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 63.17-63.17 *)
val Word31.- : Word31.word * Word31.word -> Word31.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 64.17-64.17 *)
val Word31.< : Word31.word * Word31.word -> bool (* @ $(SML_LIB)/basis/integer/embed-word.sml 87.17-87.17 *)
val Word31.<< : Word31.word * word -> Word31.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 78.14-78.15 *)
val Word31.<= : Word31.word * Word31.word -> bool (* @ $(SML_LIB)/basis/integer/embed-word.sml 88.17-88.18 *)
val Word31.> : Word31.word * Word31.word -> bool (* @ $(SML_LIB)/basis/integer/embed-word.sml 89.17-89.17 *)
val Word31.>= : Word31.word * Word31.word -> bool (* @ $(SML_LIB)/basis/integer/embed-word.sml 90.17-90.18 *)
val Word31.>> : Word31.word * word -> Word31.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 77.14-77.15 *)
val Word31.andb: Word31.word * Word31.word -> Word31.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 65.14-65.17 *)
val Word31.compare: Word31.word * Word31.word -> order (* @ $(SML_LIB)/basis/integer/embed-word.sml 91.14-91.20 *)
val Word31.div: Word31.word * Word31.word -> Word31.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 66.17-66.19 *)
val Word31.fmt: StringCvt.radix -> Word31.word -> string (* @ $(SML_LIB)/basis/integer/embed-word.sml 129.11-129.13 *)
val Word31.fromInt: int -> Word31.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 105.14-105.20 *)
val Word31.fromLarge: LargeWord.word -> Word31.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 106.14-106.22 *)
val Word31.fromLargeInt: LargeInt.int -> Word31.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 107.14-107.25 *)
val Word31.fromLargeWord: LargeWord.word -> Word31.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 131.11-131.23 *)
val Word31.fromString: string -> Word31.word option (* @ $(SML_LIB)/basis/integer/embed-word.sml 133.11-133.20 *)
val Word31.max: Word31.word * Word31.word -> Word31.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 135.11-135.13 *)
val Word31.min: Word31.word * Word31.word -> Word31.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 137.11-137.13 *)
val Word31.mod: Word31.word * Word31.word -> Word31.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 67.17-67.19 *)
val Word31.notb: Word31.word -> Word31.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 98.14-98.17 *)
val Word31.orb: Word31.word * Word31.word -> Word31.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 68.14-68.16 *)
val Word31.scan: StringCvt.radix -> ('a -> (char * 'a) option) -> 'a -> (Word31.word * 'a) option (* @ $(SML_LIB)/basis/integer/embed-word.sml 139.11-139.14 *)
val Word31.toInt: Word31.word -> int (* @ $(SML_LIB)/basis/integer/embed-word.sml 114.14-114.18 *)
val Word31.toIntX: Word31.word -> int (* @ $(SML_LIB)/basis/integer/embed-word.sml 124.14-124.19 *)
val Word31.toLarge: Word31.word -> LargeWord.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 115.14-115.20 *)
val Word31.toLargeInt: Word31.word -> LargeInt.int (* @ $(SML_LIB)/basis/integer/embed-word.sml 116.14-116.23 *)
val Word31.toLargeIntX: Word31.word -> LargeInt.int (* @ $(SML_LIB)/basis/integer/embed-word.sml 125.14-125.24 *)
val Word31.toLargeWord: Word31.word -> LargeWord.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 144.11-144.21 *)
val Word31.toLargeWordX: Word31.word -> LargeWord.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 146.11-146.22 *)
val Word31.toLargeX: Word31.word -> LargeWord.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 126.14-126.21 *)
val Word31.toString: Word31.word -> string (* @ $(SML_LIB)/basis/integer/embed-word.sml 117.14-117.21 *)
val Word31.wordSize: int (* @ $(SML_LIB)/basis/integer/embed-word.sml 24.17-24.24 *)
val Word31.xorb: Word31.word * Word31.word -> Word31.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 69.14-69.17 *)
val Word31.~ : Word31.word -> Word31.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 148.11-148.11 *)
val Word31.~>> : Word31.word * word -> Word31.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 81.11-81.13 *)
structure Word32: WORD where type word = word (* @ $(SML_LIB)/basis/libs/basis-2002/top-level/top-level.sml 89.11-89.16 *)
type Word32.word = word (* @ $(SML_LIB)/basis/primitive/prim-basis.sml 426.12-426.15 *)
val Word32.* : word * word -> word (* @ $(SML_LIB)/basis/primitive/prim-word.sml 361.11-361.11 *)
val Word32.+ : word * word -> word (* @ $(SML_LIB)/basis/primitive/prim-word.sml 358.11-358.11 *)
val Word32.- : word * word -> word (* @ $(SML_LIB)/basis/primitive/prim-word.sml 371.11-371.11 *)
val Word32.< : word * word -> bool (* @ $(SML_LIB)/basis/util/integral-comparisons.sml 11.11-11.11 *)
val Word32.<< : word * word -> word (* @ $(SML_LIB)/basis/integer/word.sml 19.5-19.6 *)
val Word32.<= : word * word -> bool (* @ $(SML_LIB)/basis/util/integral-comparisons.sml 12.11-12.12 *)
val Word32.> : word * word -> bool (* @ $(SML_LIB)/basis/util/integral-comparisons.sml 13.11-13.11 *)
val Word32.>= : word * word -> bool (* @ $(SML_LIB)/basis/util/integral-comparisons.sml 14.11-14.12 *)
val Word32.>> : word * word -> word (* @ $(SML_LIB)/basis/integer/word.sml 23.5-23.6 *)
val Word32.andb: word * word -> word (* @ $(SML_LIB)/basis/primitive/prim-word.sml 359.11-359.14 *)
val Word32.compare: word * word -> order (* @ $(SML_LIB)/basis/util/integral-comparisons.sml 16.11-16.17 *)
val Word32.div: word * word -> word (* @ $(SML_LIB)/basis/integer/num0.sml 97.23-97.25 *)
val Word32.fmt: StringCvt.radix -> word -> string (* @ $(SML_LIB)/basis/integer/word.sml 104.8-104.10 *)
val Word32.fromInt: int -> word (* @ $(SML_LIB)/basis/integer/word.sml 55.5-55.11 *)
val Word32.fromLarge: LargeWord.word -> word (* @ $(SML_LIB)/basis/integer/word.sml 87.5-87.13 *)
val Word32.fromLargeInt: LargeInt.int -> word (* @ $(SML_LIB)/basis/integer/word.sml 70.5-70.16 *)
val Word32.fromLargeWord: LargeWord.word -> word (* @ $(SML_LIB)/basis/integer/word.sml 86.5-86.17 *)
val Word32.fromString: string -> word option (* @ $(SML_LIB)/basis/integer/word.sml 209.5-209.14 *)
val Word32.max: word * word -> word (* @ $(SML_LIB)/basis/util/integral-comparisons.sml 21.11-21.13 *)
val Word32.min: word * word -> word (* @ $(SML_LIB)/basis/util/integral-comparisons.sml 20.11-20.13 *)
val Word32.mod: word * word -> word (* @ $(SML_LIB)/basis/integer/num0.sml 98.23-98.25 *)
val Word32.notb: word -> word (* @ $(SML_LIB)/basis/primitive/prim-word.sml 363.11-363.14 *)
val Word32.orb: word * word -> word (* @ $(SML_LIB)/basis/primitive/prim-word.sml 364.11-364.13 *)
val Word32.scan: StringCvt.radix -> ('a -> (char * 'a) option) -> 'a -> (word * 'a) option (* @ $(SML_LIB)/basis/integer/word.sml 146.5-146.8 *)
val Word32.toInt: word -> int (* @ $(SML_LIB)/basis/integer/word.sml 57.5-57.9 *)
val Word32.toIntX: word -> int (* @ $(SML_LIB)/basis/integer/word.sml 56.5-56.10 *)
val Word32.toLarge: word -> LargeWord.word (* @ $(SML_LIB)/basis/integer/word.sml 91.5-91.11 *)
val Word32.toLargeInt: word -> LargeInt.int (* @ $(SML_LIB)/basis/integer/word.sml 72.5-72.14 *)
val Word32.toLargeIntX: word -> LargeInt.int (* @ $(SML_LIB)/basis/integer/word.sml 71.5-71.15 *)
val Word32.toLargeWord: word -> LargeWord.word (* @ $(SML_LIB)/basis/integer/word.sml 90.5-90.15 *)
val Word32.toLargeWordX: word -> LargeWord.word (* @ $(SML_LIB)/basis/integer/word.sml 88.5-88.16 *)
val Word32.toLargeX: word -> LargeWord.word (* @ $(SML_LIB)/basis/integer/word.sml 89.5-89.12 *)
val Word32.toString: word -> string (* @ $(SML_LIB)/basis/integer/word.sml 144.5-144.12 *)
val Word32.wordSize: int (* @ $(SML_LIB)/basis/integer/word.sml 16.5-16.12 *)
val Word32.xorb: word * word -> word (* @ $(SML_LIB)/basis/primitive/prim-word.sml 372.11-372.14 *)
val Word32.~ : word -> word (* @ $(SML_LIB)/basis/primitive/prim-word.sml 362.11-362.11 *)
val Word32.~>> : word * word -> word (* @ $(SML_LIB)/basis/integer/word.sml 27.5-27.7 *)
structure Word32Array: MONO_ARRAY where type array = Word32Array.array where type elem = word where type vector = Word32Vector.vector (* @ $(SML_LIB)/basis/libs/basis-2002/top-level/top-level.sml 64.11-64.21 *)
type Word32Array.array = Word32Array.array (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array.fun 23.12-23.16 *)
type Word32Array.elem = word (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array.fun 22.12-22.15 *)
type Word32Array.vector = Word32Vector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array.fun 24.12-24.17 *)
val Word32Array.all: (word -> bool) -> Word32Array.array -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 476.13-476.15 *)
val Word32Array.app: (word -> unit) -> Word32Array.array -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 464.13-464.15 *)
val Word32Array.appi: (int * word -> unit) -> Word32Array.array -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 463.13-463.16 *)
val Word32Array.array: int * word -> Word32Array.array (* @ $(SML_LIB)/basis/arrays-and-vectors/array.sml 34.11-34.15 *)
val Word32Array.collate: (word * word -> order) -> Word32Array.array * Word32Array.array -> order (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 477.13-477.19 *)
val Word32Array.copy: {di: int, dst: Word32Array.array, src: Word32Array.array} -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 457.13-457.16 *)
val Word32Array.copyVec: {di: int, dst: Word32Array.array, src: Word32Vector.vector} -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array.sml 37.11-37.17 *)
val Word32Array.exists: (word -> bool) -> Word32Array.array -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 474.13-474.18 *)
val Word32Array.find: (word -> bool) -> Word32Array.array -> word option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 472.13-472.16 *)
val Word32Array.findi: (int * word -> bool) -> Word32Array.array -> (int * word) option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 471.13-471.17 *)
val Word32Array.foldl: (word * 'a -> 'a) -> 'a -> Word32Array.array -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 468.13-468.17 *)
val Word32Array.foldli: (int * word * 'a -> 'a) -> 'a -> Word32Array.array -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 467.13-467.18 *)
val Word32Array.foldr: (word * 'a -> 'a) -> 'a -> Word32Array.array -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 470.13-470.17 *)
val Word32Array.foldri: (int * word * 'a -> 'a) -> 'a -> Word32Array.array -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 469.13-469.18 *)
val Word32Array.fromList: word list -> Word32Array.array (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 122.11-122.18 *)
val Word32Array.length: Word32Array.array -> int (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 90.11-90.16 *)
val Word32Array.maxLen: int (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 88.11-88.16 *)
val Word32Array.modify: (word -> word) -> Word32Array.array -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array.sml 40.11-40.16 *)
val Word32Array.modifyi: (int * word -> word) -> Word32Array.array -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array.sml 39.11-39.17 *)
val Word32Array.sub: Word32Array.array * int -> word (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 450.13-450.15 *)
val Word32Array.tabulate: int * (int -> word) -> Word32Array.array (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 114.11-114.18 *)
val Word32Array.update: Word32Array.array * int * word -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 452.13-452.18 *)
val Word32Array.vector: Word32Array.array -> Word32Vector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/array.sml 36.11-36.16 *)
structure Word32Array2: MONO_ARRAY2 where type array = Word32Array2.array where type elem = word where type vector = Word32Vector.vector (* @ $(SML_LIB)/basis/libs/basis-2002/top-level/top-level.sml 65.11-65.22 *)
type Word32Array2.array = Word32Array2.array (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array2.fun 18.12-18.16 *)
type Word32Array2.elem = word (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array2.fun 15.12-15.15 *)
type Word32Array2.region = {base: Word32Array2.array, col: int, ncols: int option, nrows: int option, row: int} (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array2.fun 19.12-19.17 *)
datatype Word32Array2.traversal = ColMajor | RowMajor (* = datatype Array2.traversal *) (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 106.16-106.24 *)
type Word32Array2.vector = Word32Vector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array2.fun 16.12-16.17 *)
con Word32Array2.ColMajor: Array2.traversal (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 106.39-106.46 *)
con Word32Array2.RowMajor: Array2.traversal (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 106.28-106.35 *)
val Word32Array2.app: Array2.traversal -> (word -> unit) -> Word32Array2.array -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 294.11-294.13 *)
val Word32Array2.appi: Array2.traversal -> (int * int * word -> unit) -> {base: Word32Array2.array, col: int, ncols: int option, nrows: int option, row: int} -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 291.11-291.14 *)
val Word32Array2.array: int * int * word -> Word32Array2.array (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 140.14-140.18 *)
val Word32Array2.column: Word32Array2.array * int -> Word32Vector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 237.11-237.16 *)
val Word32Array2.copy: {dst: Word32Array2.array, dst_col: int, dst_row: int, src: {base: Word32Array2.array, col: int, ncols: int option, nrows: int option, row: int}} -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 309.11-309.14 *)
val Word32Array2.dimensions: Word32Array2.array -> int * int (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 33.11-33.20 *)
val Word32Array2.fold: Array2.traversal -> (word * 'a -> 'a) -> 'a -> Word32Array2.array -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 288.11-288.14 *)
val Word32Array2.foldi: Array2.traversal -> (int * int * word * 'a -> 'a) -> 'a -> {base: Word32Array2.array, col: int, ncols: int option, nrows: int option, row: int} -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 283.11-283.15 *)
val Word32Array2.fromList: word list list -> Word32Array2.array (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 188.14-188.21 *)
val Word32Array2.modify: Array2.traversal -> (word -> word) -> Word32Array2.array -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 299.11-299.16 *)
val Word32Array2.modifyi: Array2.traversal -> (int * int * word -> word) -> {base: Word32Array2.array, col: int, ncols: int option, nrows: int option, row: int} -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 296.11-296.17 *)
val Word32Array2.nCols: Word32Array2.array -> int (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 38.11-38.15 *)
val Word32Array2.nRows: Word32Array2.array -> int (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 36.11-36.15 *)
val Word32Array2.row: Word32Array2.array * int -> Word32Vector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 222.11-222.13 *)
val Word32Array2.sub: Word32Array2.array * int * int -> word (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 182.14-182.16 *)
val Word32Array2.tabulate: Array2.traversal -> int * int * (int * int -> word) -> Word32Array2.array (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 301.11-301.18 *)
val Word32Array2.update: Word32Array2.array * int * int * word -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 184.14-184.19 *)
structure Word32ArraySlice: MONO_ARRAY_SLICE where type array = Word32Array.array where type elem = word where type slice = Word32ArraySlice.slice where type vector = Word32Vector.vector where type vector_slice = Word32VectorSlice.slice (* @ $(SML_LIB)/basis/libs/basis-extra/top-level/basis.sml 245.17-245.32 *)
type Word32ArraySlice.array = Word32Array.array (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array.fun 35.18-35.22 *)
type Word32ArraySlice.elem = word (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array.fun 34.18-34.21 *)
type Word32ArraySlice.slice = Word32ArraySlice.slice (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array.fun 36.18-36.22 *)
type Word32ArraySlice.vector = Word32Vector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array.fun 37.18-37.23 *)
type Word32ArraySlice.vector_slice = Word32VectorSlice.slice (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array.fun 38.18-38.29 *)
val Word32ArraySlice.all: (word -> bool) -> Word32ArraySlice.slice -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 235.17-235.19 *)
val Word32ArraySlice.app: (word -> unit) -> Word32ArraySlice.slice -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 226.17-226.19 *)
val Word32ArraySlice.appi: (int * word -> unit) -> Word32ArraySlice.slice -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 225.17-225.20 *)
val Word32ArraySlice.base: Word32ArraySlice.slice -> Word32Array.array * int * int (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 208.17-208.20 *)
val Word32ArraySlice.collate: (word * word -> order) -> Word32ArraySlice.slice * Word32ArraySlice.slice -> order (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 236.17-236.23 *)
val Word32ArraySlice.copy: {di: int, dst: Word32Array.array, src: Word32ArraySlice.slice} -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 185.17-185.20 *)
val Word32ArraySlice.copyVec: {di: int, dst: Word32Array.array, src: Word32VectorSlice.slice} -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array.sml 28.17-28.23 *)
val Word32ArraySlice.exists: (word -> bool) -> Word32ArraySlice.slice -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 233.17-233.22 *)
val Word32ArraySlice.find: (word -> bool) -> Word32ArraySlice.slice -> word option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 231.17-231.20 *)
val Word32ArraySlice.findi: (int * word -> bool) -> Word32ArraySlice.slice -> (int * word) option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 229.17-229.21 *)
val Word32ArraySlice.foldl: (word * 'a -> 'a) -> 'a -> Word32ArraySlice.slice -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 223.17-223.21 *)
val Word32ArraySlice.foldli: (int * word * 'a -> 'a) -> 'a -> Word32ArraySlice.slice -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 221.17-221.22 *)
val Word32ArraySlice.foldr: (word * 'a -> 'a) -> 'a -> Word32ArraySlice.slice -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 224.17-224.21 *)
val Word32ArraySlice.foldri: (int * word * 'a -> 'a) -> 'a -> Word32ArraySlice.slice -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 222.17-222.22 *)
val Word32ArraySlice.full: Word32Array.array -> Word32ArraySlice.slice (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 192.17-192.20 *)
val Word32ArraySlice.getItem: Word32ArraySlice.slice -> (word * Word32ArraySlice.slice) option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 220.17-220.23 *)
val Word32ArraySlice.isEmpty: Word32ArraySlice.slice -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 219.17-219.23 *)
val Word32ArraySlice.length: Word32ArraySlice.slice -> int (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 134.17-134.22 *)
val Word32ArraySlice.modify: (word -> word) -> Word32ArraySlice.slice -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array.sml 31.17-31.22 *)
val Word32ArraySlice.modifyi: (int * word -> word) -> Word32ArraySlice.slice -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array.sml 30.17-30.23 *)
val Word32ArraySlice.slice: Word32Array.array * int * int option -> Word32ArraySlice.slice (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 206.17-206.21 *)
val Word32ArraySlice.sub: Word32ArraySlice.slice * int -> word (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 142.17-142.19 *)
val Word32ArraySlice.subslice: Word32ArraySlice.slice * int * int option -> Word32ArraySlice.slice (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 199.17-199.24 *)
val Word32ArraySlice.update: Word32ArraySlice.slice * int * word -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 155.17-155.22 *)
val Word32ArraySlice.vector: Word32ArraySlice.slice -> Word32Vector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/array.sml 27.17-27.22 *)
structure Word32Vector: MONO_VECTOR where type elem = word where type vector = Word32Vector.vector (* @ $(SML_LIB)/basis/libs/basis-2002/top-level/top-level.sml 66.11-66.22 *)
type Word32Vector.elem = word (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-vector.fun 35.12-35.15 *)
type Word32Vector.vector = Word32Vector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-vector.fun 36.12-36.17 *)
val Word32Vector.all: (word -> bool) -> Word32Vector.vector -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 476.13-476.15 *)
val Word32Vector.app: (word -> unit) -> Word32Vector.vector -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 464.13-464.15 *)
val Word32Vector.appi: (int * word -> unit) -> Word32Vector.vector -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 463.13-463.16 *)
val Word32Vector.collate: (word * word -> order) -> Word32Vector.vector * Word32Vector.vector -> order (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 477.13-477.19 *)
val Word32Vector.concat: Word32Vector.vector list -> Word32Vector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 462.13-462.18 *)
val Word32Vector.exists: (word -> bool) -> Word32Vector.vector -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 474.13-474.18 *)
val Word32Vector.find: (word -> bool) -> Word32Vector.vector -> word option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 472.13-472.16 *)
val Word32Vector.findi: (int * word -> bool) -> Word32Vector.vector -> (int * word) option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 471.13-471.17 *)
val Word32Vector.foldl: (word * 'a -> 'a) -> 'a -> Word32Vector.vector -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 468.13-468.17 *)
val Word32Vector.foldli: (int * word * 'a -> 'a) -> 'a -> Word32Vector.vector -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 467.13-467.18 *)
val Word32Vector.foldr: (word * 'a -> 'a) -> 'a -> Word32Vector.vector -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 470.13-470.17 *)
val Word32Vector.foldri: (int * word * 'a -> 'a) -> 'a -> Word32Vector.vector -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 469.13-469.18 *)
val Word32Vector.fromList: word list -> Word32Vector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 122.11-122.18 *)
val Word32Vector.length: Word32Vector.vector -> int (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 90.11-90.16 *)
val Word32Vector.map: (word -> word) -> Word32Vector.vector -> Word32Vector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 466.13-466.15 *)
val Word32Vector.mapi: (int * word -> word) -> Word32Vector.vector -> Word32Vector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 465.13-465.16 *)
val Word32Vector.maxLen: int (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 88.11-88.16 *)
val Word32Vector.sub: Word32Vector.vector * int -> word (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 450.13-450.15 *)
val Word32Vector.tabulate: int * (int -> word) -> Word32Vector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 114.11-114.18 *)
val Word32Vector.update: Word32Vector.vector * int * word -> Word32Vector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/vector.sml 30.11-30.16 *)
structure Word32VectorSlice: MONO_VECTOR_SLICE where type elem = word where type slice = Word32VectorSlice.slice where type vector = Word32Vector.vector (* @ $(SML_LIB)/basis/libs/basis-extra/top-level/basis.sml 247.17-247.33 *)
type Word32VectorSlice.elem = word (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-vector.fun 43.18-43.21 *)
type Word32VectorSlice.slice = Word32VectorSlice.slice (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-vector.fun 45.18-45.22 *)
type Word32VectorSlice.vector = Word32Vector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-vector.fun 44.18-44.23 *)
val Word32VectorSlice.all: (word -> bool) -> Word32VectorSlice.slice -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 235.17-235.19 *)
val Word32VectorSlice.app: (word -> unit) -> Word32VectorSlice.slice -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 226.17-226.19 *)
val Word32VectorSlice.appi: (int * word -> unit) -> Word32VectorSlice.slice -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 225.17-225.20 *)
val Word32VectorSlice.base: Word32VectorSlice.slice -> Word32Vector.vector * int * int (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 208.17-208.20 *)
val Word32VectorSlice.collate: (word * word -> order) -> Word32VectorSlice.slice * Word32VectorSlice.slice -> order (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 236.17-236.23 *)
val Word32VectorSlice.concat: Word32VectorSlice.slice list -> Word32Vector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 240.17-240.22 *)
val Word32VectorSlice.exists: (word -> bool) -> Word32VectorSlice.slice -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 233.17-233.22 *)
val Word32VectorSlice.find: (word -> bool) -> Word32VectorSlice.slice -> word option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 231.17-231.20 *)
val Word32VectorSlice.findi: (int * word -> bool) -> Word32VectorSlice.slice -> (int * word) option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 229.17-229.21 *)
val Word32VectorSlice.foldl: (word * 'a -> 'a) -> 'a -> Word32VectorSlice.slice -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 223.17-223.21 *)
val Word32VectorSlice.foldli: (int * word * 'a -> 'a) -> 'a -> Word32VectorSlice.slice -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 221.17-221.22 *)
val Word32VectorSlice.foldr: (word * 'a -> 'a) -> 'a -> Word32VectorSlice.slice -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 224.17-224.21 *)
val Word32VectorSlice.foldri: (int * word * 'a -> 'a) -> 'a -> Word32VectorSlice.slice -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 222.17-222.22 *)
val Word32VectorSlice.full: Word32Vector.vector -> Word32VectorSlice.slice (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 192.17-192.20 *)
val Word32VectorSlice.getItem: Word32VectorSlice.slice -> (word * Word32VectorSlice.slice) option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 220.17-220.23 *)
val Word32VectorSlice.isEmpty: Word32VectorSlice.slice -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 219.17-219.23 *)
val Word32VectorSlice.length: Word32VectorSlice.slice -> int (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 134.17-134.22 *)
val Word32VectorSlice.map: (word -> word) -> Word32VectorSlice.slice -> Word32Vector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 228.17-228.19 *)
val Word32VectorSlice.mapi: (int * word -> word) -> Word32VectorSlice.slice -> Word32Vector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 227.17-227.20 *)
val Word32VectorSlice.slice: Word32Vector.vector * int * int option -> Word32VectorSlice.slice (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 206.17-206.21 *)
val Word32VectorSlice.sub: Word32VectorSlice.slice * int -> word (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 142.17-142.19 *)
val Word32VectorSlice.subslice: Word32VectorSlice.slice * int * int option -> Word32VectorSlice.slice (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 199.17-199.24 *)
val Word32VectorSlice.vector: Word32VectorSlice.slice -> Word32Vector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/vector.sml 21.17-21.22 *)
structure Word4: WORD where type word = Word4.word (* @ $(SML_LIB)/basis/libs/basis-extra/top-level/basis.sml 202.17-202.21 *)
type Word4.word = Word4.word (* @ $(SML_LIB)/basis/primitive/prim-basis.sml 286.12-286.15 *)
val Word4.* : Word4.word * Word4.word -> Word4.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 62.17-62.17 *)
val Word4.+ : Word4.word * Word4.word -> Word4.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 63.17-63.17 *)
val Word4.- : Word4.word * Word4.word -> Word4.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 64.17-64.17 *)
val Word4.< : Word4.word * Word4.word -> bool (* @ $(SML_LIB)/basis/integer/embed-word.sml 87.17-87.17 *)
val Word4.<< : Word4.word * word -> Word4.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 78.14-78.15 *)
val Word4.<= : Word4.word * Word4.word -> bool (* @ $(SML_LIB)/basis/integer/embed-word.sml 88.17-88.18 *)
val Word4.> : Word4.word * Word4.word -> bool (* @ $(SML_LIB)/basis/integer/embed-word.sml 89.17-89.17 *)
val Word4.>= : Word4.word * Word4.word -> bool (* @ $(SML_LIB)/basis/integer/embed-word.sml 90.17-90.18 *)
val Word4.>> : Word4.word * word -> Word4.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 77.14-77.15 *)
val Word4.andb: Word4.word * Word4.word -> Word4.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 65.14-65.17 *)
val Word4.compare: Word4.word * Word4.word -> order (* @ $(SML_LIB)/basis/integer/embed-word.sml 91.14-91.20 *)
val Word4.div: Word4.word * Word4.word -> Word4.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 66.17-66.19 *)
val Word4.fmt: StringCvt.radix -> Word4.word -> string (* @ $(SML_LIB)/basis/integer/embed-word.sml 129.11-129.13 *)
val Word4.fromInt: int -> Word4.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 105.14-105.20 *)
val Word4.fromLarge: LargeWord.word -> Word4.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 106.14-106.22 *)
val Word4.fromLargeInt: LargeInt.int -> Word4.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 107.14-107.25 *)
val Word4.fromLargeWord: LargeWord.word -> Word4.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 131.11-131.23 *)
val Word4.fromString: string -> Word4.word option (* @ $(SML_LIB)/basis/integer/embed-word.sml 133.11-133.20 *)
val Word4.max: Word4.word * Word4.word -> Word4.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 135.11-135.13 *)
val Word4.min: Word4.word * Word4.word -> Word4.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 137.11-137.13 *)
val Word4.mod: Word4.word * Word4.word -> Word4.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 67.17-67.19 *)
val Word4.notb: Word4.word -> Word4.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 98.14-98.17 *)
val Word4.orb: Word4.word * Word4.word -> Word4.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 68.14-68.16 *)
val Word4.scan: StringCvt.radix -> ('a -> (char * 'a) option) -> 'a -> (Word4.word * 'a) option (* @ $(SML_LIB)/basis/integer/embed-word.sml 139.11-139.14 *)
val Word4.toInt: Word4.word -> int (* @ $(SML_LIB)/basis/integer/embed-word.sml 114.14-114.18 *)
val Word4.toIntX: Word4.word -> int (* @ $(SML_LIB)/basis/integer/embed-word.sml 124.14-124.19 *)
val Word4.toLarge: Word4.word -> LargeWord.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 115.14-115.20 *)
val Word4.toLargeInt: Word4.word -> LargeInt.int (* @ $(SML_LIB)/basis/integer/embed-word.sml 116.14-116.23 *)
val Word4.toLargeIntX: Word4.word -> LargeInt.int (* @ $(SML_LIB)/basis/integer/embed-word.sml 125.14-125.24 *)
val Word4.toLargeWord: Word4.word -> LargeWord.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 144.11-144.21 *)
val Word4.toLargeWordX: Word4.word -> LargeWord.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 146.11-146.22 *)
val Word4.toLargeX: Word4.word -> LargeWord.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 126.14-126.21 *)
val Word4.toString: Word4.word -> string (* @ $(SML_LIB)/basis/integer/embed-word.sml 117.14-117.21 *)
val Word4.wordSize: int (* @ $(SML_LIB)/basis/integer/embed-word.sml 24.17-24.24 *)
val Word4.xorb: Word4.word * Word4.word -> Word4.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 69.14-69.17 *)
val Word4.~ : Word4.word -> Word4.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 148.11-148.11 *)
val Word4.~>> : Word4.word * word -> Word4.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 81.11-81.13 *)
structure Word5: WORD where type word = Word5.word (* @ $(SML_LIB)/basis/libs/basis-extra/top-level/basis.sml 203.17-203.21 *)
type Word5.word = Word5.word (* @ $(SML_LIB)/basis/primitive/prim-basis.sml 291.12-291.15 *)
val Word5.* : Word5.word * Word5.word -> Word5.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 62.17-62.17 *)
val Word5.+ : Word5.word * Word5.word -> Word5.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 63.17-63.17 *)
val Word5.- : Word5.word * Word5.word -> Word5.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 64.17-64.17 *)
val Word5.< : Word5.word * Word5.word -> bool (* @ $(SML_LIB)/basis/integer/embed-word.sml 87.17-87.17 *)
val Word5.<< : Word5.word * word -> Word5.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 78.14-78.15 *)
val Word5.<= : Word5.word * Word5.word -> bool (* @ $(SML_LIB)/basis/integer/embed-word.sml 88.17-88.18 *)
val Word5.> : Word5.word * Word5.word -> bool (* @ $(SML_LIB)/basis/integer/embed-word.sml 89.17-89.17 *)
val Word5.>= : Word5.word * Word5.word -> bool (* @ $(SML_LIB)/basis/integer/embed-word.sml 90.17-90.18 *)
val Word5.>> : Word5.word * word -> Word5.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 77.14-77.15 *)
val Word5.andb: Word5.word * Word5.word -> Word5.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 65.14-65.17 *)
val Word5.compare: Word5.word * Word5.word -> order (* @ $(SML_LIB)/basis/integer/embed-word.sml 91.14-91.20 *)
val Word5.div: Word5.word * Word5.word -> Word5.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 66.17-66.19 *)
val Word5.fmt: StringCvt.radix -> Word5.word -> string (* @ $(SML_LIB)/basis/integer/embed-word.sml 129.11-129.13 *)
val Word5.fromInt: int -> Word5.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 105.14-105.20 *)
val Word5.fromLarge: LargeWord.word -> Word5.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 106.14-106.22 *)
val Word5.fromLargeInt: LargeInt.int -> Word5.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 107.14-107.25 *)
val Word5.fromLargeWord: LargeWord.word -> Word5.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 131.11-131.23 *)
val Word5.fromString: string -> Word5.word option (* @ $(SML_LIB)/basis/integer/embed-word.sml 133.11-133.20 *)
val Word5.max: Word5.word * Word5.word -> Word5.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 135.11-135.13 *)
val Word5.min: Word5.word * Word5.word -> Word5.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 137.11-137.13 *)
val Word5.mod: Word5.word * Word5.word -> Word5.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 67.17-67.19 *)
val Word5.notb: Word5.word -> Word5.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 98.14-98.17 *)
val Word5.orb: Word5.word * Word5.word -> Word5.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 68.14-68.16 *)
val Word5.scan: StringCvt.radix -> ('a -> (char * 'a) option) -> 'a -> (Word5.word * 'a) option (* @ $(SML_LIB)/basis/integer/embed-word.sml 139.11-139.14 *)
val Word5.toInt: Word5.word -> int (* @ $(SML_LIB)/basis/integer/embed-word.sml 114.14-114.18 *)
val Word5.toIntX: Word5.word -> int (* @ $(SML_LIB)/basis/integer/embed-word.sml 124.14-124.19 *)
val Word5.toLarge: Word5.word -> LargeWord.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 115.14-115.20 *)
val Word5.toLargeInt: Word5.word -> LargeInt.int (* @ $(SML_LIB)/basis/integer/embed-word.sml 116.14-116.23 *)
val Word5.toLargeIntX: Word5.word -> LargeInt.int (* @ $(SML_LIB)/basis/integer/embed-word.sml 125.14-125.24 *)
val Word5.toLargeWord: Word5.word -> LargeWord.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 144.11-144.21 *)
val Word5.toLargeWordX: Word5.word -> LargeWord.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 146.11-146.22 *)
val Word5.toLargeX: Word5.word -> LargeWord.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 126.14-126.21 *)
val Word5.toString: Word5.word -> string (* @ $(SML_LIB)/basis/integer/embed-word.sml 117.14-117.21 *)
val Word5.wordSize: int (* @ $(SML_LIB)/basis/integer/embed-word.sml 24.17-24.24 *)
val Word5.xorb: Word5.word * Word5.word -> Word5.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 69.14-69.17 *)
val Word5.~ : Word5.word -> Word5.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 148.11-148.11 *)
val Word5.~>> : Word5.word * word -> Word5.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 81.11-81.13 *)
structure Word6: WORD where type word = Word6.word (* @ $(SML_LIB)/basis/libs/basis-extra/top-level/basis.sml 204.17-204.21 *)
type Word6.word = Word6.word (* @ $(SML_LIB)/basis/primitive/prim-basis.sml 296.12-296.15 *)
val Word6.* : Word6.word * Word6.word -> Word6.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 62.17-62.17 *)
val Word6.+ : Word6.word * Word6.word -> Word6.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 63.17-63.17 *)
val Word6.- : Word6.word * Word6.word -> Word6.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 64.17-64.17 *)
val Word6.< : Word6.word * Word6.word -> bool (* @ $(SML_LIB)/basis/integer/embed-word.sml 87.17-87.17 *)
val Word6.<< : Word6.word * word -> Word6.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 78.14-78.15 *)
val Word6.<= : Word6.word * Word6.word -> bool (* @ $(SML_LIB)/basis/integer/embed-word.sml 88.17-88.18 *)
val Word6.> : Word6.word * Word6.word -> bool (* @ $(SML_LIB)/basis/integer/embed-word.sml 89.17-89.17 *)
val Word6.>= : Word6.word * Word6.word -> bool (* @ $(SML_LIB)/basis/integer/embed-word.sml 90.17-90.18 *)
val Word6.>> : Word6.word * word -> Word6.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 77.14-77.15 *)
val Word6.andb: Word6.word * Word6.word -> Word6.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 65.14-65.17 *)
val Word6.compare: Word6.word * Word6.word -> order (* @ $(SML_LIB)/basis/integer/embed-word.sml 91.14-91.20 *)
val Word6.div: Word6.word * Word6.word -> Word6.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 66.17-66.19 *)
val Word6.fmt: StringCvt.radix -> Word6.word -> string (* @ $(SML_LIB)/basis/integer/embed-word.sml 129.11-129.13 *)
val Word6.fromInt: int -> Word6.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 105.14-105.20 *)
val Word6.fromLarge: LargeWord.word -> Word6.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 106.14-106.22 *)
val Word6.fromLargeInt: LargeInt.int -> Word6.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 107.14-107.25 *)
val Word6.fromLargeWord: LargeWord.word -> Word6.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 131.11-131.23 *)
val Word6.fromString: string -> Word6.word option (* @ $(SML_LIB)/basis/integer/embed-word.sml 133.11-133.20 *)
val Word6.max: Word6.word * Word6.word -> Word6.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 135.11-135.13 *)
val Word6.min: Word6.word * Word6.word -> Word6.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 137.11-137.13 *)
val Word6.mod: Word6.word * Word6.word -> Word6.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 67.17-67.19 *)
val Word6.notb: Word6.word -> Word6.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 98.14-98.17 *)
val Word6.orb: Word6.word * Word6.word -> Word6.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 68.14-68.16 *)
val Word6.scan: StringCvt.radix -> ('a -> (char * 'a) option) -> 'a -> (Word6.word * 'a) option (* @ $(SML_LIB)/basis/integer/embed-word.sml 139.11-139.14 *)
val Word6.toInt: Word6.word -> int (* @ $(SML_LIB)/basis/integer/embed-word.sml 114.14-114.18 *)
val Word6.toIntX: Word6.word -> int (* @ $(SML_LIB)/basis/integer/embed-word.sml 124.14-124.19 *)
val Word6.toLarge: Word6.word -> LargeWord.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 115.14-115.20 *)
val Word6.toLargeInt: Word6.word -> LargeInt.int (* @ $(SML_LIB)/basis/integer/embed-word.sml 116.14-116.23 *)
val Word6.toLargeIntX: Word6.word -> LargeInt.int (* @ $(SML_LIB)/basis/integer/embed-word.sml 125.14-125.24 *)
val Word6.toLargeWord: Word6.word -> LargeWord.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 144.11-144.21 *)
val Word6.toLargeWordX: Word6.word -> LargeWord.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 146.11-146.22 *)
val Word6.toLargeX: Word6.word -> LargeWord.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 126.14-126.21 *)
val Word6.toString: Word6.word -> string (* @ $(SML_LIB)/basis/integer/embed-word.sml 117.14-117.21 *)
val Word6.wordSize: int (* @ $(SML_LIB)/basis/integer/embed-word.sml 24.17-24.24 *)
val Word6.xorb: Word6.word * Word6.word -> Word6.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 69.14-69.17 *)
val Word6.~ : Word6.word -> Word6.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 148.11-148.11 *)
val Word6.~>> : Word6.word * word -> Word6.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 81.11-81.13 *)
structure Word64: WORD where type word = LargeWord.word (* @ $(SML_LIB)/basis/libs/basis-2002/top-level/top-level.sml 90.11-90.16 *)
type Word64.word = LargeWord.word (* @ $(SML_LIB)/basis/primitive/prim-basis.sml 431.12-431.15 *)
val Word64.* : LargeWord.word * LargeWord.word -> LargeWord.word (* @ $(SML_LIB)/basis/primitive/prim-word.sml 396.11-396.11 *)
val Word64.+ : LargeWord.word * LargeWord.word -> LargeWord.word (* @ $(SML_LIB)/basis/primitive/prim-word.sml 393.11-393.11 *)
val Word64.- : LargeWord.word * LargeWord.word -> LargeWord.word (* @ $(SML_LIB)/basis/primitive/prim-word.sml 406.11-406.11 *)
val Word64.< : LargeWord.word * LargeWord.word -> bool (* @ $(SML_LIB)/basis/util/integral-comparisons.sml 11.11-11.11 *)
val Word64.<< : LargeWord.word * word -> LargeWord.word (* @ $(SML_LIB)/basis/integer/word.sml 19.5-19.6 *)
val Word64.<= : LargeWord.word * LargeWord.word -> bool (* @ $(SML_LIB)/basis/util/integral-comparisons.sml 12.11-12.12 *)
val Word64.> : LargeWord.word * LargeWord.word -> bool (* @ $(SML_LIB)/basis/util/integral-comparisons.sml 13.11-13.11 *)
val Word64.>= : LargeWord.word * LargeWord.word -> bool (* @ $(SML_LIB)/basis/util/integral-comparisons.sml 14.11-14.12 *)
val Word64.>> : LargeWord.word * word -> LargeWord.word (* @ $(SML_LIB)/basis/integer/word.sml 23.5-23.6 *)
val Word64.andb: LargeWord.word * LargeWord.word -> LargeWord.word (* @ $(SML_LIB)/basis/primitive/prim-word.sml 394.11-394.14 *)
val Word64.compare: LargeWord.word * LargeWord.word -> order (* @ $(SML_LIB)/basis/util/integral-comparisons.sml 16.11-16.17 *)
val Word64.div: LargeWord.word * LargeWord.word -> LargeWord.word (* @ $(SML_LIB)/basis/integer/num0.sml 97.23-97.25 *)
val Word64.fmt: StringCvt.radix -> LargeWord.word -> string (* @ $(SML_LIB)/basis/integer/word.sml 104.8-104.10 *)
val Word64.fromInt: int -> LargeWord.word (* @ $(SML_LIB)/basis/integer/word.sml 55.5-55.11 *)
val Word64.fromLarge: LargeWord.word -> LargeWord.word (* @ $(SML_LIB)/basis/integer/word.sml 87.5-87.13 *)
val Word64.fromLargeInt: LargeInt.int -> LargeWord.word (* @ $(SML_LIB)/basis/integer/word.sml 70.5-70.16 *)
val Word64.fromLargeWord: LargeWord.word -> LargeWord.word (* @ $(SML_LIB)/basis/integer/word.sml 86.5-86.17 *)
val Word64.fromString: string -> LargeWord.word option (* @ $(SML_LIB)/basis/integer/word.sml 209.5-209.14 *)
val Word64.max: LargeWord.word * LargeWord.word -> LargeWord.word (* @ $(SML_LIB)/basis/util/integral-comparisons.sml 21.11-21.13 *)
val Word64.min: LargeWord.word * LargeWord.word -> LargeWord.word (* @ $(SML_LIB)/basis/util/integral-comparisons.sml 20.11-20.13 *)
val Word64.mod: LargeWord.word * LargeWord.word -> LargeWord.word (* @ $(SML_LIB)/basis/integer/num0.sml 98.23-98.25 *)
val Word64.notb: LargeWord.word -> LargeWord.word (* @ $(SML_LIB)/basis/primitive/prim-word.sml 398.11-398.14 *)
val Word64.orb: LargeWord.word * LargeWord.word -> LargeWord.word (* @ $(SML_LIB)/basis/primitive/prim-word.sml 399.11-399.13 *)
val Word64.scan: StringCvt.radix -> ('a -> (char * 'a) option) -> 'a -> (LargeWord.word * 'a) option (* @ $(SML_LIB)/basis/integer/word.sml 146.5-146.8 *)
val Word64.toInt: LargeWord.word -> int (* @ $(SML_LIB)/basis/integer/word.sml 57.5-57.9 *)
val Word64.toIntX: LargeWord.word -> int (* @ $(SML_LIB)/basis/integer/word.sml 56.5-56.10 *)
val Word64.toLarge: LargeWord.word -> LargeWord.word (* @ $(SML_LIB)/basis/integer/word.sml 91.5-91.11 *)
val Word64.toLargeInt: LargeWord.word -> LargeInt.int (* @ $(SML_LIB)/basis/integer/word.sml 72.5-72.14 *)
val Word64.toLargeIntX: LargeWord.word -> LargeInt.int (* @ $(SML_LIB)/basis/integer/word.sml 71.5-71.15 *)
val Word64.toLargeWord: LargeWord.word -> LargeWord.word (* @ $(SML_LIB)/basis/integer/word.sml 90.5-90.15 *)
val Word64.toLargeWordX: LargeWord.word -> LargeWord.word (* @ $(SML_LIB)/basis/integer/word.sml 88.5-88.16 *)
val Word64.toLargeX: LargeWord.word -> LargeWord.word (* @ $(SML_LIB)/basis/integer/word.sml 89.5-89.12 *)
val Word64.toString: LargeWord.word -> string (* @ $(SML_LIB)/basis/integer/word.sml 144.5-144.12 *)
val Word64.wordSize: int (* @ $(SML_LIB)/basis/integer/word.sml 16.5-16.12 *)
val Word64.xorb: LargeWord.word * LargeWord.word -> LargeWord.word (* @ $(SML_LIB)/basis/primitive/prim-word.sml 407.11-407.14 *)
val Word64.~ : LargeWord.word -> LargeWord.word (* @ $(SML_LIB)/basis/primitive/prim-word.sml 397.11-397.11 *)
val Word64.~>> : LargeWord.word * word -> LargeWord.word (* @ $(SML_LIB)/basis/integer/word.sml 27.5-27.7 *)
structure Word64Array: MONO_ARRAY where type array = Word64Array.array where type elem = LargeWord.word where type vector = Word64Vector.vector (* @ $(SML_LIB)/basis/libs/basis-2002/top-level/top-level.sml 67.11-67.21 *)
type Word64Array.array = Word64Array.array (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array.fun 23.12-23.16 *)
type Word64Array.elem = LargeWord.word (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array.fun 22.12-22.15 *)
type Word64Array.vector = Word64Vector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array.fun 24.12-24.17 *)
val Word64Array.all: (LargeWord.word -> bool) -> Word64Array.array -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 476.13-476.15 *)
val Word64Array.app: (LargeWord.word -> unit) -> Word64Array.array -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 464.13-464.15 *)
val Word64Array.appi: (int * LargeWord.word -> unit) -> Word64Array.array -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 463.13-463.16 *)
val Word64Array.array: int * LargeWord.word -> Word64Array.array (* @ $(SML_LIB)/basis/arrays-and-vectors/array.sml 34.11-34.15 *)
val Word64Array.collate: (LargeWord.word * LargeWord.word -> order) -> Word64Array.array * Word64Array.array -> order (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 477.13-477.19 *)
val Word64Array.copy: {di: int, dst: Word64Array.array, src: Word64Array.array} -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 457.13-457.16 *)
val Word64Array.copyVec: {di: int, dst: Word64Array.array, src: Word64Vector.vector} -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array.sml 37.11-37.17 *)
val Word64Array.exists: (LargeWord.word -> bool) -> Word64Array.array -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 474.13-474.18 *)
val Word64Array.find: (LargeWord.word -> bool) -> Word64Array.array -> LargeWord.word option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 472.13-472.16 *)
val Word64Array.findi: (int * LargeWord.word -> bool) -> Word64Array.array -> (int * LargeWord.word) option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 471.13-471.17 *)
val Word64Array.foldl: (LargeWord.word * 'a -> 'a) -> 'a -> Word64Array.array -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 468.13-468.17 *)
val Word64Array.foldli: (int * LargeWord.word * 'a -> 'a) -> 'a -> Word64Array.array -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 467.13-467.18 *)
val Word64Array.foldr: (LargeWord.word * 'a -> 'a) -> 'a -> Word64Array.array -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 470.13-470.17 *)
val Word64Array.foldri: (int * LargeWord.word * 'a -> 'a) -> 'a -> Word64Array.array -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 469.13-469.18 *)
val Word64Array.fromList: LargeWord.word list -> Word64Array.array (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 122.11-122.18 *)
val Word64Array.length: Word64Array.array -> int (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 90.11-90.16 *)
val Word64Array.maxLen: int (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 88.11-88.16 *)
val Word64Array.modify: (LargeWord.word -> LargeWord.word) -> Word64Array.array -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array.sml 40.11-40.16 *)
val Word64Array.modifyi: (int * LargeWord.word -> LargeWord.word) -> Word64Array.array -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array.sml 39.11-39.17 *)
val Word64Array.sub: Word64Array.array * int -> LargeWord.word (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 450.13-450.15 *)
val Word64Array.tabulate: int * (int -> LargeWord.word) -> Word64Array.array (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 114.11-114.18 *)
val Word64Array.update: Word64Array.array * int * LargeWord.word -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 452.13-452.18 *)
val Word64Array.vector: Word64Array.array -> Word64Vector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/array.sml 36.11-36.16 *)
structure Word64Array2: MONO_ARRAY2 where type array = Word64Array2.array where type elem = LargeWord.word where type vector = Word64Vector.vector (* @ $(SML_LIB)/basis/libs/basis-2002/top-level/top-level.sml 68.11-68.22 *)
type Word64Array2.array = Word64Array2.array (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array2.fun 18.12-18.16 *)
type Word64Array2.elem = LargeWord.word (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array2.fun 15.12-15.15 *)
type Word64Array2.region = {base: Word64Array2.array, col: int, ncols: int option, nrows: int option, row: int} (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array2.fun 19.12-19.17 *)
datatype Word64Array2.traversal = ColMajor | RowMajor (* = datatype Array2.traversal *) (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 106.16-106.24 *)
type Word64Array2.vector = Word64Vector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array2.fun 16.12-16.17 *)
con Word64Array2.ColMajor: Array2.traversal (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 106.39-106.46 *)
con Word64Array2.RowMajor: Array2.traversal (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 106.28-106.35 *)
val Word64Array2.app: Array2.traversal -> (LargeWord.word -> unit) -> Word64Array2.array -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 294.11-294.13 *)
val Word64Array2.appi: Array2.traversal -> (int * int * LargeWord.word -> unit) -> {base: Word64Array2.array, col: int, ncols: int option, nrows: int option, row: int} -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 291.11-291.14 *)
val Word64Array2.array: int * int * LargeWord.word -> Word64Array2.array (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 140.14-140.18 *)
val Word64Array2.column: Word64Array2.array * int -> Word64Vector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 237.11-237.16 *)
val Word64Array2.copy: {dst: Word64Array2.array, dst_col: int, dst_row: int, src: {base: Word64Array2.array, col: int, ncols: int option, nrows: int option, row: int}} -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 309.11-309.14 *)
val Word64Array2.dimensions: Word64Array2.array -> int * int (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 33.11-33.20 *)
val Word64Array2.fold: Array2.traversal -> (LargeWord.word * 'a -> 'a) -> 'a -> Word64Array2.array -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 288.11-288.14 *)
val Word64Array2.foldi: Array2.traversal -> (int * int * LargeWord.word * 'a -> 'a) -> 'a -> {base: Word64Array2.array, col: int, ncols: int option, nrows: int option, row: int} -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 283.11-283.15 *)
val Word64Array2.fromList: LargeWord.word list list -> Word64Array2.array (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 188.14-188.21 *)
val Word64Array2.modify: Array2.traversal -> (LargeWord.word -> LargeWord.word) -> Word64Array2.array -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 299.11-299.16 *)
val Word64Array2.modifyi: Array2.traversal -> (int * int * LargeWord.word -> LargeWord.word) -> {base: Word64Array2.array, col: int, ncols: int option, nrows: int option, row: int} -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 296.11-296.17 *)
val Word64Array2.nCols: Word64Array2.array -> int (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 38.11-38.15 *)
val Word64Array2.nRows: Word64Array2.array -> int (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 36.11-36.15 *)
val Word64Array2.row: Word64Array2.array * int -> Word64Vector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 222.11-222.13 *)
val Word64Array2.sub: Word64Array2.array * int * int -> LargeWord.word (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 182.14-182.16 *)
val Word64Array2.tabulate: Array2.traversal -> int * int * (int * int -> LargeWord.word) -> Word64Array2.array (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 301.11-301.18 *)
val Word64Array2.update: Word64Array2.array * int * int * LargeWord.word -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 184.14-184.19 *)
structure Word64ArraySlice: MONO_ARRAY_SLICE where type array = Word64Array.array where type elem = LargeWord.word where type slice = Word64ArraySlice.slice where type vector = Word64Vector.vector where type vector_slice = Word64VectorSlice.slice (* @ $(SML_LIB)/basis/libs/basis-extra/top-level/basis.sml 250.17-250.32 *)
type Word64ArraySlice.array = Word64Array.array (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array.fun 35.18-35.22 *)
type Word64ArraySlice.elem = LargeWord.word (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array.fun 34.18-34.21 *)
type Word64ArraySlice.slice = Word64ArraySlice.slice (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array.fun 36.18-36.22 *)
type Word64ArraySlice.vector = Word64Vector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array.fun 37.18-37.23 *)
type Word64ArraySlice.vector_slice = Word64VectorSlice.slice (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array.fun 38.18-38.29 *)
val Word64ArraySlice.all: (LargeWord.word -> bool) -> Word64ArraySlice.slice -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 235.17-235.19 *)
val Word64ArraySlice.app: (LargeWord.word -> unit) -> Word64ArraySlice.slice -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 226.17-226.19 *)
val Word64ArraySlice.appi: (int * LargeWord.word -> unit) -> Word64ArraySlice.slice -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 225.17-225.20 *)
val Word64ArraySlice.base: Word64ArraySlice.slice -> Word64Array.array * int * int (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 208.17-208.20 *)
val Word64ArraySlice.collate: (LargeWord.word * LargeWord.word -> order) -> Word64ArraySlice.slice * Word64ArraySlice.slice -> order (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 236.17-236.23 *)
val Word64ArraySlice.copy: {di: int, dst: Word64Array.array, src: Word64ArraySlice.slice} -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 185.17-185.20 *)
val Word64ArraySlice.copyVec: {di: int, dst: Word64Array.array, src: Word64VectorSlice.slice} -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array.sml 28.17-28.23 *)
val Word64ArraySlice.exists: (LargeWord.word -> bool) -> Word64ArraySlice.slice -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 233.17-233.22 *)
val Word64ArraySlice.find: (LargeWord.word -> bool) -> Word64ArraySlice.slice -> LargeWord.word option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 231.17-231.20 *)
val Word64ArraySlice.findi: (int * LargeWord.word -> bool) -> Word64ArraySlice.slice -> (int * LargeWord.word) option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 229.17-229.21 *)
val Word64ArraySlice.foldl: (LargeWord.word * 'a -> 'a) -> 'a -> Word64ArraySlice.slice -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 223.17-223.21 *)
val Word64ArraySlice.foldli: (int * LargeWord.word * 'a -> 'a) -> 'a -> Word64ArraySlice.slice -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 221.17-221.22 *)
val Word64ArraySlice.foldr: (LargeWord.word * 'a -> 'a) -> 'a -> Word64ArraySlice.slice -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 224.17-224.21 *)
val Word64ArraySlice.foldri: (int * LargeWord.word * 'a -> 'a) -> 'a -> Word64ArraySlice.slice -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 222.17-222.22 *)
val Word64ArraySlice.full: Word64Array.array -> Word64ArraySlice.slice (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 192.17-192.20 *)
val Word64ArraySlice.getItem: Word64ArraySlice.slice -> (LargeWord.word * Word64ArraySlice.slice) option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 220.17-220.23 *)
val Word64ArraySlice.isEmpty: Word64ArraySlice.slice -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 219.17-219.23 *)
val Word64ArraySlice.length: Word64ArraySlice.slice -> int (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 134.17-134.22 *)
val Word64ArraySlice.modify: (LargeWord.word -> LargeWord.word) -> Word64ArraySlice.slice -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array.sml 31.17-31.22 *)
val Word64ArraySlice.modifyi: (int * LargeWord.word -> LargeWord.word) -> Word64ArraySlice.slice -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array.sml 30.17-30.23 *)
val Word64ArraySlice.slice: Word64Array.array * int * int option -> Word64ArraySlice.slice (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 206.17-206.21 *)
val Word64ArraySlice.sub: Word64ArraySlice.slice * int -> LargeWord.word (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 142.17-142.19 *)
val Word64ArraySlice.subslice: Word64ArraySlice.slice * int * int option -> Word64ArraySlice.slice (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 199.17-199.24 *)
val Word64ArraySlice.update: Word64ArraySlice.slice * int * LargeWord.word -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 155.17-155.22 *)
val Word64ArraySlice.vector: Word64ArraySlice.slice -> Word64Vector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/array.sml 27.17-27.22 *)
structure Word64Vector: MONO_VECTOR where type elem = LargeWord.word where type vector = Word64Vector.vector (* @ $(SML_LIB)/basis/libs/basis-2002/top-level/top-level.sml 69.11-69.22 *)
type Word64Vector.elem = LargeWord.word (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-vector.fun 35.12-35.15 *)
type Word64Vector.vector = Word64Vector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-vector.fun 36.12-36.17 *)
val Word64Vector.all: (LargeWord.word -> bool) -> Word64Vector.vector -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 476.13-476.15 *)
val Word64Vector.app: (LargeWord.word -> unit) -> Word64Vector.vector -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 464.13-464.15 *)
val Word64Vector.appi: (int * LargeWord.word -> unit) -> Word64Vector.vector -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 463.13-463.16 *)
val Word64Vector.collate: (LargeWord.word * LargeWord.word -> order) -> Word64Vector.vector * Word64Vector.vector -> order (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 477.13-477.19 *)
val Word64Vector.concat: Word64Vector.vector list -> Word64Vector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 462.13-462.18 *)
val Word64Vector.exists: (LargeWord.word -> bool) -> Word64Vector.vector -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 474.13-474.18 *)
val Word64Vector.find: (LargeWord.word -> bool) -> Word64Vector.vector -> LargeWord.word option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 472.13-472.16 *)
val Word64Vector.findi: (int * LargeWord.word -> bool) -> Word64Vector.vector -> (int * LargeWord.word) option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 471.13-471.17 *)
val Word64Vector.foldl: (LargeWord.word * 'a -> 'a) -> 'a -> Word64Vector.vector -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 468.13-468.17 *)
val Word64Vector.foldli: (int * LargeWord.word * 'a -> 'a) -> 'a -> Word64Vector.vector -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 467.13-467.18 *)
val Word64Vector.foldr: (LargeWord.word * 'a -> 'a) -> 'a -> Word64Vector.vector -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 470.13-470.17 *)
val Word64Vector.foldri: (int * LargeWord.word * 'a -> 'a) -> 'a -> Word64Vector.vector -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 469.13-469.18 *)
val Word64Vector.fromList: LargeWord.word list -> Word64Vector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 122.11-122.18 *)
val Word64Vector.length: Word64Vector.vector -> int (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 90.11-90.16 *)
val Word64Vector.map: (LargeWord.word -> LargeWord.word) -> Word64Vector.vector -> Word64Vector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 466.13-466.15 *)
val Word64Vector.mapi: (int * LargeWord.word -> LargeWord.word) -> Word64Vector.vector -> Word64Vector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 465.13-465.16 *)
val Word64Vector.maxLen: int (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 88.11-88.16 *)
val Word64Vector.sub: Word64Vector.vector * int -> LargeWord.word (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 450.13-450.15 *)
val Word64Vector.tabulate: int * (int -> LargeWord.word) -> Word64Vector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 114.11-114.18 *)
val Word64Vector.update: Word64Vector.vector * int * LargeWord.word -> Word64Vector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/vector.sml 30.11-30.16 *)
structure Word64VectorSlice: MONO_VECTOR_SLICE where type elem = LargeWord.word where type slice = Word64VectorSlice.slice where type vector = Word64Vector.vector (* @ $(SML_LIB)/basis/libs/basis-extra/top-level/basis.sml 252.17-252.33 *)
type Word64VectorSlice.elem = LargeWord.word (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-vector.fun 43.18-43.21 *)
type Word64VectorSlice.slice = Word64VectorSlice.slice (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-vector.fun 45.18-45.22 *)
type Word64VectorSlice.vector = Word64Vector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-vector.fun 44.18-44.23 *)
val Word64VectorSlice.all: (LargeWord.word -> bool) -> Word64VectorSlice.slice -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 235.17-235.19 *)
val Word64VectorSlice.app: (LargeWord.word -> unit) -> Word64VectorSlice.slice -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 226.17-226.19 *)
val Word64VectorSlice.appi: (int * LargeWord.word -> unit) -> Word64VectorSlice.slice -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 225.17-225.20 *)
val Word64VectorSlice.base: Word64VectorSlice.slice -> Word64Vector.vector * int * int (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 208.17-208.20 *)
val Word64VectorSlice.collate: (LargeWord.word * LargeWord.word -> order) -> Word64VectorSlice.slice * Word64VectorSlice.slice -> order (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 236.17-236.23 *)
val Word64VectorSlice.concat: Word64VectorSlice.slice list -> Word64Vector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 240.17-240.22 *)
val Word64VectorSlice.exists: (LargeWord.word -> bool) -> Word64VectorSlice.slice -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 233.17-233.22 *)
val Word64VectorSlice.find: (LargeWord.word -> bool) -> Word64VectorSlice.slice -> LargeWord.word option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 231.17-231.20 *)
val Word64VectorSlice.findi: (int * LargeWord.word -> bool) -> Word64VectorSlice.slice -> (int * LargeWord.word) option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 229.17-229.21 *)
val Word64VectorSlice.foldl: (LargeWord.word * 'a -> 'a) -> 'a -> Word64VectorSlice.slice -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 223.17-223.21 *)
val Word64VectorSlice.foldli: (int * LargeWord.word * 'a -> 'a) -> 'a -> Word64VectorSlice.slice -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 221.17-221.22 *)
val Word64VectorSlice.foldr: (LargeWord.word * 'a -> 'a) -> 'a -> Word64VectorSlice.slice -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 224.17-224.21 *)
val Word64VectorSlice.foldri: (int * LargeWord.word * 'a -> 'a) -> 'a -> Word64VectorSlice.slice -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 222.17-222.22 *)
val Word64VectorSlice.full: Word64Vector.vector -> Word64VectorSlice.slice (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 192.17-192.20 *)
val Word64VectorSlice.getItem: Word64VectorSlice.slice -> (LargeWord.word * Word64VectorSlice.slice) option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 220.17-220.23 *)
val Word64VectorSlice.isEmpty: Word64VectorSlice.slice -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 219.17-219.23 *)
val Word64VectorSlice.length: Word64VectorSlice.slice -> int (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 134.17-134.22 *)
val Word64VectorSlice.map: (LargeWord.word -> LargeWord.word) -> Word64VectorSlice.slice -> Word64Vector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 228.17-228.19 *)
val Word64VectorSlice.mapi: (int * LargeWord.word -> LargeWord.word) -> Word64VectorSlice.slice -> Word64Vector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 227.17-227.20 *)
val Word64VectorSlice.slice: Word64Vector.vector * int * int option -> Word64VectorSlice.slice (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 206.17-206.21 *)
val Word64VectorSlice.sub: Word64VectorSlice.slice * int -> LargeWord.word (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 142.17-142.19 *)
val Word64VectorSlice.subslice: Word64VectorSlice.slice * int * int option -> Word64VectorSlice.slice (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 199.17-199.24 *)
val Word64VectorSlice.vector: Word64VectorSlice.slice -> Word64Vector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/vector.sml 21.17-21.22 *)
structure Word7: WORD where type word = Word7.word (* @ $(SML_LIB)/basis/libs/basis-extra/top-level/basis.sml 205.17-205.21 *)
type Word7.word = Word7.word (* @ $(SML_LIB)/basis/primitive/prim-basis.sml 301.12-301.15 *)
val Word7.* : Word7.word * Word7.word -> Word7.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 62.17-62.17 *)
val Word7.+ : Word7.word * Word7.word -> Word7.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 63.17-63.17 *)
val Word7.- : Word7.word * Word7.word -> Word7.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 64.17-64.17 *)
val Word7.< : Word7.word * Word7.word -> bool (* @ $(SML_LIB)/basis/integer/embed-word.sml 87.17-87.17 *)
val Word7.<< : Word7.word * word -> Word7.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 78.14-78.15 *)
val Word7.<= : Word7.word * Word7.word -> bool (* @ $(SML_LIB)/basis/integer/embed-word.sml 88.17-88.18 *)
val Word7.> : Word7.word * Word7.word -> bool (* @ $(SML_LIB)/basis/integer/embed-word.sml 89.17-89.17 *)
val Word7.>= : Word7.word * Word7.word -> bool (* @ $(SML_LIB)/basis/integer/embed-word.sml 90.17-90.18 *)
val Word7.>> : Word7.word * word -> Word7.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 77.14-77.15 *)
val Word7.andb: Word7.word * Word7.word -> Word7.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 65.14-65.17 *)
val Word7.compare: Word7.word * Word7.word -> order (* @ $(SML_LIB)/basis/integer/embed-word.sml 91.14-91.20 *)
val Word7.div: Word7.word * Word7.word -> Word7.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 66.17-66.19 *)
val Word7.fmt: StringCvt.radix -> Word7.word -> string (* @ $(SML_LIB)/basis/integer/embed-word.sml 129.11-129.13 *)
val Word7.fromInt: int -> Word7.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 105.14-105.20 *)
val Word7.fromLarge: LargeWord.word -> Word7.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 106.14-106.22 *)
val Word7.fromLargeInt: LargeInt.int -> Word7.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 107.14-107.25 *)
val Word7.fromLargeWord: LargeWord.word -> Word7.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 131.11-131.23 *)
val Word7.fromString: string -> Word7.word option (* @ $(SML_LIB)/basis/integer/embed-word.sml 133.11-133.20 *)
val Word7.max: Word7.word * Word7.word -> Word7.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 135.11-135.13 *)
val Word7.min: Word7.word * Word7.word -> Word7.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 137.11-137.13 *)
val Word7.mod: Word7.word * Word7.word -> Word7.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 67.17-67.19 *)
val Word7.notb: Word7.word -> Word7.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 98.14-98.17 *)
val Word7.orb: Word7.word * Word7.word -> Word7.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 68.14-68.16 *)
val Word7.scan: StringCvt.radix -> ('a -> (char * 'a) option) -> 'a -> (Word7.word * 'a) option (* @ $(SML_LIB)/basis/integer/embed-word.sml 139.11-139.14 *)
val Word7.toInt: Word7.word -> int (* @ $(SML_LIB)/basis/integer/embed-word.sml 114.14-114.18 *)
val Word7.toIntX: Word7.word -> int (* @ $(SML_LIB)/basis/integer/embed-word.sml 124.14-124.19 *)
val Word7.toLarge: Word7.word -> LargeWord.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 115.14-115.20 *)
val Word7.toLargeInt: Word7.word -> LargeInt.int (* @ $(SML_LIB)/basis/integer/embed-word.sml 116.14-116.23 *)
val Word7.toLargeIntX: Word7.word -> LargeInt.int (* @ $(SML_LIB)/basis/integer/embed-word.sml 125.14-125.24 *)
val Word7.toLargeWord: Word7.word -> LargeWord.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 144.11-144.21 *)
val Word7.toLargeWordX: Word7.word -> LargeWord.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 146.11-146.22 *)
val Word7.toLargeX: Word7.word -> LargeWord.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 126.14-126.21 *)
val Word7.toString: Word7.word -> string (* @ $(SML_LIB)/basis/integer/embed-word.sml 117.14-117.21 *)
val Word7.wordSize: int (* @ $(SML_LIB)/basis/integer/embed-word.sml 24.17-24.24 *)
val Word7.xorb: Word7.word * Word7.word -> Word7.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 69.14-69.17 *)
val Word7.~ : Word7.word -> Word7.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 148.11-148.11 *)
val Word7.~>> : Word7.word * word -> Word7.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 81.11-81.13 *)
structure Word8: WORD where type word = Word8.word (* @ $(SML_LIB)/basis/libs/basis-2002/top-level/top-level.sml 87.11-87.15 *)
type Word8.word = Word8.word (* @ $(SML_LIB)/basis/primitive/prim-basis.sml 306.12-306.15 *)
val Word8.* : Word8.word * Word8.word -> Word8.word (* @ $(SML_LIB)/basis/primitive/prim-word.sml 115.11-115.11 *)
val Word8.+ : Word8.word * Word8.word -> Word8.word (* @ $(SML_LIB)/basis/primitive/prim-word.sml 112.11-112.11 *)
val Word8.- : Word8.word * Word8.word -> Word8.word (* @ $(SML_LIB)/basis/primitive/prim-word.sml 125.11-125.11 *)
val Word8.< : Word8.word * Word8.word -> bool (* @ $(SML_LIB)/basis/util/integral-comparisons.sml 11.11-11.11 *)
val Word8.<< : Word8.word * word -> Word8.word (* @ $(SML_LIB)/basis/integer/word.sml 19.5-19.6 *)
val Word8.<= : Word8.word * Word8.word -> bool (* @ $(SML_LIB)/basis/util/integral-comparisons.sml 12.11-12.12 *)
val Word8.> : Word8.word * Word8.word -> bool (* @ $(SML_LIB)/basis/util/integral-comparisons.sml 13.11-13.11 *)
val Word8.>= : Word8.word * Word8.word -> bool (* @ $(SML_LIB)/basis/util/integral-comparisons.sml 14.11-14.12 *)
val Word8.>> : Word8.word * word -> Word8.word (* @ $(SML_LIB)/basis/integer/word.sml 23.5-23.6 *)
val Word8.andb: Word8.word * Word8.word -> Word8.word (* @ $(SML_LIB)/basis/primitive/prim-word.sml 113.11-113.14 *)
val Word8.compare: Word8.word * Word8.word -> order (* @ $(SML_LIB)/basis/util/integral-comparisons.sml 16.11-16.17 *)
val Word8.div: Word8.word * Word8.word -> Word8.word (* @ $(SML_LIB)/basis/integer/num0.sml 97.23-97.25 *)
val Word8.fmt: StringCvt.radix -> Word8.word -> string (* @ $(SML_LIB)/basis/integer/word.sml 104.8-104.10 *)
val Word8.fromInt: int -> Word8.word (* @ $(SML_LIB)/basis/integer/word.sml 55.5-55.11 *)
val Word8.fromLarge: LargeWord.word -> Word8.word (* @ $(SML_LIB)/basis/integer/word.sml 87.5-87.13 *)
val Word8.fromLargeInt: LargeInt.int -> Word8.word (* @ $(SML_LIB)/basis/integer/word.sml 70.5-70.16 *)
val Word8.fromLargeWord: LargeWord.word -> Word8.word (* @ $(SML_LIB)/basis/integer/word.sml 86.5-86.17 *)
val Word8.fromString: string -> Word8.word option (* @ $(SML_LIB)/basis/integer/word.sml 209.5-209.14 *)
val Word8.max: Word8.word * Word8.word -> Word8.word (* @ $(SML_LIB)/basis/util/integral-comparisons.sml 21.11-21.13 *)
val Word8.min: Word8.word * Word8.word -> Word8.word (* @ $(SML_LIB)/basis/util/integral-comparisons.sml 20.11-20.13 *)
val Word8.mod: Word8.word * Word8.word -> Word8.word (* @ $(SML_LIB)/basis/integer/num0.sml 98.23-98.25 *)
val Word8.notb: Word8.word -> Word8.word (* @ $(SML_LIB)/basis/primitive/prim-word.sml 117.11-117.14 *)
val Word8.orb: Word8.word * Word8.word -> Word8.word (* @ $(SML_LIB)/basis/primitive/prim-word.sml 118.11-118.13 *)
val Word8.scan: StringCvt.radix -> ('a -> (char * 'a) option) -> 'a -> (Word8.word * 'a) option (* @ $(SML_LIB)/basis/integer/word.sml 146.5-146.8 *)
val Word8.toInt: Word8.word -> int (* @ $(SML_LIB)/basis/integer/word.sml 57.5-57.9 *)
val Word8.toIntX: Word8.word -> int (* @ $(SML_LIB)/basis/integer/word.sml 56.5-56.10 *)
val Word8.toLarge: Word8.word -> LargeWord.word (* @ $(SML_LIB)/basis/integer/word.sml 91.5-91.11 *)
val Word8.toLargeInt: Word8.word -> LargeInt.int (* @ $(SML_LIB)/basis/integer/word.sml 72.5-72.14 *)
val Word8.toLargeIntX: Word8.word -> LargeInt.int (* @ $(SML_LIB)/basis/integer/word.sml 71.5-71.15 *)
val Word8.toLargeWord: Word8.word -> LargeWord.word (* @ $(SML_LIB)/basis/integer/word.sml 90.5-90.15 *)
val Word8.toLargeWordX: Word8.word -> LargeWord.word (* @ $(SML_LIB)/basis/integer/word.sml 88.5-88.16 *)
val Word8.toLargeX: Word8.word -> LargeWord.word (* @ $(SML_LIB)/basis/integer/word.sml 89.5-89.12 *)
val Word8.toString: Word8.word -> string (* @ $(SML_LIB)/basis/integer/word.sml 144.5-144.12 *)
val Word8.wordSize: int (* @ $(SML_LIB)/basis/integer/word.sml 16.5-16.12 *)
val Word8.xorb: Word8.word * Word8.word -> Word8.word (* @ $(SML_LIB)/basis/primitive/prim-word.sml 126.11-126.14 *)
val Word8.~ : Word8.word -> Word8.word (* @ $(SML_LIB)/basis/primitive/prim-word.sml 116.11-116.11 *)
val Word8.~>> : Word8.word * word -> Word8.word (* @ $(SML_LIB)/basis/integer/word.sml 27.5-27.7 *)
structure Word8Array: MONO_ARRAY where type array = Word8Array.array where type elem = Word8.word where type vector = Word8Vector.vector (* @ $(SML_LIB)/basis/libs/basis-2002/top-level/top-level.sml 58.11-58.20 *)
type Word8Array.array = Word8Array.array (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array.fun 23.12-23.16 *)
type Word8Array.elem = Word8.word (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array.fun 22.12-22.15 *)
type Word8Array.vector = Word8Vector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array.fun 24.12-24.17 *)
val Word8Array.all: (Word8.word -> bool) -> Word8Array.array -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 476.13-476.15 *)
val Word8Array.app: (Word8.word -> unit) -> Word8Array.array -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 464.13-464.15 *)
val Word8Array.appi: (int * Word8.word -> unit) -> Word8Array.array -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 463.13-463.16 *)
val Word8Array.array: int * Word8.word -> Word8Array.array (* @ $(SML_LIB)/basis/arrays-and-vectors/array.sml 34.11-34.15 *)
val Word8Array.collate: (Word8.word * Word8.word -> order) -> Word8Array.array * Word8Array.array -> order (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 477.13-477.19 *)
val Word8Array.copy: {di: int, dst: Word8Array.array, src: Word8Array.array} -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 457.13-457.16 *)
val Word8Array.copyVec: {di: int, dst: Word8Array.array, src: Word8Vector.vector} -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array.sml 37.11-37.17 *)
val Word8Array.exists: (Word8.word -> bool) -> Word8Array.array -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 474.13-474.18 *)
val Word8Array.find: (Word8.word -> bool) -> Word8Array.array -> Word8.word option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 472.13-472.16 *)
val Word8Array.findi: (int * Word8.word -> bool) -> Word8Array.array -> (int * Word8.word) option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 471.13-471.17 *)
val Word8Array.foldl: (Word8.word * 'a -> 'a) -> 'a -> Word8Array.array -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 468.13-468.17 *)
val Word8Array.foldli: (int * Word8.word * 'a -> 'a) -> 'a -> Word8Array.array -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 467.13-467.18 *)
val Word8Array.foldr: (Word8.word * 'a -> 'a) -> 'a -> Word8Array.array -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 470.13-470.17 *)
val Word8Array.foldri: (int * Word8.word * 'a -> 'a) -> 'a -> Word8Array.array -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 469.13-469.18 *)
val Word8Array.fromList: Word8.word list -> Word8Array.array (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 122.11-122.18 *)
val Word8Array.length: Word8Array.array -> int (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 90.11-90.16 *)
val Word8Array.maxLen: int (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 88.11-88.16 *)
val Word8Array.modify: (Word8.word -> Word8.word) -> Word8Array.array -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array.sml 40.11-40.16 *)
val Word8Array.modifyi: (int * Word8.word -> Word8.word) -> Word8Array.array -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array.sml 39.11-39.17 *)
val Word8Array.sub: Word8Array.array * int -> Word8.word (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 450.13-450.15 *)
val Word8Array.tabulate: int * (int -> Word8.word) -> Word8Array.array (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 114.11-114.18 *)
val Word8Array.update: Word8Array.array * int * Word8.word -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 452.13-452.18 *)
val Word8Array.vector: Word8Array.array -> Word8Vector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/array.sml 36.11-36.16 *)
structure Word8Array2: MONO_ARRAY2 where type array = Word8Array2.array where type elem = Word8.word where type vector = Word8Vector.vector (* @ $(SML_LIB)/basis/libs/basis-2002/top-level/top-level.sml 59.11-59.21 *)
type Word8Array2.array = Word8Array2.array (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array2.fun 18.12-18.16 *)
type Word8Array2.elem = Word8.word (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array2.fun 15.12-15.15 *)
type Word8Array2.region = {base: Word8Array2.array, col: int, ncols: int option, nrows: int option, row: int} (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array2.fun 19.12-19.17 *)
datatype Word8Array2.traversal = ColMajor | RowMajor (* = datatype Array2.traversal *) (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 106.16-106.24 *)
type Word8Array2.vector = Word8Vector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array2.fun 16.12-16.17 *)
con Word8Array2.ColMajor: Array2.traversal (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 106.39-106.46 *)
con Word8Array2.RowMajor: Array2.traversal (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 106.28-106.35 *)
val Word8Array2.app: Array2.traversal -> (Word8.word -> unit) -> Word8Array2.array -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 294.11-294.13 *)
val Word8Array2.appi: Array2.traversal -> (int * int * Word8.word -> unit) -> {base: Word8Array2.array, col: int, ncols: int option, nrows: int option, row: int} -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 291.11-291.14 *)
val Word8Array2.array: int * int * Word8.word -> Word8Array2.array (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 140.14-140.18 *)
val Word8Array2.column: Word8Array2.array * int -> Word8Vector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 237.11-237.16 *)
val Word8Array2.copy: {dst: Word8Array2.array, dst_col: int, dst_row: int, src: {base: Word8Array2.array, col: int, ncols: int option, nrows: int option, row: int}} -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 309.11-309.14 *)
val Word8Array2.dimensions: Word8Array2.array -> int * int (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 33.11-33.20 *)
val Word8Array2.fold: Array2.traversal -> (Word8.word * 'a -> 'a) -> 'a -> Word8Array2.array -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 288.11-288.14 *)
val Word8Array2.foldi: Array2.traversal -> (int * int * Word8.word * 'a -> 'a) -> 'a -> {base: Word8Array2.array, col: int, ncols: int option, nrows: int option, row: int} -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 283.11-283.15 *)
val Word8Array2.fromList: Word8.word list list -> Word8Array2.array (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 188.14-188.21 *)
val Word8Array2.modify: Array2.traversal -> (Word8.word -> Word8.word) -> Word8Array2.array -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 299.11-299.16 *)
val Word8Array2.modifyi: Array2.traversal -> (int * int * Word8.word -> Word8.word) -> {base: Word8Array2.array, col: int, ncols: int option, nrows: int option, row: int} -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 296.11-296.17 *)
val Word8Array2.nCols: Word8Array2.array -> int (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 38.11-38.15 *)
val Word8Array2.nRows: Word8Array2.array -> int (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 36.11-36.15 *)
val Word8Array2.row: Word8Array2.array * int -> Word8Vector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 222.11-222.13 *)
val Word8Array2.sub: Word8Array2.array * int * int -> Word8.word (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 182.14-182.16 *)
val Word8Array2.tabulate: Array2.traversal -> int * int * (int * int -> Word8.word) -> Word8Array2.array (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 301.11-301.18 *)
val Word8Array2.update: Word8Array2.array * int * int * Word8.word -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 184.14-184.19 *)
structure Word8ArraySlice: MONO_ARRAY_SLICE where type array = Word8Array.array where type elem = Word8.word where type slice = Word8ArraySlice.slice where type vector = Word8Vector.vector where type vector_slice = Word8VectorSlice.slice (* @ $(SML_LIB)/basis/libs/basis-extra/top-level/basis.sml 51.17-51.31 *)
type Word8ArraySlice.array = Word8Array.array (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array.fun 35.18-35.22 *)
type Word8ArraySlice.elem = Word8.word (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array.fun 34.18-34.21 *)
type Word8ArraySlice.slice = Word8ArraySlice.slice (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array.fun 36.18-36.22 *)
type Word8ArraySlice.vector = Word8Vector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array.fun 37.18-37.23 *)
type Word8ArraySlice.vector_slice = Word8VectorSlice.slice (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array.fun 38.18-38.29 *)
val Word8ArraySlice.all: (Word8.word -> bool) -> Word8ArraySlice.slice -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 235.17-235.19 *)
val Word8ArraySlice.app: (Word8.word -> unit) -> Word8ArraySlice.slice -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 226.17-226.19 *)
val Word8ArraySlice.appi: (int * Word8.word -> unit) -> Word8ArraySlice.slice -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 225.17-225.20 *)
val Word8ArraySlice.base: Word8ArraySlice.slice -> Word8Array.array * int * int (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 208.17-208.20 *)
val Word8ArraySlice.collate: (Word8.word * Word8.word -> order) -> Word8ArraySlice.slice * Word8ArraySlice.slice -> order (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 236.17-236.23 *)
val Word8ArraySlice.copy: {di: int, dst: Word8Array.array, src: Word8ArraySlice.slice} -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 185.17-185.20 *)
val Word8ArraySlice.copyVec: {di: int, dst: Word8Array.array, src: Word8VectorSlice.slice} -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array.sml 28.17-28.23 *)
val Word8ArraySlice.exists: (Word8.word -> bool) -> Word8ArraySlice.slice -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 233.17-233.22 *)
val Word8ArraySlice.find: (Word8.word -> bool) -> Word8ArraySlice.slice -> Word8.word option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 231.17-231.20 *)
val Word8ArraySlice.findi: (int * Word8.word -> bool) -> Word8ArraySlice.slice -> (int * Word8.word) option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 229.17-229.21 *)
val Word8ArraySlice.foldl: (Word8.word * 'a -> 'a) -> 'a -> Word8ArraySlice.slice -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 223.17-223.21 *)
val Word8ArraySlice.foldli: (int * Word8.word * 'a -> 'a) -> 'a -> Word8ArraySlice.slice -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 221.17-221.22 *)
val Word8ArraySlice.foldr: (Word8.word * 'a -> 'a) -> 'a -> Word8ArraySlice.slice -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 224.17-224.21 *)
val Word8ArraySlice.foldri: (int * Word8.word * 'a -> 'a) -> 'a -> Word8ArraySlice.slice -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 222.17-222.22 *)
val Word8ArraySlice.full: Word8Array.array -> Word8ArraySlice.slice (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 192.17-192.20 *)
val Word8ArraySlice.getItem: Word8ArraySlice.slice -> (Word8.word * Word8ArraySlice.slice) option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 220.17-220.23 *)
val Word8ArraySlice.isEmpty: Word8ArraySlice.slice -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 219.17-219.23 *)
val Word8ArraySlice.length: Word8ArraySlice.slice -> int (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 134.17-134.22 *)
val Word8ArraySlice.modify: (Word8.word -> Word8.word) -> Word8ArraySlice.slice -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array.sml 31.17-31.22 *)
val Word8ArraySlice.modifyi: (int * Word8.word -> Word8.word) -> Word8ArraySlice.slice -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array.sml 30.17-30.23 *)
val Word8ArraySlice.slice: Word8Array.array * int * int option -> Word8ArraySlice.slice (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 206.17-206.21 *)
val Word8ArraySlice.sub: Word8ArraySlice.slice * int -> Word8.word (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 142.17-142.19 *)
val Word8ArraySlice.subslice: Word8ArraySlice.slice * int * int option -> Word8ArraySlice.slice (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 199.17-199.24 *)
val Word8ArraySlice.update: Word8ArraySlice.slice * int * Word8.word -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 155.17-155.22 *)
val Word8ArraySlice.vector: Word8ArraySlice.slice -> Word8Vector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/array.sml 27.17-27.22 *)
structure Word8Vector: MONO_VECTOR where type elem = Word8.word where type vector = Word8Vector.vector (* @ $(SML_LIB)/basis/libs/basis-2002/top-level/top-level.sml 60.11-60.21 *)
type Word8Vector.elem = Word8.word (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-vector.fun 35.12-35.15 *)
type Word8Vector.vector = Word8Vector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-vector.fun 36.12-36.17 *)
val Word8Vector.all: (Word8.word -> bool) -> Word8Vector.vector -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 476.13-476.15 *)
val Word8Vector.app: (Word8.word -> unit) -> Word8Vector.vector -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 464.13-464.15 *)
val Word8Vector.appi: (int * Word8.word -> unit) -> Word8Vector.vector -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 463.13-463.16 *)
val Word8Vector.collate: (Word8.word * Word8.word -> order) -> Word8Vector.vector * Word8Vector.vector -> order (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 477.13-477.19 *)
val Word8Vector.concat: Word8Vector.vector list -> Word8Vector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 462.13-462.18 *)
val Word8Vector.exists: (Word8.word -> bool) -> Word8Vector.vector -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 474.13-474.18 *)
val Word8Vector.find: (Word8.word -> bool) -> Word8Vector.vector -> Word8.word option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 472.13-472.16 *)
val Word8Vector.findi: (int * Word8.word -> bool) -> Word8Vector.vector -> (int * Word8.word) option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 471.13-471.17 *)
val Word8Vector.foldl: (Word8.word * 'a -> 'a) -> 'a -> Word8Vector.vector -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 468.13-468.17 *)
val Word8Vector.foldli: (int * Word8.word * 'a -> 'a) -> 'a -> Word8Vector.vector -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 467.13-467.18 *)
val Word8Vector.foldr: (Word8.word * 'a -> 'a) -> 'a -> Word8Vector.vector -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 470.13-470.17 *)
val Word8Vector.foldri: (int * Word8.word * 'a -> 'a) -> 'a -> Word8Vector.vector -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 469.13-469.18 *)
val Word8Vector.fromList: Word8.word list -> Word8Vector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 122.11-122.18 *)
val Word8Vector.length: Word8Vector.vector -> int (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 90.11-90.16 *)
val Word8Vector.map: (Word8.word -> Word8.word) -> Word8Vector.vector -> Word8Vector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 466.13-466.15 *)
val Word8Vector.mapi: (int * Word8.word -> Word8.word) -> Word8Vector.vector -> Word8Vector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 465.13-465.16 *)
val Word8Vector.maxLen: int (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 88.11-88.16 *)
val Word8Vector.sub: Word8Vector.vector * int -> Word8.word (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 450.13-450.15 *)
val Word8Vector.tabulate: int * (int -> Word8.word) -> Word8Vector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 114.11-114.18 *)
val Word8Vector.update: Word8Vector.vector * int * Word8.word -> Word8Vector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/vector.sml 30.11-30.16 *)
structure Word8VectorSlice: MONO_VECTOR_SLICE where type elem = Word8.word where type slice = Word8VectorSlice.slice where type vector = Word8Vector.vector (* @ $(SML_LIB)/basis/libs/basis-extra/top-level/basis.sml 53.17-53.32 *)
type Word8VectorSlice.elem = Word8.word (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-vector.fun 43.18-43.21 *)
type Word8VectorSlice.slice = Word8VectorSlice.slice (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-vector.fun 45.18-45.22 *)
type Word8VectorSlice.vector = Word8Vector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-vector.fun 44.18-44.23 *)
val Word8VectorSlice.all: (Word8.word -> bool) -> Word8VectorSlice.slice -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 235.17-235.19 *)
val Word8VectorSlice.app: (Word8.word -> unit) -> Word8VectorSlice.slice -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 226.17-226.19 *)
val Word8VectorSlice.appi: (int * Word8.word -> unit) -> Word8VectorSlice.slice -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 225.17-225.20 *)
val Word8VectorSlice.base: Word8VectorSlice.slice -> Word8Vector.vector * int * int (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 208.17-208.20 *)
val Word8VectorSlice.collate: (Word8.word * Word8.word -> order) -> Word8VectorSlice.slice * Word8VectorSlice.slice -> order (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 236.17-236.23 *)
val Word8VectorSlice.concat: Word8VectorSlice.slice list -> Word8Vector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 240.17-240.22 *)
val Word8VectorSlice.exists: (Word8.word -> bool) -> Word8VectorSlice.slice -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 233.17-233.22 *)
val Word8VectorSlice.find: (Word8.word -> bool) -> Word8VectorSlice.slice -> Word8.word option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 231.17-231.20 *)
val Word8VectorSlice.findi: (int * Word8.word -> bool) -> Word8VectorSlice.slice -> (int * Word8.word) option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 229.17-229.21 *)
val Word8VectorSlice.foldl: (Word8.word * 'a -> 'a) -> 'a -> Word8VectorSlice.slice -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 223.17-223.21 *)
val Word8VectorSlice.foldli: (int * Word8.word * 'a -> 'a) -> 'a -> Word8VectorSlice.slice -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 221.17-221.22 *)
val Word8VectorSlice.foldr: (Word8.word * 'a -> 'a) -> 'a -> Word8VectorSlice.slice -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 224.17-224.21 *)
val Word8VectorSlice.foldri: (int * Word8.word * 'a -> 'a) -> 'a -> Word8VectorSlice.slice -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 222.17-222.22 *)
val Word8VectorSlice.full: Word8Vector.vector -> Word8VectorSlice.slice (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 192.17-192.20 *)
val Word8VectorSlice.getItem: Word8VectorSlice.slice -> (Word8.word * Word8VectorSlice.slice) option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 220.17-220.23 *)
val Word8VectorSlice.isEmpty: Word8VectorSlice.slice -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 219.17-219.23 *)
val Word8VectorSlice.length: Word8VectorSlice.slice -> int (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 134.17-134.22 *)
val Word8VectorSlice.map: (Word8.word -> Word8.word) -> Word8VectorSlice.slice -> Word8Vector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 228.17-228.19 *)
val Word8VectorSlice.mapi: (int * Word8.word -> Word8.word) -> Word8VectorSlice.slice -> Word8Vector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 227.17-227.20 *)
val Word8VectorSlice.slice: Word8Vector.vector * int * int option -> Word8VectorSlice.slice (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 206.17-206.21 *)
val Word8VectorSlice.sub: Word8VectorSlice.slice * int -> Word8.word (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 142.17-142.19 *)
val Word8VectorSlice.subslice: Word8VectorSlice.slice * int * int option -> Word8VectorSlice.slice (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 199.17-199.24 *)
val Word8VectorSlice.vector: Word8VectorSlice.slice -> Word8Vector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/vector.sml 21.17-21.22 *)
structure Word9: WORD where type word = Word9.word (* @ $(SML_LIB)/basis/libs/basis-extra/top-level/basis.sml 207.17-207.21 *)
type Word9.word = Word9.word (* @ $(SML_LIB)/basis/primitive/prim-basis.sml 311.12-311.15 *)
val Word9.* : Word9.word * Word9.word -> Word9.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 62.17-62.17 *)
val Word9.+ : Word9.word * Word9.word -> Word9.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 63.17-63.17 *)
val Word9.- : Word9.word * Word9.word -> Word9.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 64.17-64.17 *)
val Word9.< : Word9.word * Word9.word -> bool (* @ $(SML_LIB)/basis/integer/embed-word.sml 87.17-87.17 *)
val Word9.<< : Word9.word * word -> Word9.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 78.14-78.15 *)
val Word9.<= : Word9.word * Word9.word -> bool (* @ $(SML_LIB)/basis/integer/embed-word.sml 88.17-88.18 *)
val Word9.> : Word9.word * Word9.word -> bool (* @ $(SML_LIB)/basis/integer/embed-word.sml 89.17-89.17 *)
val Word9.>= : Word9.word * Word9.word -> bool (* @ $(SML_LIB)/basis/integer/embed-word.sml 90.17-90.18 *)
val Word9.>> : Word9.word * word -> Word9.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 77.14-77.15 *)
val Word9.andb: Word9.word * Word9.word -> Word9.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 65.14-65.17 *)
val Word9.compare: Word9.word * Word9.word -> order (* @ $(SML_LIB)/basis/integer/embed-word.sml 91.14-91.20 *)
val Word9.div: Word9.word * Word9.word -> Word9.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 66.17-66.19 *)
val Word9.fmt: StringCvt.radix -> Word9.word -> string (* @ $(SML_LIB)/basis/integer/embed-word.sml 129.11-129.13 *)
val Word9.fromInt: int -> Word9.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 105.14-105.20 *)
val Word9.fromLarge: LargeWord.word -> Word9.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 106.14-106.22 *)
val Word9.fromLargeInt: LargeInt.int -> Word9.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 107.14-107.25 *)
val Word9.fromLargeWord: LargeWord.word -> Word9.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 131.11-131.23 *)
val Word9.fromString: string -> Word9.word option (* @ $(SML_LIB)/basis/integer/embed-word.sml 133.11-133.20 *)
val Word9.max: Word9.word * Word9.word -> Word9.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 135.11-135.13 *)
val Word9.min: Word9.word * Word9.word -> Word9.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 137.11-137.13 *)
val Word9.mod: Word9.word * Word9.word -> Word9.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 67.17-67.19 *)
val Word9.notb: Word9.word -> Word9.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 98.14-98.17 *)
val Word9.orb: Word9.word * Word9.word -> Word9.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 68.14-68.16 *)
val Word9.scan: StringCvt.radix -> ('a -> (char * 'a) option) -> 'a -> (Word9.word * 'a) option (* @ $(SML_LIB)/basis/integer/embed-word.sml 139.11-139.14 *)
val Word9.toInt: Word9.word -> int (* @ $(SML_LIB)/basis/integer/embed-word.sml 114.14-114.18 *)
val Word9.toIntX: Word9.word -> int (* @ $(SML_LIB)/basis/integer/embed-word.sml 124.14-124.19 *)
val Word9.toLarge: Word9.word -> LargeWord.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 115.14-115.20 *)
val Word9.toLargeInt: Word9.word -> LargeInt.int (* @ $(SML_LIB)/basis/integer/embed-word.sml 116.14-116.23 *)
val Word9.toLargeIntX: Word9.word -> LargeInt.int (* @ $(SML_LIB)/basis/integer/embed-word.sml 125.14-125.24 *)
val Word9.toLargeWord: Word9.word -> LargeWord.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 144.11-144.21 *)
val Word9.toLargeWordX: Word9.word -> LargeWord.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 146.11-146.22 *)
val Word9.toLargeX: Word9.word -> LargeWord.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 126.14-126.21 *)
val Word9.toString: Word9.word -> string (* @ $(SML_LIB)/basis/integer/embed-word.sml 117.14-117.21 *)
val Word9.wordSize: int (* @ $(SML_LIB)/basis/integer/embed-word.sml 24.17-24.24 *)
val Word9.xorb: Word9.word * Word9.word -> Word9.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 69.14-69.17 *)
val Word9.~ : Word9.word -> Word9.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 148.11-148.11 *)
val Word9.~>> : Word9.word * word -> Word9.word (* @ $(SML_LIB)/basis/integer/embed-word.sml 81.11-81.13 *)
structure WordArray: MONO_ARRAY where type array = WordArray.array where type elem = word where type vector = WordVector.vector (* @ $(SML_LIB)/basis/libs/basis-2002/top-level/top-level.sml 70.11-70.19 *)
type WordArray.array = WordArray.array (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array.fun 23.12-23.16 *)
type WordArray.elem = word (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array.fun 22.12-22.15 *)
type WordArray.vector = WordVector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array.fun 24.12-24.17 *)
val WordArray.all: (word -> bool) -> WordArray.array -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 476.13-476.15 *)
val WordArray.app: (word -> unit) -> WordArray.array -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 464.13-464.15 *)
val WordArray.appi: (int * word -> unit) -> WordArray.array -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 463.13-463.16 *)
val WordArray.array: int * word -> WordArray.array (* @ $(SML_LIB)/basis/arrays-and-vectors/array.sml 34.11-34.15 *)
val WordArray.collate: (word * word -> order) -> WordArray.array * WordArray.array -> order (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 477.13-477.19 *)
val WordArray.copy: {di: int, dst: WordArray.array, src: WordArray.array} -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 457.13-457.16 *)
val WordArray.copyVec: {di: int, dst: WordArray.array, src: WordVector.vector} -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array.sml 37.11-37.17 *)
val WordArray.exists: (word -> bool) -> WordArray.array -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 474.13-474.18 *)
val WordArray.find: (word -> bool) -> WordArray.array -> word option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 472.13-472.16 *)
val WordArray.findi: (int * word -> bool) -> WordArray.array -> (int * word) option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 471.13-471.17 *)
val WordArray.foldl: (word * 'a -> 'a) -> 'a -> WordArray.array -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 468.13-468.17 *)
val WordArray.foldli: (int * word * 'a -> 'a) -> 'a -> WordArray.array -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 467.13-467.18 *)
val WordArray.foldr: (word * 'a -> 'a) -> 'a -> WordArray.array -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 470.13-470.17 *)
val WordArray.foldri: (int * word * 'a -> 'a) -> 'a -> WordArray.array -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 469.13-469.18 *)
val WordArray.fromList: word list -> WordArray.array (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 122.11-122.18 *)
val WordArray.length: WordArray.array -> int (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 90.11-90.16 *)
val WordArray.maxLen: int (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 88.11-88.16 *)
val WordArray.modify: (word -> word) -> WordArray.array -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array.sml 40.11-40.16 *)
val WordArray.modifyi: (int * word -> word) -> WordArray.array -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array.sml 39.11-39.17 *)
val WordArray.sub: WordArray.array * int -> word (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 450.13-450.15 *)
val WordArray.tabulate: int * (int -> word) -> WordArray.array (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 114.11-114.18 *)
val WordArray.update: WordArray.array * int * word -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 452.13-452.18 *)
val WordArray.vector: WordArray.array -> WordVector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/array.sml 36.11-36.16 *)
structure WordArray2: MONO_ARRAY2 where type array = WordArray2.array where type elem = word where type vector = WordVector.vector (* @ $(SML_LIB)/basis/libs/basis-2002/top-level/top-level.sml 71.11-71.20 *)
type WordArray2.array = WordArray2.array (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array2.fun 18.12-18.16 *)
type WordArray2.elem = word (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array2.fun 15.12-15.15 *)
type WordArray2.region = {base: WordArray2.array, col: int, ncols: int option, nrows: int option, row: int} (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array2.fun 19.12-19.17 *)
datatype WordArray2.traversal = ColMajor | RowMajor (* = datatype Array2.traversal *) (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 106.16-106.24 *)
type WordArray2.vector = WordVector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array2.fun 16.12-16.17 *)
con WordArray2.ColMajor: Array2.traversal (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 106.39-106.46 *)
con WordArray2.RowMajor: Array2.traversal (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 106.28-106.35 *)
val WordArray2.app: Array2.traversal -> (word -> unit) -> WordArray2.array -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 294.11-294.13 *)
val WordArray2.appi: Array2.traversal -> (int * int * word -> unit) -> {base: WordArray2.array, col: int, ncols: int option, nrows: int option, row: int} -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 291.11-291.14 *)
val WordArray2.array: int * int * word -> WordArray2.array (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 140.14-140.18 *)
val WordArray2.column: WordArray2.array * int -> WordVector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 237.11-237.16 *)
val WordArray2.copy: {dst: WordArray2.array, dst_col: int, dst_row: int, src: {base: WordArray2.array, col: int, ncols: int option, nrows: int option, row: int}} -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 309.11-309.14 *)
val WordArray2.dimensions: WordArray2.array -> int * int (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 33.11-33.20 *)
val WordArray2.fold: Array2.traversal -> (word * 'a -> 'a) -> 'a -> WordArray2.array -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 288.11-288.14 *)
val WordArray2.foldi: Array2.traversal -> (int * int * word * 'a -> 'a) -> 'a -> {base: WordArray2.array, col: int, ncols: int option, nrows: int option, row: int} -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 283.11-283.15 *)
val WordArray2.fromList: word list list -> WordArray2.array (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 188.14-188.21 *)
val WordArray2.modify: Array2.traversal -> (word -> word) -> WordArray2.array -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 299.11-299.16 *)
val WordArray2.modifyi: Array2.traversal -> (int * int * word -> word) -> {base: WordArray2.array, col: int, ncols: int option, nrows: int option, row: int} -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 296.11-296.17 *)
val WordArray2.nCols: WordArray2.array -> int (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 38.11-38.15 *)
val WordArray2.nRows: WordArray2.array -> int (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 36.11-36.15 *)
val WordArray2.row: WordArray2.array * int -> WordVector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 222.11-222.13 *)
val WordArray2.sub: WordArray2.array * int * int -> word (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 182.14-182.16 *)
val WordArray2.tabulate: Array2.traversal -> int * int * (int * int -> word) -> WordArray2.array (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 301.11-301.18 *)
val WordArray2.update: WordArray2.array * int * int * word -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array2.sml 184.14-184.19 *)
structure WordArraySlice: MONO_ARRAY_SLICE where type array = WordArray.array where type elem = word where type slice = WordArraySlice.slice where type vector = WordVector.vector where type vector_slice = WordVectorSlice.slice (* @ $(SML_LIB)/basis/libs/basis-extra/top-level/basis.sml 235.17-235.30 *)
type WordArraySlice.array = WordArray.array (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array.fun 35.18-35.22 *)
type WordArraySlice.elem = word (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array.fun 34.18-34.21 *)
type WordArraySlice.slice = WordArraySlice.slice (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array.fun 36.18-36.22 *)
type WordArraySlice.vector = WordVector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array.fun 37.18-37.23 *)
type WordArraySlice.vector_slice = WordVectorSlice.slice (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-array.fun 38.18-38.29 *)
val WordArraySlice.all: (word -> bool) -> WordArraySlice.slice -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 235.17-235.19 *)
val WordArraySlice.app: (word -> unit) -> WordArraySlice.slice -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 226.17-226.19 *)
val WordArraySlice.appi: (int * word -> unit) -> WordArraySlice.slice -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 225.17-225.20 *)
val WordArraySlice.base: WordArraySlice.slice -> WordArray.array * int * int (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 208.17-208.20 *)
val WordArraySlice.collate: (word * word -> order) -> WordArraySlice.slice * WordArraySlice.slice -> order (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 236.17-236.23 *)
val WordArraySlice.copy: {di: int, dst: WordArray.array, src: WordArraySlice.slice} -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 185.17-185.20 *)
val WordArraySlice.copyVec: {di: int, dst: WordArray.array, src: WordVectorSlice.slice} -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array.sml 28.17-28.23 *)
val WordArraySlice.exists: (word -> bool) -> WordArraySlice.slice -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 233.17-233.22 *)
val WordArraySlice.find: (word -> bool) -> WordArraySlice.slice -> word option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 231.17-231.20 *)
val WordArraySlice.findi: (int * word -> bool) -> WordArraySlice.slice -> (int * word) option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 229.17-229.21 *)
val WordArraySlice.foldl: (word * 'a -> 'a) -> 'a -> WordArraySlice.slice -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 223.17-223.21 *)
val WordArraySlice.foldli: (int * word * 'a -> 'a) -> 'a -> WordArraySlice.slice -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 221.17-221.22 *)
val WordArraySlice.foldr: (word * 'a -> 'a) -> 'a -> WordArraySlice.slice -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 224.17-224.21 *)
val WordArraySlice.foldri: (int * word * 'a -> 'a) -> 'a -> WordArraySlice.slice -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 222.17-222.22 *)
val WordArraySlice.full: WordArray.array -> WordArraySlice.slice (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 192.17-192.20 *)
val WordArraySlice.getItem: WordArraySlice.slice -> (word * WordArraySlice.slice) option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 220.17-220.23 *)
val WordArraySlice.isEmpty: WordArraySlice.slice -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 219.17-219.23 *)
val WordArraySlice.length: WordArraySlice.slice -> int (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 134.17-134.22 *)
val WordArraySlice.modify: (word -> word) -> WordArraySlice.slice -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array.sml 31.17-31.22 *)
val WordArraySlice.modifyi: (int * word -> word) -> WordArraySlice.slice -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/array.sml 30.17-30.23 *)
val WordArraySlice.slice: WordArray.array * int * int option -> WordArraySlice.slice (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 206.17-206.21 *)
val WordArraySlice.sub: WordArraySlice.slice * int -> word (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 142.17-142.19 *)
val WordArraySlice.subslice: WordArraySlice.slice * int * int option -> WordArraySlice.slice (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 199.17-199.24 *)
val WordArraySlice.update: WordArraySlice.slice * int * word -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 155.17-155.22 *)
val WordArraySlice.vector: WordArraySlice.slice -> WordVector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/array.sml 27.17-27.22 *)
structure WordVector: MONO_VECTOR where type elem = word where type vector = WordVector.vector (* @ $(SML_LIB)/basis/libs/basis-2002/top-level/top-level.sml 72.11-72.20 *)
type WordVector.elem = word (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-vector.fun 35.12-35.15 *)
type WordVector.vector = WordVector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-vector.fun 36.12-36.17 *)
val WordVector.all: (word -> bool) -> WordVector.vector -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 476.13-476.15 *)
val WordVector.app: (word -> unit) -> WordVector.vector -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 464.13-464.15 *)
val WordVector.appi: (int * word -> unit) -> WordVector.vector -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 463.13-463.16 *)
val WordVector.collate: (word * word -> order) -> WordVector.vector * WordVector.vector -> order (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 477.13-477.19 *)
val WordVector.concat: WordVector.vector list -> WordVector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 462.13-462.18 *)
val WordVector.exists: (word -> bool) -> WordVector.vector -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 474.13-474.18 *)
val WordVector.find: (word -> bool) -> WordVector.vector -> word option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 472.13-472.16 *)
val WordVector.findi: (int * word -> bool) -> WordVector.vector -> (int * word) option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 471.13-471.17 *)
val WordVector.foldl: (word * 'a -> 'a) -> 'a -> WordVector.vector -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 468.13-468.17 *)
val WordVector.foldli: (int * word * 'a -> 'a) -> 'a -> WordVector.vector -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 467.13-467.18 *)
val WordVector.foldr: (word * 'a -> 'a) -> 'a -> WordVector.vector -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 470.13-470.17 *)
val WordVector.foldri: (int * word * 'a -> 'a) -> 'a -> WordVector.vector -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 469.13-469.18 *)
val WordVector.fromList: word list -> WordVector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 122.11-122.18 *)
val WordVector.length: WordVector.vector -> int (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 90.11-90.16 *)
val WordVector.map: (word -> word) -> WordVector.vector -> WordVector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 466.13-466.15 *)
val WordVector.mapi: (int * word -> word) -> WordVector.vector -> WordVector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 465.13-465.16 *)
val WordVector.maxLen: int (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 88.11-88.16 *)
val WordVector.sub: WordVector.vector * int -> word (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 450.13-450.15 *)
val WordVector.tabulate: int * (int -> word) -> WordVector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 114.11-114.18 *)
val WordVector.update: WordVector.vector * int * word -> WordVector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/vector.sml 30.11-30.16 *)
structure WordVectorSlice: MONO_VECTOR_SLICE where type elem = word where type slice = WordVectorSlice.slice where type vector = WordVector.vector (* @ $(SML_LIB)/basis/libs/basis-extra/top-level/basis.sml 237.17-237.31 *)
type WordVectorSlice.elem = word (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-vector.fun 43.18-43.21 *)
type WordVectorSlice.slice = WordVectorSlice.slice (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-vector.fun 45.18-45.22 *)
type WordVectorSlice.vector = WordVector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/mono-vector.fun 44.18-44.23 *)
val WordVectorSlice.all: (word -> bool) -> WordVectorSlice.slice -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 235.17-235.19 *)
val WordVectorSlice.app: (word -> unit) -> WordVectorSlice.slice -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 226.17-226.19 *)
val WordVectorSlice.appi: (int * word -> unit) -> WordVectorSlice.slice -> unit (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 225.17-225.20 *)
val WordVectorSlice.base: WordVectorSlice.slice -> WordVector.vector * int * int (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 208.17-208.20 *)
val WordVectorSlice.collate: (word * word -> order) -> WordVectorSlice.slice * WordVectorSlice.slice -> order (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 236.17-236.23 *)
val WordVectorSlice.concat: WordVectorSlice.slice list -> WordVector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 240.17-240.22 *)
val WordVectorSlice.exists: (word -> bool) -> WordVectorSlice.slice -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 233.17-233.22 *)
val WordVectorSlice.find: (word -> bool) -> WordVectorSlice.slice -> word option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 231.17-231.20 *)
val WordVectorSlice.findi: (int * word -> bool) -> WordVectorSlice.slice -> (int * word) option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 229.17-229.21 *)
val WordVectorSlice.foldl: (word * 'a -> 'a) -> 'a -> WordVectorSlice.slice -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 223.17-223.21 *)
val WordVectorSlice.foldli: (int * word * 'a -> 'a) -> 'a -> WordVectorSlice.slice -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 221.17-221.22 *)
val WordVectorSlice.foldr: (word * 'a -> 'a) -> 'a -> WordVectorSlice.slice -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 224.17-224.21 *)
val WordVectorSlice.foldri: (int * word * 'a -> 'a) -> 'a -> WordVectorSlice.slice -> 'a (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 222.17-222.22 *)
val WordVectorSlice.full: WordVector.vector -> WordVectorSlice.slice (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 192.17-192.20 *)
val WordVectorSlice.getItem: WordVectorSlice.slice -> (word * WordVectorSlice.slice) option (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 220.17-220.23 *)
val WordVectorSlice.isEmpty: WordVectorSlice.slice -> bool (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 219.17-219.23 *)
val WordVectorSlice.length: WordVectorSlice.slice -> int (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 134.17-134.22 *)
val WordVectorSlice.map: (word -> word) -> WordVectorSlice.slice -> WordVector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 228.17-228.19 *)
val WordVectorSlice.mapi: (int * word -> word) -> WordVectorSlice.slice -> WordVector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 227.17-227.20 *)
val WordVectorSlice.slice: WordVector.vector * int * int option -> WordVectorSlice.slice (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 206.17-206.21 *)
val WordVectorSlice.sub: WordVectorSlice.slice * int -> word (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 142.17-142.19 *)
val WordVectorSlice.subslice: WordVectorSlice.slice * int * int option -> WordVectorSlice.slice (* @ $(SML_LIB)/basis/arrays-and-vectors/sequence.fun 199.17-199.24 *)
val WordVectorSlice.vector: WordVectorSlice.slice -> WordVector.vector (* @ $(SML_LIB)/basis/arrays-and-vectors/vector.sml 21.17-21.22 *)
functor ImperativeIO
   (_arg_ImperativeIO:
       sig
          structure Array: MONO_ARRAY
          structure StreamIO: STREAM_IO where type elem = _sig.Array.elem
          structure Vector: MONO_VECTOR where type elem = _sig.Array.elem where type vector = _sig.Array.vector
       end):
   IMPERATIVE_IO where type StreamIO.elem = _arg_ImperativeIO.Vector.elem where type StreamIO.instream = _arg_ImperativeIO.StreamIO.instream where type StreamIO.out_pos = _arg_ImperativeIO.StreamIO.out_pos where type StreamIO.outstream = _arg_ImperativeIO.StreamIO.outstream where type StreamIO.pos = _arg_ImperativeIO.StreamIO.pos where type StreamIO.reader = _arg_ImperativeIO.StreamIO.reader where type StreamIO.vector = _arg_ImperativeIO.StreamIO.vector where type StreamIO.writer = _arg_ImperativeIO.StreamIO.writer where type instream = _res_ImperativeIO.instream where type outstream = _res_ImperativeIO.outstream
   (* @ $(SML_LIB)/basis/libs/basis-2002/top-level/basis-funs.sml 13.9-13.20 *)
functor PrimIO
   (_arg_PrimIO:
       sig
          eqtype pos
          val compare: _sig.pos * _sig.pos -> order
          val someElem: _sig.Array.elem
          structure Array: MONO_ARRAY
          structure ArraySlice: MONO_ARRAY_SLICE where type array = _sig.Array.array where type elem = _sig.Array.elem where type vector = _sig.Array.vector
          structure Vector: MONO_VECTOR where type elem = _sig.Array.elem where type vector = _sig.Array.vector
          structure VectorSlice: MONO_VECTOR_SLICE where type elem = _sig.Array.elem where type slice = _sig.ArraySlice.vector_slice where type vector = _sig.Array.vector
       end):
   PRIM_IO where type array = _arg_PrimIO.ArraySlice.array where type array_slice = _arg_PrimIO.ArraySlice.slice where type elem = _arg_PrimIO.VectorSlice.elem where type pos = _arg_PrimIO.pos where type reader = _res_PrimIO.reader where type vector = _arg_PrimIO.VectorSlice.vector where type vector_slice = _arg_PrimIO.VectorSlice.slice where type writer = _res_PrimIO.writer
   (* @ $(SML_LIB)/basis/libs/basis-2002/top-level/basis-funs.sml 11.9-11.14 *)
functor StreamIO
   (_arg_StreamIO:
       sig
          val someElem: _sig.Array.elem
          structure Array: MONO_ARRAY
          structure ArraySlice: MONO_ARRAY_SLICE where type array = _sig.Array.array where type elem = _sig.Array.elem where type vector = _sig.Array.vector
          structure PrimIO: PRIM_IO where type array = _sig.Array.array where type array_slice = _sig.ArraySlice.slice where type elem = _sig.Array.elem where type vector = _sig.Array.vector where type vector_slice = _sig.ArraySlice.vector_slice
          structure Vector: MONO_VECTOR where type elem = _sig.Array.elem where type vector = _sig.Array.vector
          structure VectorSlice: MONO_VECTOR_SLICE where type elem = _sig.Array.elem where type slice = _sig.ArraySlice.vector_slice where type vector = _sig.Array.vector
       end):
   STREAM_IO where type elem = _arg_StreamIO.VectorSlice.elem where type instream = _res_StreamIO.instream where type out_pos = _res_StreamIO.out_pos where type outstream = _res_StreamIO.outstream where type pos = _arg_StreamIO.PrimIO.pos where type reader = _arg_StreamIO.PrimIO.reader where type vector = _arg_StreamIO.VectorSlice.vector where type writer = _arg_StreamIO.PrimIO.writer
   (* @ $(SML_LIB)/basis/libs/basis-2002/top-level/basis-funs.sml 12.9-12.16 *)
